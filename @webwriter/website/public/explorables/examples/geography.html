<!DOCTYPE html><html id="ww-598817e8-74f9-4e52-b624-185dd56432c9" lang="en"><head><meta charset="utf-8" /><meta content="webwriter@1.0.0" name="generator" /><style data-ww-theme="base" blocking="render">html {  background: #f4f4f5;}body {  margin: 20px auto;  max-width: 840px;  padding: 19px;  background: white;  box-sizing: border-box;  border: 1px solid rgba(0, 0, 0, 0.1);  font-size: 1.15rem;  line-height: 1.5;  font-family: -apple-system, BlinkMacSystemFont, "Avenir Next", Avenir,  "Nimbus Sans L", Roboto, "Noto Sans", "Segoe UI", Arial, Helvetica,  "Helvetica Neue", sans-serif;}figure {  margin: 0;}figure > script {  display: block;  font-family: monospace;  border: 2px solid darkgray;  border-radius: 0.25rem;  font-size: 0.875rem;  padding: 0.5rem;  white-space: pre;  overflow: scroll;  height: 300px;  resize: vertical;  width: 100%;  box-sizing: border-box;}figure > embed {  aspect-ratio: 1/1.4142;}figure > :is(audio, video, picture, img, picture > img, embed, script) {  display: block;  margin: 0 auto;}figcaption {  text-align: center;  font-size: 0.875rem;  margin-top: 0.125rem;}kbd {  border: 0;  outline: 0;  vertical-align: baseline;  background: transparent;  padding: 0 5px;  background-color: #f7f7f7;  border: 1px solid #ccc;  border-radius: 3px;  box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px #fff inset;  color: #333;  display: inline-block;  font-family: monospace, sans-serif;  font-size: 0.75rem;  font-weight: 600;  line-height: 1.25;  margin: 0 0.1em;  padding: 0.1em 0.6em;  text-shadow: 0 1px 0 #fff;  user-select: none;}blockquote {  padding: 0.4rem 0.8rem;  border-left: 10px solid #ccc;  color: var(--text-light);}details {  border-left: 2px solid black;  padding-left: 1ch;}details p {  margin: 0;}picture {  width: 100%;  display: block;}iframe, audio, video {  width: 100%;  aspect-ratio: 16/9;}iframe {  border: none;}img[src] {  width: 100%;  aspect-ratio: auto;  max-height: 500px;  object-fit: contain;}p {  margin: 0;  min-height: 1lh;}body > * {  margin-block: 1rem;}svg {  aspect-ratio: 16/9;  width: 100%;}table {  width: 100%;}</style><script type="module" data-ww-editing="bundle">/**
 * @license
 * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
if (!ShadowRoot.prototype.createElement) {
  const NativeHTMLElement = window.HTMLElement;
  const nativeDefine = window.customElements.define;
  const nativeGet = window.customElements.get;
  const nativeRegistry = window.customElements;

  const definitionForElement = new WeakMap();
  const pendingRegistryForElement = new WeakMap();
  const globalDefinitionForConstructor = new WeakMap();
  // TBD: This part of the spec proposal is unclear:
  // > Another option for looking up registries is to store an element's
  // > originating registry with the element. The Chrome DOM team was concerned
  // > about the small additional memory overhead on all elements. Looking up the
  // > root avoids this.
  const scopeForElement = new WeakMap();

  // Constructable CE registry class, which uses the native CE registry to
  // register stand-in elements that can delegate out to CE classes registered
  // in scoped registries
  window.CustomElementRegistry = class {
    constructor() {
      this._definitionsByTag = new Map();
      this._definitionsByClass = new Map();
      this._whenDefinedPromises = new Map();
      this._awaitingUpgrade = new Map();
    }

    define(tagName, elementClass) {
      tagName = tagName.toLowerCase();
      if (this._getDefinition(tagName) !== undefined) {
        throw new DOMException(
          `Failed to execute 'define' on 'CustomElementRegistry': the name "${tagName}" has already been used with this registry`
        );
      }
      if (this._definitionsByClass.get(elementClass) !== undefined) {
        throw new DOMException(
          `Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry`
        );
      }
      // Since observedAttributes can't change, we approximate it by patching
      // set/remove/toggleAttribute on the user's class
      const attributeChangedCallback =
        elementClass.prototype.attributeChangedCallback;
      const observedAttributes = new Set(elementClass.observedAttributes || []);
      patchAttributes(
        elementClass,
        observedAttributes,
        attributeChangedCallback
      );
      // Register the definition
      const definition = {
        elementClass,
        connectedCallback: elementClass.prototype.connectedCallback,
        disconnectedCallback: elementClass.prototype.disconnectedCallback,
        adoptedCallback: elementClass.prototype.adoptedCallback,
        attributeChangedCallback,
        'formAssociated': elementClass['formAssociated'],
        'formAssociatedCallback':
          elementClass.prototype['formAssociatedCallback'],
        'formDisabledCallback': elementClass.prototype['formDisabledCallback'],
        'formResetCallback': elementClass.prototype['formResetCallback'],
        'formStateRestoreCallback':
          elementClass.prototype['formStateRestoreCallback'],
        observedAttributes,
      };
      this._definitionsByTag.set(tagName, definition);
      this._definitionsByClass.set(elementClass, definition);
      // Register a stand-in class which will handle the registry lookup & delegation
      let standInClass = nativeGet.call(nativeRegistry, tagName);
      if (!standInClass) {
        standInClass = createStandInElement(tagName);
        nativeDefine.call(nativeRegistry, tagName, standInClass);
      }
      if (this === window.customElements) {
        globalDefinitionForConstructor.set(elementClass, definition);
        definition.standInClass = standInClass;
      }
      // Upgrade any elements created in this scope before define was called
      const awaiting = this._awaitingUpgrade.get(tagName);
      if (awaiting) {
        this._awaitingUpgrade.delete(tagName);
        for (const element of awaiting) {
          pendingRegistryForElement.delete(element);
          customize(element, definition, true);
        }
      }
      // Flush whenDefined callbacks
      const info = this._whenDefinedPromises.get(tagName);
      if (info !== undefined) {
        info.resolve(elementClass);
        this._whenDefinedPromises.delete(tagName);
      }
      return elementClass;
    }

    upgrade() {
      creationContext.push(this);
      nativeRegistry.upgrade.apply(nativeRegistry, arguments);
      creationContext.pop();
    }

    get(tagName) {
      const definition = this._definitionsByTag.get(tagName);
      return definition?.elementClass;
    }

    _getDefinition(tagName) {
      return this._definitionsByTag.get(tagName);
    }

    whenDefined(tagName) {
      const definition = this._getDefinition(tagName);
      if (definition !== undefined) {
        return Promise.resolve(definition.elementClass);
      }
      let info = this._whenDefinedPromises.get(tagName);
      if (info === undefined) {
        info = {};
        info.promise = new Promise((r) => (info.resolve = r));
        this._whenDefinedPromises.set(tagName, info);
      }
      return info.promise;
    }

    _upgradeWhenDefined(element, tagName, shouldUpgrade) {
      let awaiting = this._awaitingUpgrade.get(tagName);
      if (!awaiting) {
        this._awaitingUpgrade.set(tagName, (awaiting = new Set()));
      }
      if (shouldUpgrade) {
        awaiting.add(element);
      } else {
        awaiting.delete(element);
      }
    }
  };

  // User extends this HTMLElement, which returns the CE being upgraded
  let upgradingInstance;
  window.HTMLElement = function HTMLElement() {
    // Upgrading case: the StandInElement constructor was run by the browser's
    // native custom elements and we're in the process of running the
    // "constructor-call trick" on the natively constructed instance, so just
    // return that here
    let instance = upgradingInstance;
    if (instance) {
      upgradingInstance = undefined;
      return instance;
    }
    // Construction case: we need to construct the StandInElement and return
    // it; note the current spec proposal only allows new'ing the constructor
    // of elements registered with the global registry
    const definition = globalDefinitionForConstructor.get(this.constructor);
    if (!definition) {
      throw new TypeError(
        'Illegal constructor (custom element class must be registered with global customElements registry to be newable)'
      );
    }
    instance = Reflect.construct(
      NativeHTMLElement,
      [],
      definition.standInClass
    );
    Object.setPrototypeOf(instance, this.constructor.prototype);
    definitionForElement.set(instance, definition);
    return instance;
  };
  window.HTMLElement.prototype = NativeHTMLElement.prototype;

  // Helpers to return the scope for a node where its registry would be located
  const isValidScope = (node) =>
    node === document || node instanceof ShadowRoot;
  const registryForNode = (node) => {
    // TODO: the algorithm for finding the scope is a bit up in the air; assigning
    // a one-time scope at creation time would require walking every tree ever
    // created, which is avoided for now
    let scope = node.getRootNode();
    // If we're not attached to the document (i.e. in a disconnected tree or
    // fragment), we need to get the scope from the creation context; that should
    // be a Document or ShadowRoot, unless it was created via innerHTML
    if (!isValidScope(scope)) {
      const context = creationContext[creationContext.length - 1];
      // When upgrading via registry.upgrade(), the registry itself is put on the
      // creationContext stack
      if (context instanceof CustomElementRegistry) {
        return context;
      }
      // Otherwise, get the root node of the element this was created from
      scope = context.getRootNode();
      // The creation context wasn't a Document or ShadowRoot or in one; this
      // means we're being innerHTML'ed into a disconnected element; for now, we
      // hope that root node was created imperatively, where we stash _its_
      // scopeForElement. Beyond that, we'd need more costly tracking.
      if (!isValidScope(scope)) {
        scope = scopeForElement.get(scope)?.getRootNode() || document;
      }
    }
    return scope.customElements;
  };

  // Helper to create stand-in element for each tagName registered that delegates
  // out to the registry for the given element
  const createStandInElement = (tagName) => {
    return class ScopedCustomElementBase {
      static get ['formAssociated']() {
        return true;
      }
      constructor() {
        // Create a raw HTMLElement first
        const instance = Reflect.construct(
          NativeHTMLElement,
          [],
          this.constructor
        );
        // We need to install the minimum HTMLElement prototype so that
        // scopeForNode can use DOM API to determine our construction scope;
        // upgrade will eventually install the full CE prototype
        Object.setPrototypeOf(instance, HTMLElement.prototype);
        // Get the node's scope, and its registry (falls back to global registry)
        const registry = registryForNode(instance) || window.customElements;
        const definition = registry._getDefinition(tagName);
        if (definition) {
          customize(instance, definition);
        } else {
          pendingRegistryForElement.set(instance, registry);
        }
        return instance;
      }

      connectedCallback() {
        const definition = definitionForElement.get(this);
        if (definition) {
          // Delegate out to user callback
          definition.connectedCallback &&
            definition.connectedCallback.apply(this, arguments);
        } else {
          // Register for upgrade when defined (only when connected, so we don't leak)
          pendingRegistryForElement
            .get(this)
            ._upgradeWhenDefined(this, tagName, true);
        }
      }

      disconnectedCallback() {
        const definition = definitionForElement.get(this);
        if (definition) {
          // Delegate out to user callback
          definition.disconnectedCallback &&
            definition.disconnectedCallback.apply(this, arguments);
        } else {
          // Un-register for upgrade when defined (so we don't leak)
          pendingRegistryForElement
            .get(this)
            ._upgradeWhenDefined(this, tagName, false);
        }
      }

      adoptedCallback() {
        const definition = definitionForElement.get(this);
        definition?.adoptedCallback?.apply(this, arguments);
      }

      // Form-associated custom elements lifecycle methods
      ['formAssociatedCallback']() {
        const definition = definitionForElement.get(this);
        if (definition && definition['formAssociated']) {
          definition?.['formAssociatedCallback']?.apply(this, arguments);
        }
      }

      ['formDisabledCallback']() {
        const definition = definitionForElement.get(this);
        if (definition?.['formAssociated']) {
          definition?.['formDisabledCallback']?.apply(this, arguments);
        }
      }

      ['formResetCallback']() {
        const definition = definitionForElement.get(this);
        if (definition?.['formAssociated']) {
          definition?.['formResetCallback']?.apply(this, arguments);
        }
      }

      ['formStateRestoreCallback']() {
        const definition = definitionForElement.get(this);
        if (definition?.['formAssociated']) {
          definition?.['formStateRestoreCallback']?.apply(this, arguments);
        }
      }

      // no attributeChangedCallback or observedAttributes since these
      // are simulated via setAttribute/removeAttribute patches
    };
  };

  // Helper to patch CE class setAttribute/getAttribute/toggleAttribute to
  // implement attributeChangedCallback
  const patchAttributes = (
    elementClass,
    observedAttributes,
    attributeChangedCallback
  ) => {
    if (
      observedAttributes.size === 0 ||
      attributeChangedCallback === undefined
    ) {
      return;
    }
    const setAttribute = elementClass.prototype.setAttribute;
    if (setAttribute) {
      elementClass.prototype.setAttribute = function (n, value) {
        const name = n.toLowerCase();
        if (observedAttributes.has(name)) {
          const old = this.getAttribute(name);
          setAttribute.call(this, name, value);
          attributeChangedCallback.call(this, name, old, value);
        } else {
          setAttribute.call(this, name, value);
        }
      };
    }
    const removeAttribute = elementClass.prototype.removeAttribute;
    if (removeAttribute) {
      elementClass.prototype.removeAttribute = function (n) {
        const name = n.toLowerCase();
        if (observedAttributes.has(name)) {
          const old = this.getAttribute(name);
          removeAttribute.call(this, name);
          attributeChangedCallback.call(this, name, old, null);
        } else {
          removeAttribute.call(this, name);
        }
      };
    }
    const toggleAttribute = elementClass.prototype.toggleAttribute;
    if (toggleAttribute) {
      elementClass.prototype.toggleAttribute = function (n, force) {
        const name = n.toLowerCase();
        if (observedAttributes.has(name)) {
          const old = this.getAttribute(name);
          toggleAttribute.call(this, name, force);
          const newValue = this.getAttribute(name);
          attributeChangedCallback.call(this, name, old, newValue);
        } else {
          toggleAttribute.call(this, name, force);
        }
      };
    }
  };

  // Helper to patch CE class hierarchy changing those CE classes created before applying the polyfill
  // to make them work with the new patched CustomElementsRegistry
  const patchHTMLElement = (elementClass) => {
    const parentClass = Object.getPrototypeOf(elementClass);

    if (parentClass !== window.HTMLElement) {
      if (parentClass === NativeHTMLElement) {
        return Object.setPrototypeOf(elementClass, window.HTMLElement);
      }

      return patchHTMLElement(parentClass);
    }
  };

  // Helper to upgrade an instance with a CE definition using "constructor call trick"
  const customize = (instance, definition, isUpgrade = false) => {
    Object.setPrototypeOf(instance, definition.elementClass.prototype);
    definitionForElement.set(instance, definition);
    upgradingInstance = instance;
    try {
      new definition.elementClass();
    } catch (_) {
      patchHTMLElement(definition.elementClass);
      new definition.elementClass();
    }
    if (definition.attributeChangedCallback) {
      // Approximate observedAttributes from the user class, since the stand-in element had none
      definition.observedAttributes.forEach((attr) => {
        if (instance.hasAttribute(attr)) {
          definition.attributeChangedCallback.call(
            instance,
            attr,
            null,
            instance.getAttribute(attr)
          );
        }
      });
    }
    if (isUpgrade && definition.connectedCallback && instance.isConnected) {
      definition.connectedCallback.call(instance);
    }
  };

  // Patch attachShadow to set customElements on shadowRoot when provided
  const nativeAttachShadow = Element.prototype.attachShadow;
  Element.prototype.attachShadow = function (init) {
    const shadowRoot = nativeAttachShadow.apply(this, arguments);
    if (init.customElements) {
      shadowRoot.customElements = init.customElements;
    }
    return shadowRoot;
  };

  // Install scoped creation API on Element & ShadowRoot
  let creationContext = [document];
  const installScopedCreationMethod = (ctor, method, from = undefined) => {
    const native = (from ? Object.getPrototypeOf(from) : ctor.prototype)[
      method
    ];
    ctor.prototype[method] = function () {
      creationContext.push(this);
      const ret = native.apply(from || this, arguments);
      // For disconnected elements, note their creation scope so that e.g.
      // innerHTML into them will use the correct scope; note that
      // insertAdjacentHTML doesn't return an element, but that's fine since
      // it will have a parent that should have a scope
      if (ret !== undefined) {
        scopeForElement.set(ret, this);
      }
      creationContext.pop();
      return ret;
    };
  };
  installScopedCreationMethod(ShadowRoot, 'createElement', document);
  installScopedCreationMethod(ShadowRoot, 'importNode', document);
  installScopedCreationMethod(Element, 'insertAdjacentHTML');

  // Install scoped innerHTML on Element & ShadowRoot
  const installScopedCreationSetter = (ctor, name) => {
    const descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, name);
    Object.defineProperty(ctor.prototype, name, {
      ...descriptor,
      set(value) {
        creationContext.push(this);
        descriptor.set.call(this, value);
        creationContext.pop();
      },
    });
  };
  installScopedCreationSetter(Element, 'innerHTML');
  installScopedCreationSetter(ShadowRoot, 'innerHTML');

  // Install global registry
  Object.defineProperty(window, 'customElements', {
    value: new CustomElementRegistry(),
    configurable: true,
    writable: true,
  });

  if (
    !!window['ElementInternals'] &&
    !!window['ElementInternals'].prototype['setFormValue']
  ) {
    const internalsToHostMap = new WeakMap();
    const attachInternals = HTMLElement.prototype['attachInternals'];
    const methods = [
      'setFormValue',
      'setValidity',
      'checkValidity',
      'reportValidity',
    ];

    HTMLElement.prototype['attachInternals'] = function (...args) {
      const internals = attachInternals.call(this, ...args);
      internalsToHostMap.set(internals, this);
      return internals;
    };

    methods.forEach((method) => {
      const proto = window['ElementInternals'].prototype;
      const originalMethod = proto[method];

      proto[method] = function (...args) {
        const host = internalsToHostMap.get(this);
        const definition = definitionForElement.get(host);
        if (definition['formAssociated'] === true) {
          return originalMethod?.call(this, ...args);
        } else {
          throw new DOMException(
            `Failed to execute ${originalMethod} on 'ElementInternals': The target element is not a form-associated custom element.`
          );
        }
      };
    });

    // Emulate the native RadioNodeList object
    class RadioNodeList extends Array {
      constructor(elements) {
        super(...elements);
        this._elements = elements;
      }

      get ['value']() {
        return (
          this._elements.find((element) => element['checked'] === true)
            ?.value || ''
        );
      }
    }

    // Emulate the native HTMLFormControlsCollection object
    class HTMLFormControlsCollection {
      constructor(elements) {
        const entries = new Map();
        elements.forEach((element, index) => {
          const name = element.getAttribute('name');
          const nameReference = entries.get(name) || [];
          this[+index] = element;
          nameReference.push(element);
          entries.set(name, nameReference);
        });
        this['length'] = elements.length;
        entries.forEach((value, key) => {
          if (!value) return;
          if (value.length === 1) {
            this[key] = value[0];
          } else {
            this[key] = new RadioNodeList(value);
          }
        });
      }

      ['namedItem'](key) {
        return this[key];
      }
    }

    // Override the built-in HTMLFormElements.prototype.elements getter
    const formElementsDescriptor = Object.getOwnPropertyDescriptor(
      HTMLFormElement.prototype,
      'elements'
    );

    Object.defineProperty(HTMLFormElement.prototype, 'elements', {
      get: function () {
        const nativeElements = formElementsDescriptor.get.call(this, []);

        const include = [];

        for (const element of nativeElements) {
          const definition = definitionForElement.get(element);

          // Only purposefully formAssociated elements or built-ins will feature in elements
          if (!definition || definition['formAssociated'] === true) {
            include.push(element);
          }
        }

        return new HTMLFormControlsCollection(include);
      },
    });
  }
}
;(function () {// https:/cdn.jsdelivr.net/npm/@webwriter/quiz@1.0.5/dist/widgets/webwriter-quiz.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i43 = 0, fns = array[flags >> 1], n63 = fns && fns.length; i43 < n63; i43++) flags & 1 ? fns[i43].call(self2) : value = fns[i43].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k33 = flags & 7, s33 = !!(flags & 8), p33 = !!(flags & 16);
  var j33 = k33 > 3 ? array.length + 1 : k33 ? s33 ? 1 : 2 : 0, key = __decoratorStrings[k33 + 5];
  var initializers = k33 > 3 && (array[j33 - 1] = []), extraInitializers = array[j33] || (array[j33] = []);
  var desc = k33 && (!p33 && !s33 && (target = target.prototype), k33 < 5 && (k33 > 3 || !p33) && __getOwnPropDesc(k33 < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x32) {
    return __privateSet(this, extra, x32);
  } }, name));
  k33 ? p33 && k33 < 4 && __name(extra, (k33 > 2 ? "set " : k33 > 1 ? "get " : "") + name) : __name(target, name);
  for (var i43 = decorators.length - 1; i43 >= 0; i43--) {
    ctx = __decoratorContext(k33, name, done = {}, array[3], extraInitializers);
    if (k33) {
      ctx.static = s33, ctx.private = p33, access = ctx.access = { has: p33 ? (x32) => __privateIn(target, x32) : (x32) => name in x32 };
      if (k33 ^ 3) access.get = p33 ? (x32) => (k33 ^ 1 ? __privateGet : __privateMethod)(x32, target, k33 ^ 4 ? extra : desc.get) : (x32) => x32[name];
      if (k33 > 2) access.set = p33 ? (x32, y33) => __privateSet(x32, target, y33, k33 ^ 4 ? extra : desc.set) : (x32, y33) => x32[name] = y33;
    }
    it = (0, decorators[i43])(k33 ? k33 < 4 ? p33 ? extra : desc[key] : k33 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k33 ^ 4 || it === void 0) __expectFn(it) && (k33 > 4 ? initializers.unshift(it) : k33 ? p33 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k33 || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p33 ? k33 ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t64, e73, o73) {
    if (this._$cssResult$ = true, o73 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t64, this.t = e73;
  }
  get styleSheet() {
    let t64 = this.o;
    const s33 = this.t;
    if (e && void 0 === t64) {
      const e73 = void 0 !== s33 && 1 === s33.length;
      e73 && (t64 = o.get(s33)), void 0 === t64 && ((this.o = t64 = new CSSStyleSheet()).replaceSync(this.cssText), e73 && o.set(s33, t64));
    }
    return t64;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t64) => new n("string" == typeof t64 ? t64 : t64 + "", void 0, s);
var i = (t64, ...e73) => {
  const o73 = 1 === t64.length ? t64[0] : e73.reduce((e83, s33, o83) => e83 + ((t73) => {
    if (true === t73._$cssResult$) return t73.cssText;
    if ("number" == typeof t73) return t73;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t73 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s33) + t64[o83 + 1], t64[0]);
  return new n(o73, t64, s);
};
var S = (s33, o73) => {
  if (e) s33.adoptedStyleSheets = o73.map((t64) => t64 instanceof CSSStyleSheet ? t64 : t64.styleSheet);
  else for (const e73 of o73) {
    const o83 = document.createElement("style"), n63 = t.litNonce;
    void 0 !== n63 && o83.setAttribute("nonce", n63), o83.textContent = e73.cssText, s33.appendChild(o83);
  }
};
var c = e ? (t64) => t64 : (t64) => t64 instanceof CSSStyleSheet ? ((t73) => {
  let e73 = "";
  for (const s33 of t73.cssRules) e73 += s33.cssText;
  return r(e73);
})(t64) : t64;
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t64, s33) => t64;
var u = { toAttribute(t64, s33) {
  switch (s33) {
    case Boolean:
      t64 = t64 ? l : null;
      break;
    case Object:
    case Array:
      t64 = null == t64 ? t64 : JSON.stringify(t64);
  }
  return t64;
}, fromAttribute(t64, s33) {
  let i43 = t64;
  switch (s33) {
    case Boolean:
      i43 = null !== t64;
      break;
    case Number:
      i43 = null === t64 ? null : Number(t64);
      break;
    case Object:
    case Array:
      try {
        i43 = JSON.parse(t64);
      } catch (t73) {
        i43 = null;
      }
  }
  return i43;
} };
var f = (t64, s33) => !i2(t64, s33);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
Symbol.metadata ??= Symbol("metadata"), a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b = class extends HTMLElement {
  static addInitializer(t64) {
    this._$Ei(), (this.l ??= []).push(t64);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t64, s33 = y) {
    if (s33.state && (s33.attribute = false), this._$Ei(), this.elementProperties.set(t64, s33), !s33.noAccessor) {
      const i43 = Symbol(), r73 = this.getPropertyDescriptor(t64, i43, s33);
      void 0 !== r73 && e2(this.prototype, t64, r73);
    }
  }
  static getPropertyDescriptor(t64, s33, i43) {
    const { get: e73, set: h53 } = r2(this.prototype, t64) ?? { get() {
      return this[s33];
    }, set(t73) {
      this[s33] = t73;
    } };
    return { get() {
      return e73?.call(this);
    }, set(s43) {
      const r73 = e73?.call(this);
      h53.call(this, s43), this.requestUpdate(t64, r73, i43);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t64) {
    return this.elementProperties.get(t64) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties"))) return;
    const t64 = n2(this);
    t64.finalize(), void 0 !== t64.l && (this.l = [...t64.l]), this.elementProperties = new Map(t64.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t73 = this.properties, s33 = [...h(t73), ...o2(t73)];
      for (const i43 of s33) this.createProperty(i43, t73[i43]);
    }
    const t64 = this[Symbol.metadata];
    if (null !== t64) {
      const s33 = litPropertyMetadata.get(t64);
      if (void 0 !== s33) for (const [t73, i43] of s33) this.elementProperties.set(t73, i43);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t73, s33] of this.elementProperties) {
      const i43 = this._$Eu(t73, s33);
      void 0 !== i43 && this._$Eh.set(i43, t73);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s33) {
    const i43 = [];
    if (Array.isArray(s33)) {
      const e73 = new Set(s33.flat(1 / 0).reverse());
      for (const s43 of e73) i43.unshift(c(s43));
    } else void 0 !== s33 && i43.push(c(s33));
    return i43;
  }
  static _$Eu(t64, s33) {
    const i43 = s33.attribute;
    return false === i43 ? void 0 : "string" == typeof i43 ? i43 : "string" == typeof t64 ? t64.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t64) => this.enableUpdating = t64), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t64) => t64(this));
  }
  addController(t64) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t64), void 0 !== this.renderRoot && this.isConnected && t64.hostConnected?.();
  }
  removeController(t64) {
    this._$EO?.delete(t64);
  }
  _$E_() {
    const t64 = /* @__PURE__ */ new Map(), s33 = this.constructor.elementProperties;
    for (const i43 of s33.keys()) this.hasOwnProperty(i43) && (t64.set(i43, this[i43]), delete this[i43]);
    t64.size > 0 && (this._$Ep = t64);
  }
  createRenderRoot() {
    const t64 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t64, this.constructor.elementStyles), t64;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t64) => t64.hostConnected?.());
  }
  enableUpdating(t64) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t64) => t64.hostDisconnected?.());
  }
  attributeChangedCallback(t64, s33, i43) {
    this._$AK(t64, i43);
  }
  _$EC(t64, s33) {
    const i43 = this.constructor.elementProperties.get(t64), e73 = this.constructor._$Eu(t64, i43);
    if (void 0 !== e73 && true === i43.reflect) {
      const r73 = (void 0 !== i43.converter?.toAttribute ? i43.converter : u).toAttribute(s33, i43.type);
      this._$Em = t64, null == r73 ? this.removeAttribute(e73) : this.setAttribute(e73, r73), this._$Em = null;
    }
  }
  _$AK(t64, s33) {
    const i43 = this.constructor, e73 = i43._$Eh.get(t64);
    if (void 0 !== e73 && this._$Em !== e73) {
      const t73 = i43.getPropertyOptions(e73), r73 = "function" == typeof t73.converter ? { fromAttribute: t73.converter } : void 0 !== t73.converter?.fromAttribute ? t73.converter : u;
      this._$Em = e73, this[e73] = r73.fromAttribute(s33, t73.type), this._$Em = null;
    }
  }
  requestUpdate(t64, s33, i43) {
    if (void 0 !== t64) {
      if (i43 ??= this.constructor.getPropertyOptions(t64), !(i43.hasChanged ?? f)(this[t64], s33)) return;
      this.P(t64, s33, i43);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t64, s33, i43) {
    this._$AL.has(t64) || this._$AL.set(t64, s33), true === i43.reflect && this._$Em !== t64 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t64);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t73) {
      Promise.reject(t73);
    }
    const t64 = this.scheduleUpdate();
    return null != t64 && await t64, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t83, s43] of this._$Ep) this[t83] = s43;
        this._$Ep = void 0;
      }
      const t73 = this.constructor.elementProperties;
      if (t73.size > 0) for (const [s43, i43] of t73) true !== i43.wrapped || this._$AL.has(s43) || void 0 === this[s43] || this.P(s43, this[s43], i43);
    }
    let t64 = false;
    const s33 = this._$AL;
    try {
      t64 = this.shouldUpdate(s33), t64 ? (this.willUpdate(s33), this._$EO?.forEach((t73) => t73.hostUpdate?.()), this.update(s33)) : this._$EU();
    } catch (s43) {
      throw t64 = false, this._$EU(), s43;
    }
    t64 && this._$AE(s33);
  }
  willUpdate(t64) {
  }
  _$AE(t64) {
    this._$EO?.forEach((t73) => t73.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t64)), this.updated(t64);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t64) {
    return true;
  }
  update(t64) {
    this._$Ej &&= this._$Ej.forEach((t73) => this._$EC(t73, this[t73])), this._$EU();
  }
  updated(t64) {
  }
  firstUpdated(t64) {
  }
};
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: b }), (a.reactiveElementVersions ??= []).push("2.0.4");
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t64) => t64 }) : void 0;
var f2 = "$lit$";
var v = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m = "?" + v;
var _ = `<${m}>`;
var w = document;
var lt = () => w.createComment("");
var st = (t64) => null === t64 || "object" != typeof t64 && "function" != typeof t64;
var g = Array.isArray;
var $ = (t64) => g(t64) || "function" == typeof t64?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t64) => (i43, ...s33) => ({ _$litType$: t64, strings: i43, values: s33 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t64, i43) {
  if (!g(t64) || !t64.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i43) : i43;
}
var U = (t64, i43) => {
  const s33 = t64.length - 1, e73 = [];
  let h53, o73 = 2 === i43 ? "<svg>" : 3 === i43 ? "<math>" : "", n63 = T;
  for (let i53 = 0; i53 < s33; i53++) {
    const s43 = t64[i53];
    let r73, l33, c53 = -1, a33 = 0;
    for (; a33 < s43.length && (n63.lastIndex = a33, l33 = n63.exec(s43), null !== l33); ) a33 = n63.lastIndex, n63 === T ? "!--" === l33[1] ? n63 = E : void 0 !== l33[1] ? n63 = k : void 0 !== l33[2] ? (M.test(l33[2]) && (h53 = RegExp("</" + l33[2], "g")), n63 = O) : void 0 !== l33[3] && (n63 = O) : n63 === O ? ">" === l33[0] ? (n63 = h53 ?? T, c53 = -1) : void 0 === l33[1] ? c53 = -2 : (c53 = n63.lastIndex - l33[2].length, r73 = l33[1], n63 = void 0 === l33[3] ? O : '"' === l33[3] ? j : S2) : n63 === j || n63 === S2 ? n63 = O : n63 === E || n63 === k ? n63 = T : (n63 = O, h53 = void 0);
    const u33 = n63 === O && t64[i53 + 1].startsWith("/>") ? " " : "";
    o73 += n63 === T ? s43 + _ : c53 >= 0 ? (e73.push(r73), s43.slice(0, c53) + f2 + s43.slice(c53) + v + u33) : s43 + v + (-2 === c53 ? i53 : u33);
  }
  return [N(t64, o73 + (t64[s33] || "<?>") + (2 === i43 ? "</svg>" : 3 === i43 ? "</math>" : "")), e73];
};
var B = class _B2 {
  constructor({ strings: t64, _$litType$: i43 }, s33) {
    let e73;
    this.parts = [];
    let h53 = 0, o73 = 0;
    const n63 = t64.length - 1, r73 = this.parts, [l33, a33] = U(t64, i43);
    if (this.el = _B2.createElement(l33, s33), I.currentNode = this.el.content, 2 === i43 || 3 === i43) {
      const t73 = this.el.content.firstChild;
      t73.replaceWith(...t73.childNodes);
    }
    for (; null !== (e73 = I.nextNode()) && r73.length < n63; ) {
      if (1 === e73.nodeType) {
        if (e73.hasAttributes()) for (const t73 of e73.getAttributeNames()) if (t73.endsWith(f2)) {
          const i53 = a33[o73++], s43 = e73.getAttribute(t73).split(v), n73 = /([.?@])?(.*)/.exec(i53);
          r73.push({ type: 1, index: h53, name: n73[2], strings: s43, ctor: "." === n73[1] ? Y : "?" === n73[1] ? Z : "@" === n73[1] ? q : G }), e73.removeAttribute(t73);
        } else t73.startsWith(v) && (r73.push({ type: 6, index: h53 }), e73.removeAttribute(t73));
        if (M.test(e73.tagName)) {
          const t73 = e73.textContent.split(v), i53 = t73.length - 1;
          if (i53 > 0) {
            e73.textContent = c3 ? c3.emptyScript : "";
            for (let s43 = 0; s43 < i53; s43++) e73.append(t73[s43], lt()), I.nextNode(), r73.push({ type: 2, index: ++h53 });
            e73.append(t73[i53], lt());
          }
        }
      } else if (8 === e73.nodeType) if (e73.data === m) r73.push({ type: 2, index: h53 });
      else {
        let t73 = -1;
        for (; -1 !== (t73 = e73.data.indexOf(v, t73 + 1)); ) r73.push({ type: 7, index: h53 }), t73 += v.length - 1;
      }
      h53++;
    }
  }
  static createElement(t64, i43) {
    const s33 = w.createElement("template");
    return s33.innerHTML = t64, s33;
  }
};
function z(t64, i43, s33 = t64, e73) {
  if (i43 === R) return i43;
  let h53 = void 0 !== e73 ? s33.o?.[e73] : s33.l;
  const o73 = st(i43) ? void 0 : i43._$litDirective$;
  return h53?.constructor !== o73 && (h53?._$AO?.(false), void 0 === o73 ? h53 = void 0 : (h53 = new o73(t64), h53._$AT(t64, s33, e73)), void 0 !== e73 ? (s33.o ??= [])[e73] = h53 : s33.l = h53), void 0 !== h53 && (i43 = z(t64, h53._$AS(t64, i43.values), h53, e73)), i43;
}
var F = class {
  constructor(t64, i43) {
    this._$AV = [], this._$AN = void 0, this._$AD = t64, this._$AM = i43;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t64) {
    const { el: { content: i43 }, parts: s33 } = this._$AD, e73 = (t64?.creationScope ?? w).importNode(i43, true);
    I.currentNode = e73;
    let h53 = I.nextNode(), o73 = 0, n63 = 0, r73 = s33[0];
    for (; void 0 !== r73; ) {
      if (o73 === r73.index) {
        let i53;
        2 === r73.type ? i53 = new et(h53, h53.nextSibling, this, t64) : 1 === r73.type ? i53 = new r73.ctor(h53, r73.name, r73.strings, this, t64) : 6 === r73.type && (i53 = new K(h53, this, t64)), this._$AV.push(i53), r73 = s33[++n63];
      }
      o73 !== r73?.index && (h53 = I.nextNode(), o73++);
    }
    return I.currentNode = w, e73;
  }
  p(t64) {
    let i43 = 0;
    for (const s33 of this._$AV) void 0 !== s33 && (void 0 !== s33.strings ? (s33._$AI(t64, s33, i43), i43 += s33.strings.length - 2) : s33._$AI(t64[i43])), i43++;
  }
};
var et = class _et2 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t64, i43, s33, e73) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t64, this._$AB = i43, this._$AM = s33, this.options = e73, this.v = e73?.isConnected ?? true;
  }
  get parentNode() {
    let t64 = this._$AA.parentNode;
    const i43 = this._$AM;
    return void 0 !== i43 && 11 === t64?.nodeType && (t64 = i43.parentNode), t64;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t64, i43 = this) {
    t64 = z(this, t64, i43), st(t64) ? t64 === D || null == t64 || "" === t64 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t64 !== this._$AH && t64 !== R && this._(t64) : void 0 !== t64._$litType$ ? this.$(t64) : void 0 !== t64.nodeType ? this.T(t64) : $(t64) ? this.k(t64) : this._(t64);
  }
  O(t64) {
    return this._$AA.parentNode.insertBefore(t64, this._$AB);
  }
  T(t64) {
    this._$AH !== t64 && (this._$AR(), this._$AH = this.O(t64));
  }
  _(t64) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t64 : this.T(w.createTextNode(t64)), this._$AH = t64;
  }
  $(t64) {
    const { values: i43, _$litType$: s33 } = t64, e73 = "number" == typeof s33 ? this._$AC(t64) : (void 0 === s33.el && (s33.el = B.createElement(N(s33.h, s33.h[0]), this.options)), s33);
    if (this._$AH?._$AD === e73) this._$AH.p(i43);
    else {
      const t73 = new F(e73, this), s43 = t73.u(this.options);
      t73.p(i43), this.T(s43), this._$AH = t73;
    }
  }
  _$AC(t64) {
    let i43 = V.get(t64.strings);
    return void 0 === i43 && V.set(t64.strings, i43 = new B(t64)), i43;
  }
  k(t64) {
    g(this._$AH) || (this._$AH = [], this._$AR());
    const i43 = this._$AH;
    let s33, e73 = 0;
    for (const h53 of t64) e73 === i43.length ? i43.push(s33 = new _et2(this.O(lt()), this.O(lt()), this, this.options)) : s33 = i43[e73], s33._$AI(h53), e73++;
    e73 < i43.length && (this._$AR(s33 && s33._$AB.nextSibling, e73), i43.length = e73);
  }
  _$AR(t64 = this._$AA.nextSibling, i43) {
    for (this._$AP?.(false, true, i43); t64 && t64 !== this._$AB; ) {
      const i53 = t64.nextSibling;
      t64.remove(), t64 = i53;
    }
  }
  setConnected(t64) {
    void 0 === this._$AM && (this.v = t64, this._$AP?.(t64));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t64, i43, s33, e73, h53) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t64, this.name = i43, this._$AM = e73, this.options = h53, s33.length > 2 || "" !== s33[0] || "" !== s33[1] ? (this._$AH = Array(s33.length - 1).fill(new String()), this.strings = s33) : this._$AH = D;
  }
  _$AI(t64, i43 = this, s33, e73) {
    const h53 = this.strings;
    let o73 = false;
    if (void 0 === h53) t64 = z(this, t64, i43, 0), o73 = !st(t64) || t64 !== this._$AH && t64 !== R, o73 && (this._$AH = t64);
    else {
      const e83 = t64;
      let n63, r73;
      for (t64 = h53[0], n63 = 0; n63 < h53.length - 1; n63++) r73 = z(this, e83[s33 + n63], i43, n63), r73 === R && (r73 = this._$AH[n63]), o73 ||= !st(r73) || r73 !== this._$AH[n63], r73 === D ? t64 = D : t64 !== D && (t64 += (r73 ?? "") + h53[n63 + 1]), this._$AH[n63] = r73;
    }
    o73 && !e73 && this.j(t64);
  }
  j(t64) {
    t64 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t64 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t64) {
    this.element[this.name] = t64 === D ? void 0 : t64;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t64) {
    this.element.toggleAttribute(this.name, !!t64 && t64 !== D);
  }
};
var q = class extends G {
  constructor(t64, i43, s33, e73, h53) {
    super(t64, i43, s33, e73, h53), this.type = 5;
  }
  _$AI(t64, i43 = this) {
    if ((t64 = z(this, t64, i43, 0) ?? D) === R) return;
    const s33 = this._$AH, e73 = t64 === D && s33 !== D || t64.capture !== s33.capture || t64.once !== s33.once || t64.passive !== s33.passive, h53 = t64 !== D && (s33 === D || e73);
    e73 && this.element.removeEventListener(this.name, this, s33), h53 && this.element.addEventListener(this.name, this, t64), this._$AH = t64;
  }
  handleEvent(t64) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t64) : this._$AH.handleEvent(t64);
  }
};
var K = class {
  constructor(t64, i43, s33) {
    this.element = t64, this.type = 6, this._$AN = void 0, this._$AM = i43, this.options = s33;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t64) {
    z(this, t64);
  }
};
var si = { M: f2, P: v, A: m, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t64, i43, s33) => {
  const e73 = s33?.renderBefore ?? i43;
  let h53 = e73._$litPart$;
  if (void 0 === h53) {
    const t73 = s33?.renderBefore ?? null;
    e73._$litPart$ = h53 = new et(i43.insertBefore(lt(), t73), t73, void 0, s33 ?? {});
  }
  return h53._$AI(t64), h53;
};
var h3 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t64 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t64.firstChild, t64;
  }
  update(t64) {
    const e73 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t64), this.o = Q(e73, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name2 = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart2 = (base) => [, , , __create2(base?.[__knownSymbol2("metadata")] ?? null)];
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError2("Function expected") : fn;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn2(fn || null)) });
var __decoratorMetadata2 = (array, target) => __defNormalProp2(target, __knownSymbol2("metadata"), array[3]);
var __runInitializers2 = (array, flags, self2, value) => {
  for (var i322 = 0, fns = array[flags >> 1], n522 = fns && fns.length; i322 < n522; i322++) flags & 1 ? fns[i322].call(self2) : value = fns[i322].call(self2, value);
  return value;
};
var __decorateElement2 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k222 = flags & 7, s222 = !!(flags & 8), p222 = !!(flags & 16);
  var j222 = k222 > 3 ? array.length + 1 : k222 ? s222 ? 1 : 2 : 0, key = __decoratorStrings2[k222 + 5];
  var initializers = k222 > 3 && (array[j222 - 1] = []), extraInitializers = array[j222] || (array[j222] = []);
  var desc = k222 && (!p222 && !s222 && (target = target.prototype), k222 < 5 && (k222 > 3 || !p222) && __getOwnPropDesc2(k222 < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x222) {
    return __privateSet2(this, extra, x222);
  } }, name));
  k222 ? p222 && k222 < 4 && __name2(extra, (k222 > 2 ? "set " : k222 > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i322 = decorators.length - 1; i322 >= 0; i322--) {
    ctx = __decoratorContext2(k222, name, done = {}, array[3], extraInitializers);
    if (k222) {
      ctx.static = s222, ctx.private = p222, access = ctx.access = { has: p222 ? (x222) => __privateIn2(target, x222) : (x222) => name in x222 };
      if (k222 ^ 3) access.get = p222 ? (x222) => (k222 ^ 1 ? __privateGet2 : __privateMethod2)(x222, target, k222 ^ 4 ? extra : desc.get) : (x222) => x222[name];
      if (k222 > 2) access.set = p222 ? (x222, y222) => __privateSet2(x222, target, y222, k222 ^ 4 ? extra : desc.set) : (x222, y222) => x222[name] = y222;
    }
    it = (0, decorators[i322])(k222 ? k222 < 4 ? p222 ? extra : desc[key] : k222 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k222 ^ 4 || it === void 0) __expectFn2(it) && (k222 > 4 ? initializers.unshift(it) : k222 ? p222 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError2("Object expected");
    else __expectFn2(fn = it.get) && (desc.get = fn), __expectFn2(fn = it.set) && (desc.set = fn), __expectFn2(fn = it.init) && initializers.unshift(fn);
  }
  return k222 || __decoratorMetadata2(array, target), desc && __defProp2(target, name, desc), p222 ? k222 ^ 4 ? extra : desc : target;
};
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var t2 = globalThis;
var e3 = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s2 = Symbol();
var o3 = /* @__PURE__ */ new WeakMap();
var n4 = class {
  constructor(t222, e422, o422) {
    if (this._$cssResult$ = true, o422 !== s2) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t222, this.t = e422;
  }
  get styleSheet() {
    let t222 = this.o;
    const s222 = this.t;
    if (e3 && void 0 === t222) {
      const e422 = void 0 !== s222 && 1 === s222.length;
      e422 && (t222 = o3.get(s222)), void 0 === t222 && ((this.o = t222 = new CSSStyleSheet()).replaceSync(this.cssText), e422 && o3.set(s222, t222));
    }
    return t222;
  }
  toString() {
    return this.cssText;
  }
};
var r3 = (t222) => new n4("string" == typeof t222 ? t222 : t222 + "", void 0, s2);
var S3 = (s222, o422) => {
  if (e3) s222.adoptedStyleSheets = o422.map((t222) => t222 instanceof CSSStyleSheet ? t222 : t222.styleSheet);
  else for (const e422 of o422) {
    const o522 = document.createElement("style"), n522 = t2.litNonce;
    void 0 !== n522 && o522.setAttribute("nonce", n522), o522.textContent = e422.cssText, s222.appendChild(o522);
  }
};
var c4 = e3 ? (t222) => t222 : (t222) => t222 instanceof CSSStyleSheet ? ((t322) => {
  let e422 = "";
  for (const s222 of t322.cssRules) e422 += s222.cssText;
  return r3(e422);
})(t222) : t222;
var { is: i22, defineProperty: e22, getOwnPropertyDescriptor: r22, getOwnPropertyNames: h4, getOwnPropertySymbols: o22, getPrototypeOf: n22 } = Object;
var a2 = globalThis;
var c22 = a2.trustedTypes;
var l2 = c22 ? c22.emptyScript : "";
var p2 = a2.reactiveElementPolyfillSupport;
var d2 = (t222, s222) => t222;
var u2 = { toAttribute(t222, s222) {
  switch (s222) {
    case Boolean:
      t222 = t222 ? l2 : null;
      break;
    case Object:
    case Array:
      t222 = null == t222 ? t222 : JSON.stringify(t222);
  }
  return t222;
}, fromAttribute(t222, s222) {
  let i322 = t222;
  switch (s222) {
    case Boolean:
      i322 = null !== t222;
      break;
    case Number:
      i322 = null === t222 ? null : Number(t222);
      break;
    case Object:
    case Array:
      try {
        i322 = JSON.parse(t222);
      } catch (t322) {
        i322 = null;
      }
  }
  return i322;
} };
var f4 = (t222, s222) => !i22(t222, s222);
var y2 = { attribute: true, type: String, converter: u2, reflect: false, hasChanged: f4 };
Symbol.metadata ??= Symbol("metadata"), a2.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b2 = class extends HTMLElement {
  static addInitializer(t222) {
    this._$Ei(), (this.l ??= []).push(t222);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t222, s222 = y2) {
    if (s222.state && (s222.attribute = false), this._$Ei(), this.elementProperties.set(t222, s222), !s222.noAccessor) {
      const i322 = Symbol(), r422 = this.getPropertyDescriptor(t222, i322, s222);
      void 0 !== r422 && e22(this.prototype, t222, r422);
    }
  }
  static getPropertyDescriptor(t222, s222, i322) {
    const { get: e422, set: h422 } = r22(this.prototype, t222) ?? { get() {
      return this[s222];
    }, set(t322) {
      this[s222] = t322;
    } };
    return { get() {
      return e422?.call(this);
    }, set(s33) {
      const r422 = e422?.call(this);
      h422.call(this, s33), this.requestUpdate(t222, r422, i322);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t222) {
    return this.elementProperties.get(t222) ?? y2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d2("elementProperties"))) return;
    const t222 = n22(this);
    t222.finalize(), void 0 !== t222.l && (this.l = [...t222.l]), this.elementProperties = new Map(t222.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d2("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d2("properties"))) {
      const t322 = this.properties, s222 = [...h4(t322), ...o22(t322)];
      for (const i322 of s222) this.createProperty(i322, t322[i322]);
    }
    const t222 = this[Symbol.metadata];
    if (null !== t222) {
      const s222 = litPropertyMetadata.get(t222);
      if (void 0 !== s222) for (const [t322, i322] of s222) this.elementProperties.set(t322, i322);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t322, s222] of this.elementProperties) {
      const i322 = this._$Eu(t322, s222);
      void 0 !== i322 && this._$Eh.set(i322, t322);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s222) {
    const i322 = [];
    if (Array.isArray(s222)) {
      const e422 = new Set(s222.flat(1 / 0).reverse());
      for (const s33 of e422) i322.unshift(c4(s33));
    } else void 0 !== s222 && i322.push(c4(s222));
    return i322;
  }
  static _$Eu(t222, s222) {
    const i322 = s222.attribute;
    return false === i322 ? void 0 : "string" == typeof i322 ? i322 : "string" == typeof t222 ? t222.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t222) => this.enableUpdating = t222), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t222) => t222(this));
  }
  addController(t222) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t222), void 0 !== this.renderRoot && this.isConnected && t222.hostConnected?.();
  }
  removeController(t222) {
    this._$EO?.delete(t222);
  }
  _$E_() {
    const t222 = /* @__PURE__ */ new Map(), s222 = this.constructor.elementProperties;
    for (const i322 of s222.keys()) this.hasOwnProperty(i322) && (t222.set(i322, this[i322]), delete this[i322]);
    t222.size > 0 && (this._$Ep = t222);
  }
  createRenderRoot() {
    const t222 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S3(t222, this.constructor.elementStyles), t222;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t222) => t222.hostConnected?.());
  }
  enableUpdating(t222) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t222) => t222.hostDisconnected?.());
  }
  attributeChangedCallback(t222, s222, i322) {
    this._$AK(t222, i322);
  }
  _$EC(t222, s222) {
    const i322 = this.constructor.elementProperties.get(t222), e422 = this.constructor._$Eu(t222, i322);
    if (void 0 !== e422 && true === i322.reflect) {
      const r422 = (void 0 !== i322.converter?.toAttribute ? i322.converter : u2).toAttribute(s222, i322.type);
      this._$Em = t222, null == r422 ? this.removeAttribute(e422) : this.setAttribute(e422, r422), this._$Em = null;
    }
  }
  _$AK(t222, s222) {
    const i322 = this.constructor, e422 = i322._$Eh.get(t222);
    if (void 0 !== e422 && this._$Em !== e422) {
      const t322 = i322.getPropertyOptions(e422), r422 = "function" == typeof t322.converter ? { fromAttribute: t322.converter } : void 0 !== t322.converter?.fromAttribute ? t322.converter : u2;
      this._$Em = e422, this[e422] = r422.fromAttribute(s222, t322.type), this._$Em = null;
    }
  }
  requestUpdate(t222, s222, i322) {
    if (void 0 !== t222) {
      if (i322 ??= this.constructor.getPropertyOptions(t222), !(i322.hasChanged ?? f4)(this[t222], s222)) return;
      this.P(t222, s222, i322);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t222, s222, i322) {
    this._$AL.has(t222) || this._$AL.set(t222, s222), true === i322.reflect && this._$Em !== t222 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t222);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t322) {
      Promise.reject(t322);
    }
    const t222 = this.scheduleUpdate();
    return null != t222 && await t222, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t422, s33] of this._$Ep) this[t422] = s33;
        this._$Ep = void 0;
      }
      const t322 = this.constructor.elementProperties;
      if (t322.size > 0) for (const [s33, i322] of t322) true !== i322.wrapped || this._$AL.has(s33) || void 0 === this[s33] || this.P(s33, this[s33], i322);
    }
    let t222 = false;
    const s222 = this._$AL;
    try {
      t222 = this.shouldUpdate(s222), t222 ? (this.willUpdate(s222), this._$EO?.forEach((t322) => t322.hostUpdate?.()), this.update(s222)) : this._$EU();
    } catch (s33) {
      throw t222 = false, this._$EU(), s33;
    }
    t222 && this._$AE(s222);
  }
  willUpdate(t222) {
  }
  _$AE(t222) {
    this._$EO?.forEach((t322) => t322.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t222)), this.updated(t222);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t222) {
    return true;
  }
  update(t222) {
    this._$Ej &&= this._$Ej.forEach((t322) => this._$EC(t322, this[t322])), this._$EU();
  }
  updated(t222) {
  }
  firstUpdated(t222) {
  }
};
b2.elementStyles = [], b2.shadowRootOptions = { mode: "open" }, b2[d2("elementProperties")] = /* @__PURE__ */ new Map(), b2[d2("finalized")] = /* @__PURE__ */ new Map(), p2?.({ ReactiveElement: b2 }), (a2.reactiveElementVersions ??= []).push("2.0.4");
var n32 = globalThis;
var c32 = n32.trustedTypes;
var h22 = c32 ? c32.createPolicy("lit-html", { createHTML: (t222) => t222 }) : void 0;
var f22 = "$lit$";
var v2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m2 = "?" + v2;
var _2 = `<${m2}>`;
var w2 = document;
var lt2 = () => w2.createComment("");
var st2 = (t222) => null === t222 || "object" != typeof t222 && "function" != typeof t222;
var g2 = Array.isArray;
var $2 = (t222) => g2(t222) || "function" == typeof t222?.[Symbol.iterator];
var x2 = "[ 	\n\f\r]";
var T2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E2 = /-->/g;
var k2 = />/g;
var O2 = RegExp(`>|${x2}(?:([^\\s"'>=/]+)(${x2}*=${x2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S22 = /'/g;
var j2 = /"/g;
var M2 = /^(?:script|style|textarea|title)$/i;
var P2 = (t222) => (i322, ...s222) => ({ _$litType$: t222, strings: i322, values: s222 });
var ke2 = P2(1);
var Oe2 = P2(2);
var Se2 = P2(3);
var R2 = Symbol.for("lit-noChange");
var D2 = Symbol.for("lit-nothing");
var V2 = /* @__PURE__ */ new WeakMap();
var I2 = w2.createTreeWalker(w2, 129);
function N2(t222, i322) {
  if (!g2(t222) || !t222.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h22 ? h22.createHTML(i322) : i322;
}
var U2 = (t222, i322) => {
  const s222 = t222.length - 1, e422 = [];
  let h422, o422 = 2 === i322 ? "<svg>" : 3 === i322 ? "<math>" : "", n522 = T2;
  for (let i43 = 0; i43 < s222; i43++) {
    const s33 = t222[i43];
    let r422, l222, c422 = -1, a222 = 0;
    for (; a222 < s33.length && (n522.lastIndex = a222, l222 = n522.exec(s33), null !== l222); ) a222 = n522.lastIndex, n522 === T2 ? "!--" === l222[1] ? n522 = E2 : void 0 !== l222[1] ? n522 = k2 : void 0 !== l222[2] ? (M2.test(l222[2]) && (h422 = RegExp("</" + l222[2], "g")), n522 = O2) : void 0 !== l222[3] && (n522 = O2) : n522 === O2 ? ">" === l222[0] ? (n522 = h422 ?? T2, c422 = -1) : void 0 === l222[1] ? c422 = -2 : (c422 = n522.lastIndex - l222[2].length, r422 = l222[1], n522 = void 0 === l222[3] ? O2 : '"' === l222[3] ? j2 : S22) : n522 === j2 || n522 === S22 ? n522 = O2 : n522 === E2 || n522 === k2 ? n522 = T2 : (n522 = O2, h422 = void 0);
    const u222 = n522 === O2 && t222[i43 + 1].startsWith("/>") ? " " : "";
    o422 += n522 === T2 ? s33 + _2 : c422 >= 0 ? (e422.push(r422), s33.slice(0, c422) + f22 + s33.slice(c422) + v2 + u222) : s33 + v2 + (-2 === c422 ? i43 : u222);
  }
  return [N2(t222, o422 + (t222[s222] || "<?>") + (2 === i322 ? "</svg>" : 3 === i322 ? "</math>" : "")), e422];
};
var B2 = class _B {
  constructor({ strings: t222, _$litType$: i322 }, s222) {
    let e422;
    this.parts = [];
    let h422 = 0, o422 = 0;
    const n522 = t222.length - 1, r422 = this.parts, [l222, a222] = U2(t222, i322);
    if (this.el = _B.createElement(l222, s222), I2.currentNode = this.el.content, 2 === i322 || 3 === i322) {
      const t322 = this.el.content.firstChild;
      t322.replaceWith(...t322.childNodes);
    }
    for (; null !== (e422 = I2.nextNode()) && r422.length < n522; ) {
      if (1 === e422.nodeType) {
        if (e422.hasAttributes()) for (const t322 of e422.getAttributeNames()) if (t322.endsWith(f22)) {
          const i43 = a222[o422++], s33 = e422.getAttribute(t322).split(v2), n63 = /([.?@])?(.*)/.exec(i43);
          r422.push({ type: 1, index: h422, name: n63[2], strings: s33, ctor: "." === n63[1] ? Y2 : "?" === n63[1] ? Z2 : "@" === n63[1] ? q2 : G2 }), e422.removeAttribute(t322);
        } else t322.startsWith(v2) && (r422.push({ type: 6, index: h422 }), e422.removeAttribute(t322));
        if (M2.test(e422.tagName)) {
          const t322 = e422.textContent.split(v2), i43 = t322.length - 1;
          if (i43 > 0) {
            e422.textContent = c32 ? c32.emptyScript : "";
            for (let s33 = 0; s33 < i43; s33++) e422.append(t322[s33], lt2()), I2.nextNode(), r422.push({ type: 2, index: ++h422 });
            e422.append(t322[i43], lt2());
          }
        }
      } else if (8 === e422.nodeType) if (e422.data === m2) r422.push({ type: 2, index: h422 });
      else {
        let t322 = -1;
        for (; -1 !== (t322 = e422.data.indexOf(v2, t322 + 1)); ) r422.push({ type: 7, index: h422 }), t322 += v2.length - 1;
      }
      h422++;
    }
  }
  static createElement(t222, i322) {
    const s222 = w2.createElement("template");
    return s222.innerHTML = t222, s222;
  }
};
function z2(t222, i322, s222 = t222, e422) {
  if (i322 === R2) return i322;
  let h422 = void 0 !== e422 ? s222.o?.[e422] : s222.l;
  const o422 = st2(i322) ? void 0 : i322._$litDirective$;
  return h422?.constructor !== o422 && (h422?._$AO?.(false), void 0 === o422 ? h422 = void 0 : (h422 = new o422(t222), h422._$AT(t222, s222, e422)), void 0 !== e422 ? (s222.o ??= [])[e422] = h422 : s222.l = h422), void 0 !== h422 && (i322 = z2(t222, h422._$AS(t222, i322.values), h422, e422)), i322;
}
var F2 = class {
  constructor(t222, i322) {
    this._$AV = [], this._$AN = void 0, this._$AD = t222, this._$AM = i322;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t222) {
    const { el: { content: i322 }, parts: s222 } = this._$AD, e422 = (t222?.creationScope ?? w2).importNode(i322, true);
    I2.currentNode = e422;
    let h422 = I2.nextNode(), o422 = 0, n522 = 0, r422 = s222[0];
    for (; void 0 !== r422; ) {
      if (o422 === r422.index) {
        let i43;
        2 === r422.type ? i43 = new et2(h422, h422.nextSibling, this, t222) : 1 === r422.type ? i43 = new r422.ctor(h422, r422.name, r422.strings, this, t222) : 6 === r422.type && (i43 = new K2(h422, this, t222)), this._$AV.push(i43), r422 = s222[++n522];
      }
      o422 !== r422?.index && (h422 = I2.nextNode(), o422++);
    }
    return I2.currentNode = w2, e422;
  }
  p(t222) {
    let i322 = 0;
    for (const s222 of this._$AV) void 0 !== s222 && (void 0 !== s222.strings ? (s222._$AI(t222, s222, i322), i322 += s222.strings.length - 2) : s222._$AI(t222[i322])), i322++;
  }
};
var et2 = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t222, i322, s222, e422) {
    this.type = 2, this._$AH = D2, this._$AN = void 0, this._$AA = t222, this._$AB = i322, this._$AM = s222, this.options = e422, this.v = e422?.isConnected ?? true;
  }
  get parentNode() {
    let t222 = this._$AA.parentNode;
    const i322 = this._$AM;
    return void 0 !== i322 && 11 === t222?.nodeType && (t222 = i322.parentNode), t222;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t222, i322 = this) {
    t222 = z2(this, t222, i322), st2(t222) ? t222 === D2 || null == t222 || "" === t222 ? (this._$AH !== D2 && this._$AR(), this._$AH = D2) : t222 !== this._$AH && t222 !== R2 && this._(t222) : void 0 !== t222._$litType$ ? this.$(t222) : void 0 !== t222.nodeType ? this.T(t222) : $2(t222) ? this.k(t222) : this._(t222);
  }
  O(t222) {
    return this._$AA.parentNode.insertBefore(t222, this._$AB);
  }
  T(t222) {
    this._$AH !== t222 && (this._$AR(), this._$AH = this.O(t222));
  }
  _(t222) {
    this._$AH !== D2 && st2(this._$AH) ? this._$AA.nextSibling.data = t222 : this.T(w2.createTextNode(t222)), this._$AH = t222;
  }
  $(t222) {
    const { values: i322, _$litType$: s222 } = t222, e422 = "number" == typeof s222 ? this._$AC(t222) : (void 0 === s222.el && (s222.el = B2.createElement(N2(s222.h, s222.h[0]), this.options)), s222);
    if (this._$AH?._$AD === e422) this._$AH.p(i322);
    else {
      const t322 = new F2(e422, this), s33 = t322.u(this.options);
      t322.p(i322), this.T(s33), this._$AH = t322;
    }
  }
  _$AC(t222) {
    let i322 = V2.get(t222.strings);
    return void 0 === i322 && V2.set(t222.strings, i322 = new B2(t222)), i322;
  }
  k(t222) {
    g2(this._$AH) || (this._$AH = [], this._$AR());
    const i322 = this._$AH;
    let s222, e422 = 0;
    for (const h422 of t222) e422 === i322.length ? i322.push(s222 = new _et(this.O(lt2()), this.O(lt2()), this, this.options)) : s222 = i322[e422], s222._$AI(h422), e422++;
    e422 < i322.length && (this._$AR(s222 && s222._$AB.nextSibling, e422), i322.length = e422);
  }
  _$AR(t222 = this._$AA.nextSibling, i322) {
    for (this._$AP?.(false, true, i322); t222 && t222 !== this._$AB; ) {
      const i43 = t222.nextSibling;
      t222.remove(), t222 = i43;
    }
  }
  setConnected(t222) {
    void 0 === this._$AM && (this.v = t222, this._$AP?.(t222));
  }
};
var G2 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t222, i322, s222, e422, h422) {
    this.type = 1, this._$AH = D2, this._$AN = void 0, this.element = t222, this.name = i322, this._$AM = e422, this.options = h422, s222.length > 2 || "" !== s222[0] || "" !== s222[1] ? (this._$AH = Array(s222.length - 1).fill(new String()), this.strings = s222) : this._$AH = D2;
  }
  _$AI(t222, i322 = this, s222, e422) {
    const h422 = this.strings;
    let o422 = false;
    if (void 0 === h422) t222 = z2(this, t222, i322, 0), o422 = !st2(t222) || t222 !== this._$AH && t222 !== R2, o422 && (this._$AH = t222);
    else {
      const e522 = t222;
      let n522, r422;
      for (t222 = h422[0], n522 = 0; n522 < h422.length - 1; n522++) r422 = z2(this, e522[s222 + n522], i322, n522), r422 === R2 && (r422 = this._$AH[n522]), o422 ||= !st2(r422) || r422 !== this._$AH[n522], r422 === D2 ? t222 = D2 : t222 !== D2 && (t222 += (r422 ?? "") + h422[n522 + 1]), this._$AH[n522] = r422;
    }
    o422 && !e422 && this.j(t222);
  }
  j(t222) {
    t222 === D2 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t222 ?? "");
  }
};
var Y2 = class extends G2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t222) {
    this.element[this.name] = t222 === D2 ? void 0 : t222;
  }
};
var Z2 = class extends G2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t222) {
    this.element.toggleAttribute(this.name, !!t222 && t222 !== D2);
  }
};
var q2 = class extends G2 {
  constructor(t222, i322, s222, e422, h422) {
    super(t222, i322, s222, e422, h422), this.type = 5;
  }
  _$AI(t222, i322 = this) {
    if ((t222 = z2(this, t222, i322, 0) ?? D2) === R2) return;
    const s222 = this._$AH, e422 = t222 === D2 && s222 !== D2 || t222.capture !== s222.capture || t222.once !== s222.once || t222.passive !== s222.passive, h422 = t222 !== D2 && (s222 === D2 || e422);
    e422 && this.element.removeEventListener(this.name, this, s222), h422 && this.element.addEventListener(this.name, this, t222), this._$AH = t222;
  }
  handleEvent(t222) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t222) : this._$AH.handleEvent(t222);
  }
};
var K2 = class {
  constructor(t222, i322, s222) {
    this.element = t222, this.type = 6, this._$AN = void 0, this._$AM = i322, this.options = s222;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t222) {
    z2(this, t222);
  }
};
var Re2 = n32.litHtmlPolyfillSupport;
Re2?.(B2, et2), (n32.litHtmlVersions ??= []).push("3.2.0");
var Q2 = (t222, i322, s222) => {
  const e422 = s222?.renderBefore ?? i322;
  let h422 = e422._$litPart$;
  if (void 0 === h422) {
    const t322 = s222?.renderBefore ?? null;
    e422._$litPart$ = h422 = new et2(i322.insertBefore(lt2(), t322), t322, void 0, s222 ?? {});
  }
  return h422._$AI(t222), h422;
};
var h32 = class extends b2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t222 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t222.firstChild, t222;
  }
  update(t222) {
    const e422 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t222), this.o = Q2(e422, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R2;
  }
};
h32._$litElement$ = true, h32["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h32 });
var f32 = globalThis.litElementPolyfillSupport;
f32?.({ LitElement: h32 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o32 = { attribute: true, type: String, converter: u2, reflect: false, hasChanged: f4 };
var r32 = (t222 = o32, e422, r422) => {
  const { kind: n522, metadata: i322 } = r422;
  let s222 = globalThis.litPropertyMetadata.get(i322);
  if (void 0 === s222 && globalThis.litPropertyMetadata.set(i322, s222 = /* @__PURE__ */ new Map()), s222.set(r422.name, t222), "accessor" === n522) {
    const { name: o422 } = r422;
    return { set(r522) {
      const n63 = e422.get.call(this);
      e422.set.call(this, r522), this.requestUpdate(o422, n63, t222);
    }, init(e522) {
      return void 0 !== e522 && this.P(o422, void 0, t222), e522;
    } };
  }
  if ("setter" === n522) {
    const { name: o422 } = r422;
    return function(r522) {
      const n63 = this[o422];
      e422.call(this, r522), this.requestUpdate(o422, n63, t222);
    };
  }
  throw Error("Unsupported decorator location: " + n522);
};
function n42(t222) {
  return (e422, o422) => "object" == typeof o422 ? r32(t222, e422, o422) : ((t322, e522, o522) => {
    const r422 = e522.hasOwnProperty(o522);
    return e522.constructor.createProperty(o522, r422 ? { ...t322, wrapped: true } : t322), r422 ? Object.getOwnPropertyDescriptor(e522, o522) : void 0;
  })(t222, e422, o422);
}
var appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version = "3.0.0";
var versions = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions.includes(version)) {
  versions.push(version);
}
var ScopedElementsMixinImplementation = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry22) {
      this.constructor.__registry = registry22;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);
var ScopedElementsMixinImplementation2 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S3(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin2 = dedupeMixin(ScopedElementsMixinImplementation2);
function option(decl = { type: "string" }) {
  return (target, context) => {
    function init() {
      this.constructor["options"] = { ...this.constructor["options"], [context.name]: decl };
    }
    context.addInitializer(init);
  };
}
var _lang_dec;
var _contentEditable_dec;
var _a;
var _init;
var _contentEditable;
var _lang;
var LitElementWw = class extends (_a = ScopedElementsMixin2(h32), _contentEditable_dec = [n42({ type: String, attribute: true, reflect: true })], _lang_dec = [n42({ type: String, attribute: true, reflect: true })], _a) {
  constructor() {
    super(...arguments);
    __publicField2(this, "options");
    __publicField2(this, "actions", {});
    __privateAdd2(this, _contentEditable, __runInitializers2(_init, 8, this)), __runInitializers2(_init, 11, this);
    __privateAdd2(this, _lang, __runInitializers2(_init, 12, this)), __runInitializers2(_init, 15, this);
    __publicField2(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k222) => this.setAttribute(k222, this.getAttribute(k222)));
  }
};
_init = __decoratorStart2(_a);
_contentEditable = /* @__PURE__ */ new WeakMap();
_lang = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init, 4, "contentEditable", _contentEditable_dec, LitElementWw, _contentEditable);
__decorateElement2(_init, 4, "lang", _lang_dec, LitElementWw, _lang);
__decoratorMetadata2(_init, LitElementWw);
__publicField2(LitElementWw, "shadowRootOptions", { ...h32.shadowRootOptions });
__publicField2(LitElementWw, "options", {});
__publicField2(LitElementWw, "actions", {});
var t3 = (t64) => (e73, o73) => {
  void 0 !== o73 ? o73.addInitializer(() => {
    customElements.define(t64, e73);
  }) : customElements.define(t64, e73);
};
var o4 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r4 = (t64 = o4, e73, r73) => {
  const { kind: n63, metadata: i43 } = r73;
  let s33 = globalThis.litPropertyMetadata.get(i43);
  if (void 0 === s33 && globalThis.litPropertyMetadata.set(i43, s33 = /* @__PURE__ */ new Map()), s33.set(r73.name, t64), "accessor" === n63) {
    const { name: o73 } = r73;
    return { set(r83) {
      const n73 = e73.get.call(this);
      e73.set.call(this, r83), this.requestUpdate(o73, n73, t64);
    }, init(e83) {
      return void 0 !== e83 && this.P(o73, void 0, t64), e83;
    } };
  }
  if ("setter" === n63) {
    const { name: o73 } = r73;
    return function(r83) {
      const n73 = this[o73];
      e73.call(this, r83), this.requestUpdate(o73, n73, t64);
    };
  }
  throw Error("Unsupported decorator location: " + n63);
};
function n5(t64) {
  return (e73, o73) => "object" == typeof o73 ? r4(t64, e73, o73) : ((t73, e83, o83) => {
    const r73 = e83.hasOwnProperty(o83);
    return e83.constructor.createProperty(o83, r73 ? { ...t73, wrapped: true } : t73), r73 ? Object.getOwnPropertyDescriptor(e83, o83) : void 0;
  })(t64, e73, o73);
}
function r5(r73) {
  return n5({ ...r73, state: true, attribute: false });
}
var e4 = (e73, t64, c53) => (c53.configurable = true, c53.enumerable = true, Reflect.decorate && "object" != typeof t64 && Object.defineProperty(e73, t64, c53), c53);
function e5(e73, r73) {
  return (n63, s33, i43) => {
    const o73 = (t64) => t64.renderRoot?.querySelector(e73) ?? null;
    if (r73) {
      const { get: e83, set: r83 } = "object" == typeof s33 ? n63 : i43 ?? (() => {
        const t64 = Symbol();
        return { get() {
          return this[t64];
        }, set(e93) {
          this[t64] = e93;
        } };
      })();
      return e4(n63, s33, { get() {
        let t64 = e83.call(this);
        return void 0 === t64 && (t64 = o73(this), (null !== t64 || this.hasUpdated) && r83.call(this, t64)), t64;
      } });
    }
    return e4(n63, s33, { get() {
      return o73(this);
    } });
  };
}
function o5(o73) {
  return (e73, n63) => {
    const { slot: r73, selector: s33 } = o73 ?? {}, c53 = "slot" + (r73 ? `[name=${r73}]` : ":not([name])");
    return e4(e73, n63, { get() {
      const t64 = this.renderRoot?.querySelector(c53), e83 = t64?.assignedElements(o73) ?? [];
      return void 0 === s33 ? e83 : e83.filter((t73) => t73.matches(s33));
    } });
  };
}
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentDirection = document.documentElement.dir || "ltr";
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation(...translation22) {
  translation22.map((t64) => {
    const code = t64.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t64));
    } else {
      translations.set(code, t64);
    }
    if (!fallback) {
      fallback = t64;
    }
  });
  update();
}
function update() {
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a33, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a33 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a33 === void 0 ? void 0 : _a33.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a33;
    const { primary, secondary } = this.getTranslationData((_a33 = options.lang) !== null && _a33 !== void 0 ? _a33 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
var __defProp3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a33, b33) => {
  for (var prop in b33 || (b33 = {}))
    if (__hasOwnProp.call(b33, prop))
      __defNormalProp3(a33, prop, b33[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b33)) {
      if (__propIsEnum.call(b33, prop))
        __defNormalProp3(a33, prop, b33[prop]);
    }
  return a33;
};
var __spreadProps = (a33, b33) => __defProps(a33, __getOwnPropDescs(b33));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc3(target, key) : target;
  for (var i43 = decorators.length - 1, decorator; i43 >= 0; i43--)
    if (decorator = decorators[i43])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp3(target, key, result);
  return result;
};
var __accessCheck3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet3 = (obj, member, getter) => {
  __accessCheck3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet3 = (obj, member, value, setter) => {
  __accessCheck3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _hasRecordedInitialProperties;
var ShoelaceElement = class extends h3 {
  constructor() {
    super();
    __privateAdd3(this, _hasRecordedInitialProperties, false);
    this.initialReflectedProperties = /* @__PURE__ */ new Map();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      try {
        customElements.define(name, elementConstructor, options);
      } catch (_err) {
        customElements.define(name, class extends elementConstructor {
        }, options);
      }
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (!__privateGet3(this, _hasRecordedInitialProperties)) {
      this.constructor.elementProperties.forEach(
        (obj, prop) => {
          if (obj.reflect && this[prop] != null) {
            this.initialReflectedProperties.set(prop, this[prop]);
          }
        }
      );
      __privateSet3(this, _hasRecordedInitialProperties, true);
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    this.initialReflectedProperties.forEach((value, prop) => {
      if (changedProperties.has(prop) && this[prop] == null) {
        this[prop] = value;
      }
    });
  }
};
_hasRecordedInitialProperties = /* @__PURE__ */ new WeakMap();
ShoelaceElement.version = "2.17.1";
ShoelaceElement.dependencies = {};
__decorateClass([
  n5()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n5()
], ShoelaceElement.prototype, "lang", 2);
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return ke`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a33;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a33 = formCollections.get(this.form)) == null ? void 0 : _a33.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a33;
        return (_a33 = input.disabled) != null ? _a33 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a33;
    return (_a33 = this.form) != null ? _a33 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`;
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s33) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s33.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s33.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update22 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update22.call(this, changedProps);
    };
  };
}
var { I: et3 } = si;
var nt = (o73, t64) => void 0 === t64 ? void 0 !== o73?._$litType$ : o73?._$litType$ === t64;
var rt = (o73) => void 0 === o73.strings;
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library22) {
    var _a33;
    let fileData;
    if (library22 == null ? void 0 : library22.spriteSheet) {
      this.svg = ke`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e73) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a33 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a33.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      if (!parser)
        parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e73) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library22 = getIconLibrary(this.library);
    if (this.name && library22) {
      return {
        url: library22.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a33;
    const { url, fromLibrary } = this.getIconSource();
    const library22 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library22);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt(svg)) {
      this.svg = svg;
      if (library22) {
        await this.updateComplete;
        const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library22.mutator === "function" && shadowSVG) {
          library22.mutator(shadowSVG);
        }
      }
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a33 = library22 == null ? void 0 : library22.mutator) == null ? void 0 : _a33.call(library22, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r5()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n5({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n5()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n5()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n5({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);
var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e6 = (t64) => (...e73) => ({ _$litDirective$: t64, values: e73 });
var i3 = class {
  constructor(t64) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t64, e73, i43) {
    this.t = t64, this._$AM = e73, this.i = i43;
  }
  _$AS(t64, e73) {
    return this.update(t64, e73);
  }
  update(t64, e73) {
    return this.render(...e73);
  }
};
var Rt = e6(class extends i3 {
  constructor(s33) {
    if (super(s33), s33.type !== t4.ATTRIBUTE || "class" !== s33.name || s33.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t64) {
    return " " + Object.keys(t64).filter((s33) => t64[s33]).join(" ") + " ";
  }
  update(t64, [s33]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t64.strings && (this.nt = new Set(t64.strings.join(" ").split(/\s/).filter((t73) => "" !== t73)));
      for (const t73 in s33) s33[t73] && !this.nt?.has(t73) && this.st.add(t73);
      return this.render(s33);
    }
    const i43 = t64.element.classList;
    for (const t73 of this.st) t73 in s33 || (i43.remove(t73), this.st.delete(t73));
    for (const t73 in s33) {
      const r73 = !!s33[t73];
      r73 === this.st.has(t73) || this.nt?.has(t73) || (r73 ? (i43.add(t73), this.st.add(t73)) : (i43.remove(t73), this.st.delete(t73)));
    }
    return R;
  }
});
var $e = Symbol.for("");
var xe = (t64) => {
  if (t64?.r === $e) return t64?._$litStatic$;
};
var er = (t64, ...r73) => ({ _$litStatic$: r73.reduce((r83, e73, a33) => r83 + ((t73) => {
  if (void 0 !== t73._$litStatic$) return t73._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t73}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e73) + t64[a33 + 1], t64[0]), r: $e });
var Te = /* @__PURE__ */ new Map();
var Ee = (t64) => (r73, ...e73) => {
  const a33 = e73.length;
  let o73, s33;
  const i43 = [], l33 = [];
  let n63, u33 = 0, c53 = false;
  for (; u33 < a33; ) {
    for (n63 = r73[u33]; u33 < a33 && void 0 !== (s33 = e73[u33], o73 = xe(s33)); ) n63 += o73 + r73[++u33], c53 = true;
    u33 !== a33 && l33.push(s33), i43.push(n63), u33++;
  }
  if (u33 === a33 && i43.push(r73[a33]), c53) {
    const t73 = i43.join("$$lit$$");
    void 0 === (r73 = Te.get(t73)) && (i43.raw = i43, Te.set(t73, r73 = i43)), e73 = l33;
  }
  return t64(r73, ...e73);
};
var ke3 = Ee(ke);
var Oe3 = Ee(Oe);
var Se3 = Ee(Se);
var to = (t64) => t64 ?? D;
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? er`a` : er`button`;
    return ke3`
      <${tag}
        part="base"
        class=${Rt({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to(isLink ? void 0 : this.name)}
        value=${to(isLink ? void 0 : this.value)}
        href=${to(isLink && !this.disabled ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink ? this.rel : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke3` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke3`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e5(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  r5()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  r5()
], SlButton.prototype, "invalid", 2);
__decorateClass([
  n5()
], SlButton.prototype, "title", 2);
__decorateClass([
  n5({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  n5({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  n5()
], SlButton.prototype, "type", 2);
__decorateClass([
  n5()
], SlButton.prototype, "name", 2);
__decorateClass([
  n5()
], SlButton.prototype, "value", 2);
__decorateClass([
  n5()
], SlButton.prototype, "href", 2);
__decorateClass([
  n5()
], SlButton.prototype, "target", 2);
__decorateClass([
  n5()
], SlButton.prototype, "rel", 2);
__decorateClass([
  n5()
], SlButton.prototype, "download", 2);
__decorateClass([
  n5()
], SlButton.prototype, "form", 2);
__decorateClass([
  n5({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  n5({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass([
  n5({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  n5({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  n5({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlButton.prototype, "handleDisabledChange", 1);
var button_group_styles_default = i`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;
var SlButtonGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", true);
  }
  handleBlur(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", false);
  }
  handleMouseOver(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", true);
  }
  handleMouseOut(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", false);
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton(el);
      if (button) {
        button.toggleAttribute("data-sl-button-group__button", true);
        button.toggleAttribute("data-sl-button-group__button--first", index === 0);
        button.toggleAttribute("data-sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.toggleAttribute("data-sl-button-group__button--last", index === slottedElements.length - 1);
        button.toggleAttribute(
          "data-sl-button-group__button--radio",
          button.tagName.toLowerCase() === "sl-radio-button"
        );
      }
    });
  }
  render() {
    return ke`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
__decorateClass([
  e5("slot")
], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass([
  r5()
], SlButtonGroup.prototype, "disableRole", 2);
__decorateClass([
  n5()
], SlButtonGroup.prototype, "label", 2);
function findButton(el) {
  var _a33;
  const selector = "sl-button, sl-radio-button";
  return (_a33 = el.closest(selector)) != null ? _a33 : el.querySelector(selector);
}
var dropdown_styles_default = i`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
var computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });
  }
  const computedStyle = getCachedComputedStyle(el);
  return computedStyle.visibility !== "hidden" && computedStyle.display !== "none";
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const { overflowY, overflowX } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  const isNativelyTabbable = [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe"
  ].includes(tag);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a33, _b;
  const tabbableElements = getTabbableElements(root);
  const start = (_a33 = tabbableElements[0]) != null ? _a33 : null;
  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
  return { start, end };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a33;
  return ((_a33 = slotElement.getRootNode({ composed: true })) == null ? void 0 : _a33.host) !== root;
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */ new WeakMap();
  const tabbableElements = [];
  function walk(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {
        el.assignedElements({ flatten: true }).forEach((assignedEl) => {
          walk(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    for (const e73 of el.children) {
      walk(e73);
    }
  }
  walk(root);
  return tabbableElements.sort((a33, b33) => {
    const aTabindex = Number(a33.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b33.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v33) => ({
  x: v33,
  y: v33
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform22
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(floating));
  let rects = await platform22.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x32,
    y: y33
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i43 = 0; i43 < validMiddleware.length; i43++) {
    const {
      name,
      fn
    } = validMiddleware[i43];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x32,
      y: y33,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform22,
      elements: {
        reference,
        floating
      }
    });
    x32 = nextX != null ? nextX : x32;
    y33 = nextY != null ? nextY : y33;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform22.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x32,
          y: y33
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i43 = -1;
      continue;
    }
  }
  return {
    x: x32,
    y: y33,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x32,
    y: y33,
    platform: platform22,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform22.getClippingRect({
    element: ((_await$platform$isEle = await (platform22.isElement == null ? void 0 : platform22.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform22.getDocumentElement == null ? void 0 : platform22.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x32,
    y: y33
  } : rects.reference;
  const offsetParent = await (platform22.getOffsetParent == null ? void 0 : platform22.getOffsetParent(elements.floating));
  const offsetScale = await (platform22.isElement == null ? void 0 : platform22.isElement(offsetParent)) ? await (platform22.getScale == null ? void 0 : platform22.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform22.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform22.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x32,
      y: y33,
      placement,
      rects,
      platform: platform22,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x32,
      y: y33
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform22.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform22.getOffsetParent == null ? void 0 : platform22.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform22.isElement == null ? void 0 : platform22.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max22 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset22 = clamp(min$1, center, max22);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset22 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max22 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset22,
        centerOffset: center - offset22 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform22,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d33) => d33.overflows[0] <= 0).sort((a33, b33) => a33.overflows[1] - b33.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d33) => [d33.placement, d33.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a33, b33) => a33[1] - b33[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform22,
    elements
  } = state;
  const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x32,
        y: y33
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x32 + diffCoords.x,
        y: y33 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x32,
        y: y33,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x43,
              y: y42
            } = _ref;
            return {
              x: x43,
              y: y42
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x32,
        y: y33
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min22 = mainAxisCoord + overflow[minSide];
        const max22 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min22, mainAxisCoord, max22);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min22 = crossAxisCoord + overflow[minSide];
        const max22 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min22, crossAxisCoord, max22);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x32,
          y: limitedCoords.y - y33
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform22,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform22.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css2 = getComputedStyle2(element);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css2 = getComputedStyle2(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $33
  } = getCssDimensions(domElement);
  let x32 = ($33 ? round(rect.width) : rect.width) / width;
  let y33 = ($33 ? round(rect.height) : rect.height) / height;
  if (!x32 || !Number.isFinite(x32)) {
    x32 = 1;
  }
  if (!y33 || !Number.isFinite(y33)) {
    y33 = 1;
  }
  return {
    x: x32,
    y: y33
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x32 = (clientRect.left + visualOffsets.x) / scale.x;
  let y33 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x32 *= iframeScale.x;
      y33 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x32 += left;
      y33 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x32,
    y: y33
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x32 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y33 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x32 += max(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x32,
    y: y33
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x32 = 0;
  let y33 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x32 = visualViewport.offsetLeft;
      y33 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x32,
    y: y33
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x32 = left * scale.x;
  const y33 = top * scale.y;
  return {
    width,
    height,
    x: x32,
    y: y33
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e73) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update22, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update22, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update22);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update22) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update22();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update22();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update22();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update22);
      ancestorResize && ancestor.removeEventListener("resize", update22);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function t5(t64) {
  return r6(t64);
}
function o6(t64) {
  return t64.assignedSlot ? t64.assignedSlot : t64.parentNode instanceof ShadowRoot ? t64.parentNode.host : t64.parentNode;
}
function r6(t64) {
  for (let e73 = t64; e73; e73 = o6(e73)) if (e73 instanceof Element && "none" === getComputedStyle(e73).display) return null;
  for (let e73 = o6(t64); e73; e73 = o6(e73)) {
    if (!(e73 instanceof Element)) continue;
    const t73 = getComputedStyle(e73);
    if ("contents" !== t73.display) {
      if ("static" !== t73.position || "none" !== t73.filter) return e73;
      if ("BODY" === e73.tagName) return e73;
    }
  }
  return null;
}
function isVirtualElement(e73) {
  return e73 !== null && typeof e73 === "object" && "getBoundingClientRect" in e73 && ("contextElement" in e73 ? e73 instanceof Element : true);
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl && this.active) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent22 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, t5) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent22
      })
    }).then(({ x: x32, y: y33, middlewareData, placement }) => {
      const isRtl = this.matches(":dir(rtl)");
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x32}px`,
        top: `${y33}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return ke`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e5(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e5(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n5()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n5({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n5({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n5({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n5({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n5({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n5({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n5({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n5({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n5({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p33) => p33.trim()).filter((p33) => p33 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n5({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n5({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n5({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n5({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n5({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n5({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n5({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n5()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n5({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n5({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n5({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.sync = void 0;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a33;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (this.open && ((_a33 = document.activeElement) == null ? void 0 : _a33.tagName.toLowerCase()) === "sl-menu-item") {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a222, _b, _c;
          const activeElement = ((_a222 = this.containingElement) == null ? void 0 : _a222.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
          if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a33;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a33 = this.closeWatcher) == null ? void 0 : _a33.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a33;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a33 = this.closeWatcher) == null ? void 0 : _a33.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return ke`
      <sl-popup
        part="base"
        exportparts="popup:base__popup"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${to(this.sync ? this.sync : void 0)}
        class=${Rt({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e5(".dropdown")
], SlDropdown.prototype, "popup", 2);
__decorateClass([
  e5(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  e5(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  n5({ reflect: true })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  n5({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  n5({ attribute: false })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  n5({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  n5({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  n5({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  n5({ reflect: true })
], SlDropdown.prototype, "sync", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
var menu_styles_default = i`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;
var SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const menuItemTypes = ["menuitem", "menuitemcheckbox"];
    const composedPath = event.composedPath();
    const target = composedPath.find((el) => {
      var _a33;
      return menuItemTypes.includes(((_a33 = el == null ? void 0 : el.getAttribute) == null ? void 0 : _a33.call(el, "role")) || "");
    });
    if (!target)
      return;
    const closestMenu = composedPath.find((el) => {
      var _a33;
      return ((_a33 = el == null ? void 0 : el.getAttribute) == null ? void 0 : _a33.call(el, "role")) === "menu";
    });
    const clickHasSubmenu = closestMenu !== this;
    if (clickHasSubmenu)
      return;
    const item = target;
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", { detail: { item } });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      event.stopPropagation();
      item == null ? void 0 : item.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a33;
    return item.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((_a33 = item.getAttribute("role")) != null ? _a33 : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {
      if (el.inert || !this.isMenuItem(el)) {
        return false;
      }
      return true;
    });
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((i43) => i43.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach((i43) => {
      i43.setAttribute("tabindex", i43 === item ? "0" : "-1");
    });
  }
  render() {
    return ke`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass([
  e5("slot")
], SlMenu.prototype, "defaultSlot", 2);
var menu_item_styles_default = i`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }

  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
var mt = (i43, t64) => {
  const e73 = i43._$AN;
  if (void 0 === e73) return false;
  for (const i53 of e73) i53._$AO?.(t64, false), mt(i53, t64);
  return true;
};
var _t = (i43) => {
  let t64, e73;
  do {
    if (void 0 === (t64 = i43._$AM)) break;
    e73 = t64._$AN, e73.delete(i43), i43 = t64;
  } while (0 === e73?.size);
};
var wt = (i43) => {
  for (let t64; t64 = i43._$AM; i43 = t64) {
    let e73 = t64._$AN;
    if (void 0 === e73) t64._$AN = e73 = /* @__PURE__ */ new Set();
    else if (e73.has(i43)) break;
    e73.add(i43), gt(t64);
  }
};
function bt(i43) {
  void 0 !== this._$AN ? (_t(this), this._$AM = i43, wt(this)) : this._$AM = i43;
}
function yt(i43, t64 = false, e73 = 0) {
  const s33 = this._$AH, o73 = this._$AN;
  if (void 0 !== o73 && 0 !== o73.size) if (t64) if (Array.isArray(s33)) for (let i53 = e73; i53 < s33.length; i53++) mt(s33[i53], false), _t(s33[i53]);
  else null != s33 && (mt(s33, false), _t(s33));
  else mt(this, i43);
}
var gt = (i43) => {
  i43.type == t4.CHILD && (i43._$AP ??= yt, i43._$AQ ??= bt);
};
var $t = class extends i3 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i43, t64, e73) {
    super._$AT(i43, t64, e73), wt(this), this.isConnected = i43._$AU;
  }
  _$AO(i43, t64 = true) {
    i43 !== this.isConnected && (this.isConnected = i43, i43 ? this.reconnected?.() : this.disconnected?.()), t64 && (mt(this, i43), _t(this));
  }
  setValue(i43) {
    if (rt(this.t)) this.t._$AI(i43, this);
    else {
      const t64 = [...this.t._$AH];
      t64[this.i] = i43, this.t._$AI(t64, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var ii = () => new Zt();
var Zt = class {
};
var qt = /* @__PURE__ */ new WeakMap();
var Kt = e6(class extends $t {
  render(t64) {
    return D;
  }
  update(t64, [i43]) {
    const s33 = i43 !== this.Y;
    return s33 && void 0 !== this.Y && this.rt(void 0), (s33 || this.lt !== this.ct) && (this.Y = i43, this.ht = t64.options?.host, this.rt(this.ct = t64.element)), D;
  }
  rt(t64) {
    if (this.isConnected || (t64 = void 0), "function" == typeof this.Y) {
      const i43 = this.ht ?? globalThis;
      let s33 = qt.get(i43);
      void 0 === s33 && (s33 = /* @__PURE__ */ new WeakMap(), qt.set(i43, s33)), void 0 !== s33.get(this.Y) && this.Y.call(this.ht, void 0), s33.set(this.Y, t64), void 0 !== t64 && this.Y.call(this.ht, t64);
    } else this.Y.value = t64;
  }
  get lt() {
    return "function" == typeof this.Y ? qt.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var SubmenuController = class {
  constructor(host, hasSlotController) {
    this.popupRef = ii();
    this.enableSubmenuTimer = -1;
    this.isConnected = false;
    this.isPopupConnected = false;
    this.skidding = 0;
    this.submenuOpenDelay = 100;
    this.handleMouseMove = (event) => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${event.clientX}px`);
      this.host.style.setProperty("--safe-triangle-cursor-y", `${event.clientY}px`);
    };
    this.handleMouseOver = () => {
      if (this.hasSlotController.test("submenu")) {
        this.enableSubmenu();
      }
    };
    this.handleKeyDown = (event) => {
      switch (event.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          if (event.target !== this.host) {
            event.preventDefault();
            event.stopPropagation();
            this.host.focus();
            this.disableSubmenu();
          }
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(event);
          break;
        default:
          break;
      }
    };
    this.handleClick = (event) => {
      var _a33;
      if (event.target === this.host) {
        event.preventDefault();
        event.stopPropagation();
      } else if (event.target instanceof Element && (event.target.tagName === "sl-menu-item" || ((_a33 = event.target.role) == null ? void 0 : _a33.startsWith("menuitem")))) {
        this.disableSubmenu();
      }
    };
    this.handleFocusOut = (event) => {
      if (event.relatedTarget && event.relatedTarget instanceof Element && this.host.contains(event.relatedTarget)) {
        return;
      }
      this.disableSubmenu();
    };
    this.handlePopupMouseover = (event) => {
      event.stopPropagation();
    };
    this.handlePopupReposition = () => {
      const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
      const menu = submenuSlot == null ? void 0 : submenuSlot.assignedElements({ flatten: true }).filter((el) => el.localName === "sl-menu")[0];
      const isRtl = this.host.matches(":dir(rtl)");
      if (!menu) {
        return;
      }
      const { left, top, width, height } = menu.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-start-y", `${top}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-y", `${top + height}px`);
    };
    (this.host = host).addController(this);
    this.hasSlotController = hasSlotController;
  }
  hostConnected() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
    }
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
      this.updateSkidding();
    } else {
      this.removeListeners();
    }
  }
  addListeners() {
    if (!this.isConnected) {
      this.host.addEventListener("mousemove", this.handleMouseMove);
      this.host.addEventListener("mouseover", this.handleMouseOver);
      this.host.addEventListener("keydown", this.handleKeyDown);
      this.host.addEventListener("click", this.handleClick);
      this.host.addEventListener("focusout", this.handleFocusOut);
      this.isConnected = true;
    }
    if (!this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = true;
      }
    }
  }
  removeListeners() {
    if (this.isConnected) {
      this.host.removeEventListener("mousemove", this.handleMouseMove);
      this.host.removeEventListener("mouseover", this.handleMouseOver);
      this.host.removeEventListener("keydown", this.handleKeyDown);
      this.host.removeEventListener("click", this.handleClick);
      this.host.removeEventListener("focusout", this.handleFocusOut);
      this.isConnected = false;
    }
    if (this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = false;
      }
    }
  }
  handleSubmenuEntry(event) {
    const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!submenuSlot) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let menuItems = null;
    for (const elt of submenuSlot.assignedElements()) {
      menuItems = elt.querySelectorAll("sl-menu-item, [role^='menuitem']");
      if (menuItems.length !== 0) {
        break;
      }
    }
    if (!menuItems || menuItems.length === 0) {
      return;
    }
    menuItems[0].setAttribute("tabindex", "0");
    for (let i43 = 1; i43 !== menuItems.length; ++i43) {
      menuItems[i43].setAttribute("tabindex", "-1");
    }
    if (this.popupRef.value) {
      event.preventDefault();
      event.stopPropagation();
      if (this.popupRef.value.active) {
        if (menuItems[0] instanceof HTMLElement) {
          menuItems[0].focus();
        }
      } else {
        this.enableSubmenu(false);
        this.host.updateComplete.then(() => {
          if (menuItems[0] instanceof HTMLElement) {
            menuItems[0].focus();
          }
        });
        this.host.requestUpdate();
      }
    }
  }
  setSubmenuState(state) {
    if (this.popupRef.value) {
      if (this.popupRef.value.active !== state) {
        this.popupRef.value.active = state;
        this.host.requestUpdate();
      }
    }
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(delay = true) {
    if (delay) {
      window.clearTimeout(this.enableSubmenuTimer);
      this.enableSubmenuTimer = window.setTimeout(() => {
        this.setSubmenuState(true);
      }, this.submenuOpenDelay);
    } else {
      this.setSubmenuState(true);
    }
  }
  disableSubmenu() {
    window.clearTimeout(this.enableSubmenuTimer);
    this.setSubmenuState(false);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var _a33;
    if (!((_a33 = this.host.parentElement) == null ? void 0 : _a33.computedStyleMap)) {
      return;
    }
    const styleMap = this.host.parentElement.computedStyleMap();
    const attrs = ["padding-top", "border-top-width", "margin-top"];
    const skidding = attrs.reduce((accumulator, attr) => {
      var _a222;
      const styleValue = (_a222 = styleMap.get(attr)) != null ? _a222 : new CSSUnitValue(0, "px");
      const unitValue = styleValue instanceof CSSUnitValue ? styleValue : new CSSUnitValue(0, "px");
      const pxValue = unitValue.to("px");
      return accumulator - pxValue.value;
    }, 0);
    this.skidding = skidding;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : false;
  }
  renderSubmenu() {
    const isRtl = this.host.matches(":dir(rtl)");
    if (!this.isConnected) {
      return ke` <slot name="submenu" hidden></slot> `;
    }
    return ke`
      <sl-popup
        ${Kt(this.popupRef)}
        placement=${isRtl ? "left-start" : "right-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
        auto-size="vertical"
        auto-size-padding="10"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    `;
  }
};
var SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.loading = false;
    this.disabled = false;
    this.hasSlotController = new HasSlotController(this, "submenu");
    this.submenuController = new SubmenuController(this, this.hasSlotController);
    this.handleHostClick = (event) => {
      if (this.disabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleMouseOver = (event) => {
      this.focus();
      event.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleHostClick);
    this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleHostClick);
    this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const isRtl = this.matches(":dir(rtl)");
    const isSubmenuExpanded = this.submenuController.isExpanded();
    return ke`
      <div
        id="anchor"
        part="base"
        class=${Rt({
      "menu-item": true,
      "menu-item--rtl": isRtl,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--loading": this.loading,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": isSubmenuExpanded
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${isSubmenuExpanded ? true : false}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${isRtl ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? ke` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e5("slot:not([name])")
], SlMenuItem.prototype, "defaultSlot", 2);
__decorateClass([
  e5(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([
  n5()
], SlMenuItem.prototype, "type", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "checked", 2);
__decorateClass([
  n5()
], SlMenuItem.prototype, "value", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "loading", 2);
__decorateClass([
  n5({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("type")
], SlMenuItem.prototype, "handleTypeChange", 1);
var ui_checks_grid_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-ui-checks-grid" viewBox="0 0 16 16">%0A  <path d="M2 10h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1m9-9h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1m0 9a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1zm0-10a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zM2 9a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2zm7 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2h-3a2 2 0 0 1-2-2zM0 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5.354.854a.5.5 0 1 0-.708-.708L3 3.793l-.646-.647a.5.5 0 1 0-.708.708l1 1a.5.5 0 0 0 .708 0z"/>%0A</svg>';
var __default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-123" viewBox="0 0 16 16">%0A  <path d="M2.873 11.297V4.142H1.699L0 5.379v1.137l1.64-1.18h.06v5.961zm3.213-5.09v-.063c0-.618.44-1.169 1.196-1.169.676 0 1.174.44 1.174 1.106 0 .624-.42 1.101-.807 1.526L4.99 10.553v.744h4.78v-.99H6.643v-.069L8.41 8.252c.65-.724 1.237-1.332 1.237-2.27C9.646 4.849 8.723 4 7.308 4c-1.573 0-2.36 1.064-2.36 2.15v.057zm6.559 1.883h.786c.823 0 1.374.481 1.379 1.179.01.707-.55 1.216-1.421 1.21-.77-.005-1.326-.419-1.379-.953h-1.095c.042 1.053.938 1.918 2.464 1.918 1.478 0 2.642-.839 2.62-2.144-.02-1.143-.922-1.651-1.551-1.714v-.063c.535-.09 1.347-.66 1.326-1.678-.026-1.053-.933-1.855-2.359-1.845-1.5.005-2.317.88-2.348 1.898h1.116c.032-.498.498-.944 1.206-.944.703 0 1.206.435 1.206 1.07.005.64-.504 1.106-1.2 1.106h-.75z"/>%0A</svg>';
var card_text_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-card-text" viewBox="0 0 16 16">%0A  <path d="M14.5 3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5zm-13-1A1.5 1.5 0 0 0 0 3.5v9A1.5 1.5 0 0 0 1.5 14h13a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 14.5 2z"/>%0A  <path d="M3 5.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M3 8a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 8m0 2.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5"/>%0A</svg>';
var highlighter_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">%0A  <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065zM5.293 13.5 2.5 10.707v1.586L3.707 13.5z"/>%0A</svg>';
var mic_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-mic" viewBox="0 0 16 16">%0A  <path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5"/>%0A  <path d="M10 8a2 2 0 1 1-4 0V3a2 2 0 1 1 4 0zM8 0a3 3 0 0 0-3 3v5a3 3 0 0 0 6 0V3a3 3 0 0 0-3-3"/>%0A</svg>';
function shuffle(a33) {
  for (let i43 = a33.length - 1; i43 > 0; i43--) {
    const j33 = Math.floor(Math.random() * (i43 + 1));
    [a33[i43], a33[j33]] = [a33[j33], a33[i43]];
  }
  return a33;
}
var _submitted_dec;
var _tasks_dec;
var _slotEl_dec;
var _counter_dec;
var _randomOrder_dec;
var _a2;
var _WebwriterQuiz_decorators;
var _init2;
var _randomOrder;
var _slotEl;
var _tasks;
var _submitted;
_WebwriterQuiz_decorators = [t3("webwriter-quiz")];
var _WebwriterQuiz = class _WebwriterQuiz2 extends (_a2 = LitElementWw, _randomOrder_dec = [n5({ type: Boolean, attribute: true, reflect: true }), option({ type: Boolean, label: { "en": "Random Task Order" } })], _counter_dec = [n5({ attribute: true }), option({
  type: "select",
  label: {
    "en": "Counter"
  },
  options: [
    { value: void 0, label: { "en": "None" } },
    { value: "number", label: { "en": "1. 2. 3." } },
    { value: "roman", label: { "en": "i. ii. iii." } },
    { value: "roman-capitalized", label: { "en": "I. II. III." } },
    { value: "alphabetical", label: { "en": "a. b. c." } },
    { value: "alphabetical-capitalized", label: { "en": "A. B. C." } }
  ]
})], _slotEl_dec = [e5("slot")], _tasks_dec = [o5()], _submitted_dec = [n5({ type: Boolean, attribute: true, reflect: true })], _a2) {
  constructor() {
    super(...arguments);
    __runInitializers(_init2, 5, this);
    __publicField(this, "msg", (str) => this.lang in _WebwriterQuiz2.localization ? _WebwriterQuiz2.localization[this.lang][str] ?? str : str);
    __privateAdd(this, _randomOrder, __runInitializers(_init2, 8, this, false)), __runInitializers(_init2, 11, this);
    __publicField(this, "handleReset", () => {
      this.tasks.forEach((task) => task.reset());
      this.requestUpdate();
      this.submitted = false;
    });
    __publicField(this, "observer");
    __privateAdd(this, _slotEl, __runInitializers(_init2, 12, this)), __runInitializers(_init2, 15, this);
    __privateAdd(this, _tasks, __runInitializers(_init2, 16, this)), __runInitializers(_init2, 19, this);
    __privateAdd(this, _submitted, __runInitializers(_init2, 20, this, false)), __runInitializers(_init2, 23, this);
  }
  get answerTypes() {
    return {
      "webwriter-choice": {
        label: this.msg("Choice"),
        icon: ui_checks_grid_default
      },
      "webwriter-order": {
        label: this.msg("Order"),
        icon: __default
      },
      "webwriter-text": {
        label: this.msg("Text"),
        icon: card_text_default
      },
      "webwriter-mark": {
        label: this.msg("Mark"),
        icon: highlighter_default
      },
      /*
      "webwriter-pairing": {
        label: this.msg("Pairing"),
        icon: IconSubtract
      },
      "webwriter-cloze": {
        label: this.msg("Cloze"),
        icon: IconBodyText
      },*/
      "webwriter-speech": {
        label: this.msg("Speech"),
        //advanced: true,
        icon: mic_default
      }
      /*"webwriter-wordsearch": {
        label: this.msg("Word Search"),
        advanced: true,
        icon: IconSearch
      },
      "webwriter-memory": {
        label: this.msg("Memory"),
        advanced: true,
        icon: IconGrid3x3Gap
      }*/
    };
  }
  addTask(answerTypeName) {
    const task = this.ownerDocument.createElement("webwriter-task");
    task.setAttribute("counter", this.counter);
    const prompt = this.ownerDocument.createElement("webwriter-task-prompt");
    const p33 = this.ownerDocument.createElement("p");
    prompt.append(p33);
    prompt.slot = "prompt";
    const answer = this.ownerDocument.createElement(answerTypeName);
    task.appendChild(prompt);
    task.appendChild(answer);
    this.appendChild(task);
    document.getSelection().setBaseAndExtent(p33, 0, p33, 0);
  }
  get counter() {
    return this.tasks[0]?.counter;
  }
  set counter(value) {
    this.tasks.forEach((el) => el.counter = value);
  }
  shuffleTasks() {
    const n63 = this.tasks.length;
    const nums = shuffle([...new Array(n63).keys()]);
    this.tasks.forEach((el, i43) => el.style.order = String(nums[i43]));
  }
  handleSubmit(e73) {
    this.submitted = true;
    this.dispatchEvent(new Event("submit"));
    this.tasks.forEach((task) => task.handleSubmit());
  }
  connectedCallback() {
    super.connectedCallback();
    this.observer = new MutationObserver(() => {
      if (!this.contentEditable && this.randomOrder) {
        this.shuffleTasks();
      }
    });
    this.observer.observe(this, { childList: true });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.observer.disconnect();
  }
  get isChanged() {
    return this.tasks.some((task) => task.isChanged);
  }
  render() {
    const basicAnswerTypes = Object.keys(this.answerTypes).filter((k33) => !this.answerTypes[k33]?.advanced);
    const otherAnswerTypes = Object.keys(this.answerTypes).filter((k33) => this.answerTypes[k33]?.advanced);
    return ke`
      <slot ?inert=${this.submitted} @ww-answer-change=${() => this.requestUpdate()}></slot>
        <sl-button-group class="user-only user-actions">
          <sl-button id="submit" @click=${this.handleSubmit}>Submit</sl-button>
          <sl-button ?disabled=${!this.isChanged} id="reset" @click=${this.handleReset}>Reset</sl-button>
        </sl-button-group>
      <sl-button-group class="author-only">
        ${basicAnswerTypes.map((k33) => ke`
          <sl-button @click=${() => this.addTask(k33)}>
            <sl-icon src=${this.answerTypes[k33]?.icon}></sl-icon>
            ${this.answerTypes[k33].label}
          </sl-button>
        `)}
        <sl-dropdown data-empty=${!otherAnswerTypes.length} placement="bottom-end" hoist>
          <sl-button slot="trigger" caret></sl-button>
          <sl-menu>
            ${otherAnswerTypes.map((k33) => ke`
            <sl-menu-item @click=${() => this.addTask(k33)}>
              <sl-icon src=${this.answerTypes[k33]?.icon}></sl-icon>
              ${this.answerTypes[k33].label}
            </sl-menu-item>
            `)}
          </sl-menu>
        </sl-dropdown>
      </sl-button-group>
      `;
  }
};
_init2 = __decoratorStart(_a2);
_randomOrder = /* @__PURE__ */ new WeakMap();
_slotEl = /* @__PURE__ */ new WeakMap();
_tasks = /* @__PURE__ */ new WeakMap();
_submitted = /* @__PURE__ */ new WeakMap();
__decorateElement(_init2, 4, "randomOrder", _randomOrder_dec, _WebwriterQuiz, _randomOrder);
__decorateElement(_init2, 3, "counter", _counter_dec, _WebwriterQuiz);
__decorateElement(_init2, 4, "slotEl", _slotEl_dec, _WebwriterQuiz, _slotEl);
__decorateElement(_init2, 4, "tasks", _tasks_dec, _WebwriterQuiz, _tasks);
__decorateElement(_init2, 4, "submitted", _submitted_dec, _WebwriterQuiz, _submitted);
_WebwriterQuiz = __decorateElement(_init2, 0, "WebwriterQuiz", _WebwriterQuiz_decorators, _WebwriterQuiz);
__publicField(_WebwriterQuiz, "localization", {});
__publicField(_WebwriterQuiz, "scopedElements", {
  "sl-button": SlButton,
  "sl-button-group": SlButtonGroup,
  "sl-icon": SlIcon,
  "sl-dropdown": SlDropdown,
  "sl-menu": SlMenu,
  "sl-menu-item": SlMenuItem
});
__publicField(_WebwriterQuiz, "styles", i`
    :host {
      border-top: 1px solid darkgray;
      border-bottom: 1px solid darkgray;
      padding: 1ch;
      display: flex !important;
      flex-direction: column;
      gap: 2rem;
      counter-reset: task;
    }

    :host(:not([contenteditable=true]):not([contenteditable=""])) .author-only {
      display: none;
    }

    :host(:is([contenteditable=true], [contenteditable=""])) .user-only {
      display: none;
    }

    :host(:is([contenteditable=true], [contenteditable=""])) ::slotted(*) {
      order: unset !important;
    }

    sl-button-group::part(base) {
      display: flex;
    }

    sl-button-group > *:not(sl-dropdown) {
      flex-grow: 1;
    }

    sl-dropdown[data-empty] {
      display: none;
    }

    sl-button:not([caret])::part(label) {
      padding: 0;
      display: flex;
      flex-direction: row;
      width: 100%;
      justify-content: space-evenly;
      align-items: center;
    }

    sl-icon {
      width: 18px;
      height: 18px;
    }

    sl-menu::part(menu) {
      z-index: 10000;
    }

    .user-actions {
      & #submit {
        flex-grow: 3;
      }

      & #reset {
        flex-grow: 1;
      }
    }
  `);
__runInitializers(_init2, 1, _WebwriterQuiz);

// https:/cdn.jsdelivr.net/npm/@webwriter/quiz@1.0.5/dist/widgets/webwriter-task.js
var __create3 = Object.create;
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __knownSymbol3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name3 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var __decoratorStart3 = (base) => [, , , __create3(base?.[__knownSymbol3("metadata")] ?? null)];
var __decoratorStrings3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError3("Function expected") : fn;
var __decoratorContext3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings3[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError3("Already initialized") : fns.push(__expectFn3(fn || null)) });
var __decoratorMetadata3 = (array, target) => __defNormalProp4(target, __knownSymbol3("metadata"), array[3]);
var __runInitializers3 = (array, flags, self2, value) => {
  for (var i43 = 0, fns = array[flags >> 1], n63 = fns && fns.length; i43 < n63; i43++) flags & 1 ? fns[i43].call(self2) : value = fns[i43].call(self2, value);
  return value;
};
var __decorateElement3 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k33 = flags & 7, s33 = !!(flags & 8), p33 = !!(flags & 16);
  var j33 = k33 > 3 ? array.length + 1 : k33 ? s33 ? 1 : 2 : 0, key = __decoratorStrings3[k33 + 5];
  var initializers = k33 > 3 && (array[j33 - 1] = []), extraInitializers = array[j33] || (array[j33] = []);
  var desc = k33 && (!p33 && !s33 && (target = target.prototype), k33 < 5 && (k33 > 3 || !p33) && __getOwnPropDesc4(k33 < 4 ? target : { get [name]() {
    return __privateGet4(this, extra);
  }, set [name](x32) {
    return __privateSet4(this, extra, x32);
  } }, name));
  k33 ? p33 && k33 < 4 && __name3(extra, (k33 > 2 ? "set " : k33 > 1 ? "get " : "") + name) : __name3(target, name);
  for (var i43 = decorators.length - 1; i43 >= 0; i43--) {
    ctx = __decoratorContext3(k33, name, done = {}, array[3], extraInitializers);
    if (k33) {
      ctx.static = s33, ctx.private = p33, access = ctx.access = { has: p33 ? (x32) => __privateIn3(target, x32) : (x32) => name in x32 };
      if (k33 ^ 3) access.get = p33 ? (x32) => (k33 ^ 1 ? __privateGet4 : __privateMethod3)(x32, target, k33 ^ 4 ? extra : desc.get) : (x32) => x32[name];
      if (k33 > 2) access.set = p33 ? (x32, y33) => __privateSet4(x32, target, y33, k33 ^ 4 ? extra : desc.set) : (x32, y33) => x32[name] = y33;
    }
    it = (0, decorators[i43])(k33 ? k33 < 4 ? p33 ? extra : desc[key] : k33 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k33 ^ 4 || it === void 0) __expectFn3(it) && (k33 > 4 ? initializers.unshift(it) : k33 ? p33 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError3("Object expected");
    else __expectFn3(fn = it.get) && (desc.get = fn), __expectFn3(fn = it.set) && (desc.set = fn), __expectFn3(fn = it.init) && initializers.unshift(fn);
  }
  return k33 || __decoratorMetadata3(array, target), desc && __defProp4(target, name, desc), p33 ? k33 ^ 4 ? extra : desc : target;
};
var __publicField3 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateIn3 = (member, obj) => Object(obj) !== obj ? __typeError3('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var t6 = globalThis;
var e7 = t6.ShadowRoot && (void 0 === t6.ShadyCSS || t6.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s3 = Symbol();
var o7 = /* @__PURE__ */ new WeakMap();
var n6 = class {
  constructor(t73, e73, o73) {
    if (this._$cssResult$ = true, o73 !== s3) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t73, this.t = e73;
  }
  get styleSheet() {
    let t73 = this.o;
    const s33 = this.t;
    if (e7 && void 0 === t73) {
      const e73 = void 0 !== s33 && 1 === s33.length;
      e73 && (t73 = o7.get(s33)), void 0 === t73 && ((this.o = t73 = new CSSStyleSheet()).replaceSync(this.cssText), e73 && o7.set(s33, t73));
    }
    return t73;
  }
  toString() {
    return this.cssText;
  }
};
var r7 = (t73) => new n6("string" == typeof t73 ? t73 : t73 + "", void 0, s3);
var i4 = (t73, ...e73) => {
  const o73 = 1 === t73.length ? t73[0] : e73.reduce((e83, s33, o83) => e83 + ((t83) => {
    if (true === t83._$cssResult$) return t83.cssText;
    if ("number" == typeof t83) return t83;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t83 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s33) + t73[o83 + 1], t73[0]);
  return new n6(o73, t73, s3);
};
var S4 = (s33, o73) => {
  if (e7) s33.adoptedStyleSheets = o73.map((t73) => t73 instanceof CSSStyleSheet ? t73 : t73.styleSheet);
  else for (const e73 of o73) {
    const o83 = document.createElement("style"), n63 = t6.litNonce;
    void 0 !== n63 && o83.setAttribute("nonce", n63), o83.textContent = e73.cssText, s33.appendChild(o83);
  }
};
var c5 = e7 ? (t73) => t73 : (t73) => t73 instanceof CSSStyleSheet ? ((t83) => {
  let e73 = "";
  for (const s33 of t83.cssRules) e73 += s33.cssText;
  return r7(e73);
})(t73) : t73;
var { is: i23, defineProperty: e23, getOwnPropertyDescriptor: r23, getOwnPropertyNames: h5, getOwnPropertySymbols: o23, getPrototypeOf: n23 } = Object;
var a3 = globalThis;
var c23 = a3.trustedTypes;
var l3 = c23 ? c23.emptyScript : "";
var p3 = a3.reactiveElementPolyfillSupport;
var d3 = (t73, s33) => t73;
var u3 = { toAttribute(t73, s33) {
  switch (s33) {
    case Boolean:
      t73 = t73 ? l3 : null;
      break;
    case Object:
    case Array:
      t73 = null == t73 ? t73 : JSON.stringify(t73);
  }
  return t73;
}, fromAttribute(t73, s33) {
  let i43 = t73;
  switch (s33) {
    case Boolean:
      i43 = null !== t73;
      break;
    case Number:
      i43 = null === t73 ? null : Number(t73);
      break;
    case Object:
    case Array:
      try {
        i43 = JSON.parse(t73);
      } catch (t83) {
        i43 = null;
      }
  }
  return i43;
} };
var f5 = (t73, s33) => !i23(t73, s33);
var y3 = { attribute: true, type: String, converter: u3, reflect: false, hasChanged: f5 };
Symbol.metadata ??= Symbol("metadata"), a3.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b3 = class extends HTMLElement {
  static addInitializer(t73) {
    this._$Ei(), (this.l ??= []).push(t73);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t73, s33 = y3) {
    if (s33.state && (s33.attribute = false), this._$Ei(), this.elementProperties.set(t73, s33), !s33.noAccessor) {
      const i43 = Symbol(), r73 = this.getPropertyDescriptor(t73, i43, s33);
      void 0 !== r73 && e23(this.prototype, t73, r73);
    }
  }
  static getPropertyDescriptor(t73, s33, i43) {
    const { get: e73, set: h53 } = r23(this.prototype, t73) ?? { get() {
      return this[s33];
    }, set(t83) {
      this[s33] = t83;
    } };
    return { get() {
      return e73?.call(this);
    }, set(s43) {
      const r73 = e73?.call(this);
      h53.call(this, s43), this.requestUpdate(t73, r73, i43);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t73) {
    return this.elementProperties.get(t73) ?? y3;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d3("elementProperties"))) return;
    const t73 = n23(this);
    t73.finalize(), void 0 !== t73.l && (this.l = [...t73.l]), this.elementProperties = new Map(t73.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d3("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d3("properties"))) {
      const t83 = this.properties, s33 = [...h5(t83), ...o23(t83)];
      for (const i43 of s33) this.createProperty(i43, t83[i43]);
    }
    const t73 = this[Symbol.metadata];
    if (null !== t73) {
      const s33 = litPropertyMetadata.get(t73);
      if (void 0 !== s33) for (const [t83, i43] of s33) this.elementProperties.set(t83, i43);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t83, s33] of this.elementProperties) {
      const i43 = this._$Eu(t83, s33);
      void 0 !== i43 && this._$Eh.set(i43, t83);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s33) {
    const i43 = [];
    if (Array.isArray(s33)) {
      const e73 = new Set(s33.flat(1 / 0).reverse());
      for (const s43 of e73) i43.unshift(c5(s43));
    } else void 0 !== s33 && i43.push(c5(s33));
    return i43;
  }
  static _$Eu(t73, s33) {
    const i43 = s33.attribute;
    return false === i43 ? void 0 : "string" == typeof i43 ? i43 : "string" == typeof t73 ? t73.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t73) => this.enableUpdating = t73), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t73) => t73(this));
  }
  addController(t73) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t73), void 0 !== this.renderRoot && this.isConnected && t73.hostConnected?.();
  }
  removeController(t73) {
    this._$EO?.delete(t73);
  }
  _$E_() {
    const t73 = /* @__PURE__ */ new Map(), s33 = this.constructor.elementProperties;
    for (const i43 of s33.keys()) this.hasOwnProperty(i43) && (t73.set(i43, this[i43]), delete this[i43]);
    t73.size > 0 && (this._$Ep = t73);
  }
  createRenderRoot() {
    const t73 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S4(t73, this.constructor.elementStyles), t73;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t73) => t73.hostConnected?.());
  }
  enableUpdating(t73) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t73) => t73.hostDisconnected?.());
  }
  attributeChangedCallback(t73, s33, i43) {
    this._$AK(t73, i43);
  }
  _$EC(t73, s33) {
    const i43 = this.constructor.elementProperties.get(t73), e73 = this.constructor._$Eu(t73, i43);
    if (void 0 !== e73 && true === i43.reflect) {
      const r73 = (void 0 !== i43.converter?.toAttribute ? i43.converter : u3).toAttribute(s33, i43.type);
      this._$Em = t73, null == r73 ? this.removeAttribute(e73) : this.setAttribute(e73, r73), this._$Em = null;
    }
  }
  _$AK(t73, s33) {
    const i43 = this.constructor, e73 = i43._$Eh.get(t73);
    if (void 0 !== e73 && this._$Em !== e73) {
      const t83 = i43.getPropertyOptions(e73), r73 = "function" == typeof t83.converter ? { fromAttribute: t83.converter } : void 0 !== t83.converter?.fromAttribute ? t83.converter : u3;
      this._$Em = e73, this[e73] = r73.fromAttribute(s33, t83.type), this._$Em = null;
    }
  }
  requestUpdate(t73, s33, i43) {
    if (void 0 !== t73) {
      if (i43 ??= this.constructor.getPropertyOptions(t73), !(i43.hasChanged ?? f5)(this[t73], s33)) return;
      this.P(t73, s33, i43);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t73, s33, i43) {
    this._$AL.has(t73) || this._$AL.set(t73, s33), true === i43.reflect && this._$Em !== t73 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t73);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t83) {
      Promise.reject(t83);
    }
    const t73 = this.scheduleUpdate();
    return null != t73 && await t73, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t93, s43] of this._$Ep) this[t93] = s43;
        this._$Ep = void 0;
      }
      const t83 = this.constructor.elementProperties;
      if (t83.size > 0) for (const [s43, i43] of t83) true !== i43.wrapped || this._$AL.has(s43) || void 0 === this[s43] || this.P(s43, this[s43], i43);
    }
    let t73 = false;
    const s33 = this._$AL;
    try {
      t73 = this.shouldUpdate(s33), t73 ? (this.willUpdate(s33), this._$EO?.forEach((t83) => t83.hostUpdate?.()), this.update(s33)) : this._$EU();
    } catch (s43) {
      throw t73 = false, this._$EU(), s43;
    }
    t73 && this._$AE(s33);
  }
  willUpdate(t73) {
  }
  _$AE(t73) {
    this._$EO?.forEach((t83) => t83.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t73)), this.updated(t73);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t73) {
    return true;
  }
  update(t73) {
    this._$Ej &&= this._$Ej.forEach((t83) => this._$EC(t83, this[t83])), this._$EU();
  }
  updated(t73) {
  }
  firstUpdated(t73) {
  }
};
b3.elementStyles = [], b3.shadowRootOptions = { mode: "open" }, b3[d3("elementProperties")] = /* @__PURE__ */ new Map(), b3[d3("finalized")] = /* @__PURE__ */ new Map(), p3?.({ ReactiveElement: b3 }), (a3.reactiveElementVersions ??= []).push("2.0.4");
var n33 = globalThis;
var c33 = n33.trustedTypes;
var h23 = c33 ? c33.createPolicy("lit-html", { createHTML: (t73) => t73 }) : void 0;
var f23 = "$lit$";
var v3 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m3 = "?" + v3;
var _3 = `<${m3}>`;
var w3 = document;
var lt3 = () => w3.createComment("");
var st3 = (t73) => null === t73 || "object" != typeof t73 && "function" != typeof t73;
var g3 = Array.isArray;
var $3 = (t73) => g3(t73) || "function" == typeof t73?.[Symbol.iterator];
var x3 = "[ 	\n\f\r]";
var T3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E3 = /-->/g;
var k3 = />/g;
var O3 = RegExp(`>|${x3}(?:([^\\s"'>=/]+)(${x3}*=${x3}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S23 = /'/g;
var j3 = /"/g;
var M3 = /^(?:script|style|textarea|title)$/i;
var P3 = (t73) => (i43, ...s33) => ({ _$litType$: t73, strings: i43, values: s33 });
var ke4 = P3(1);
var Oe4 = P3(2);
var Se4 = P3(3);
var R3 = Symbol.for("lit-noChange");
var D3 = Symbol.for("lit-nothing");
var V3 = /* @__PURE__ */ new WeakMap();
var I3 = w3.createTreeWalker(w3, 129);
function N3(t73, i43) {
  if (!g3(t73) || !t73.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h23 ? h23.createHTML(i43) : i43;
}
var U3 = (t73, i43) => {
  const s33 = t73.length - 1, e73 = [];
  let h53, o73 = 2 === i43 ? "<svg>" : 3 === i43 ? "<math>" : "", n63 = T3;
  for (let i53 = 0; i53 < s33; i53++) {
    const s43 = t73[i53];
    let r73, l33, c53 = -1, a33 = 0;
    for (; a33 < s43.length && (n63.lastIndex = a33, l33 = n63.exec(s43), null !== l33); ) a33 = n63.lastIndex, n63 === T3 ? "!--" === l33[1] ? n63 = E3 : void 0 !== l33[1] ? n63 = k3 : void 0 !== l33[2] ? (M3.test(l33[2]) && (h53 = RegExp("</" + l33[2], "g")), n63 = O3) : void 0 !== l33[3] && (n63 = O3) : n63 === O3 ? ">" === l33[0] ? (n63 = h53 ?? T3, c53 = -1) : void 0 === l33[1] ? c53 = -2 : (c53 = n63.lastIndex - l33[2].length, r73 = l33[1], n63 = void 0 === l33[3] ? O3 : '"' === l33[3] ? j3 : S23) : n63 === j3 || n63 === S23 ? n63 = O3 : n63 === E3 || n63 === k3 ? n63 = T3 : (n63 = O3, h53 = void 0);
    const u33 = n63 === O3 && t73[i53 + 1].startsWith("/>") ? " " : "";
    o73 += n63 === T3 ? s43 + _3 : c53 >= 0 ? (e73.push(r73), s43.slice(0, c53) + f23 + s43.slice(c53) + v3 + u33) : s43 + v3 + (-2 === c53 ? i53 : u33);
  }
  return [N3(t73, o73 + (t73[s33] || "<?>") + (2 === i43 ? "</svg>" : 3 === i43 ? "</math>" : "")), e73];
};
var B3 = class _B22 {
  constructor({ strings: t73, _$litType$: i43 }, s33) {
    let e73;
    this.parts = [];
    let h53 = 0, o73 = 0;
    const n63 = t73.length - 1, r73 = this.parts, [l33, a33] = U3(t73, i43);
    if (this.el = _B22.createElement(l33, s33), I3.currentNode = this.el.content, 2 === i43 || 3 === i43) {
      const t83 = this.el.content.firstChild;
      t83.replaceWith(...t83.childNodes);
    }
    for (; null !== (e73 = I3.nextNode()) && r73.length < n63; ) {
      if (1 === e73.nodeType) {
        if (e73.hasAttributes()) for (const t83 of e73.getAttributeNames()) if (t83.endsWith(f23)) {
          const i53 = a33[o73++], s43 = e73.getAttribute(t83).split(v3), n73 = /([.?@])?(.*)/.exec(i53);
          r73.push({ type: 1, index: h53, name: n73[2], strings: s43, ctor: "." === n73[1] ? Y3 : "?" === n73[1] ? Z3 : "@" === n73[1] ? q3 : G3 }), e73.removeAttribute(t83);
        } else t83.startsWith(v3) && (r73.push({ type: 6, index: h53 }), e73.removeAttribute(t83));
        if (M3.test(e73.tagName)) {
          const t83 = e73.textContent.split(v3), i53 = t83.length - 1;
          if (i53 > 0) {
            e73.textContent = c33 ? c33.emptyScript : "";
            for (let s43 = 0; s43 < i53; s43++) e73.append(t83[s43], lt3()), I3.nextNode(), r73.push({ type: 2, index: ++h53 });
            e73.append(t83[i53], lt3());
          }
        }
      } else if (8 === e73.nodeType) if (e73.data === m3) r73.push({ type: 2, index: h53 });
      else {
        let t83 = -1;
        for (; -1 !== (t83 = e73.data.indexOf(v3, t83 + 1)); ) r73.push({ type: 7, index: h53 }), t83 += v3.length - 1;
      }
      h53++;
    }
  }
  static createElement(t73, i43) {
    const s33 = w3.createElement("template");
    return s33.innerHTML = t73, s33;
  }
};
function z3(t73, i43, s33 = t73, e73) {
  if (i43 === R3) return i43;
  let h53 = void 0 !== e73 ? s33.o?.[e73] : s33.l;
  const o73 = st3(i43) ? void 0 : i43._$litDirective$;
  return h53?.constructor !== o73 && (h53?._$AO?.(false), void 0 === o73 ? h53 = void 0 : (h53 = new o73(t73), h53._$AT(t73, s33, e73)), void 0 !== e73 ? (s33.o ??= [])[e73] = h53 : s33.l = h53), void 0 !== h53 && (i43 = z3(t73, h53._$AS(t73, i43.values), h53, e73)), i43;
}
var F3 = class {
  constructor(t73, i43) {
    this._$AV = [], this._$AN = void 0, this._$AD = t73, this._$AM = i43;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t73) {
    const { el: { content: i43 }, parts: s33 } = this._$AD, e73 = (t73?.creationScope ?? w3).importNode(i43, true);
    I3.currentNode = e73;
    let h53 = I3.nextNode(), o73 = 0, n63 = 0, r73 = s33[0];
    for (; void 0 !== r73; ) {
      if (o73 === r73.index) {
        let i53;
        2 === r73.type ? i53 = new et4(h53, h53.nextSibling, this, t73) : 1 === r73.type ? i53 = new r73.ctor(h53, r73.name, r73.strings, this, t73) : 6 === r73.type && (i53 = new K3(h53, this, t73)), this._$AV.push(i53), r73 = s33[++n63];
      }
      o73 !== r73?.index && (h53 = I3.nextNode(), o73++);
    }
    return I3.currentNode = w3, e73;
  }
  p(t73) {
    let i43 = 0;
    for (const s33 of this._$AV) void 0 !== s33 && (void 0 !== s33.strings ? (s33._$AI(t73, s33, i43), i43 += s33.strings.length - 2) : s33._$AI(t73[i43])), i43++;
  }
};
var et4 = class _et22 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t73, i43, s33, e73) {
    this.type = 2, this._$AH = D3, this._$AN = void 0, this._$AA = t73, this._$AB = i43, this._$AM = s33, this.options = e73, this.v = e73?.isConnected ?? true;
  }
  get parentNode() {
    let t73 = this._$AA.parentNode;
    const i43 = this._$AM;
    return void 0 !== i43 && 11 === t73?.nodeType && (t73 = i43.parentNode), t73;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t73, i43 = this) {
    t73 = z3(this, t73, i43), st3(t73) ? t73 === D3 || null == t73 || "" === t73 ? (this._$AH !== D3 && this._$AR(), this._$AH = D3) : t73 !== this._$AH && t73 !== R3 && this._(t73) : void 0 !== t73._$litType$ ? this.$(t73) : void 0 !== t73.nodeType ? this.T(t73) : $3(t73) ? this.k(t73) : this._(t73);
  }
  O(t73) {
    return this._$AA.parentNode.insertBefore(t73, this._$AB);
  }
  T(t73) {
    this._$AH !== t73 && (this._$AR(), this._$AH = this.O(t73));
  }
  _(t73) {
    this._$AH !== D3 && st3(this._$AH) ? this._$AA.nextSibling.data = t73 : this.T(w3.createTextNode(t73)), this._$AH = t73;
  }
  $(t73) {
    const { values: i43, _$litType$: s33 } = t73, e73 = "number" == typeof s33 ? this._$AC(t73) : (void 0 === s33.el && (s33.el = B3.createElement(N3(s33.h, s33.h[0]), this.options)), s33);
    if (this._$AH?._$AD === e73) this._$AH.p(i43);
    else {
      const t83 = new F3(e73, this), s43 = t83.u(this.options);
      t83.p(i43), this.T(s43), this._$AH = t83;
    }
  }
  _$AC(t73) {
    let i43 = V3.get(t73.strings);
    return void 0 === i43 && V3.set(t73.strings, i43 = new B3(t73)), i43;
  }
  k(t73) {
    g3(this._$AH) || (this._$AH = [], this._$AR());
    const i43 = this._$AH;
    let s33, e73 = 0;
    for (const h53 of t73) e73 === i43.length ? i43.push(s33 = new _et22(this.O(lt3()), this.O(lt3()), this, this.options)) : s33 = i43[e73], s33._$AI(h53), e73++;
    e73 < i43.length && (this._$AR(s33 && s33._$AB.nextSibling, e73), i43.length = e73);
  }
  _$AR(t73 = this._$AA.nextSibling, i43) {
    for (this._$AP?.(false, true, i43); t73 && t73 !== this._$AB; ) {
      const i53 = t73.nextSibling;
      t73.remove(), t73 = i53;
    }
  }
  setConnected(t73) {
    void 0 === this._$AM && (this.v = t73, this._$AP?.(t73));
  }
};
var G3 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t73, i43, s33, e73, h53) {
    this.type = 1, this._$AH = D3, this._$AN = void 0, this.element = t73, this.name = i43, this._$AM = e73, this.options = h53, s33.length > 2 || "" !== s33[0] || "" !== s33[1] ? (this._$AH = Array(s33.length - 1).fill(new String()), this.strings = s33) : this._$AH = D3;
  }
  _$AI(t73, i43 = this, s33, e73) {
    const h53 = this.strings;
    let o73 = false;
    if (void 0 === h53) t73 = z3(this, t73, i43, 0), o73 = !st3(t73) || t73 !== this._$AH && t73 !== R3, o73 && (this._$AH = t73);
    else {
      const e83 = t73;
      let n63, r73;
      for (t73 = h53[0], n63 = 0; n63 < h53.length - 1; n63++) r73 = z3(this, e83[s33 + n63], i43, n63), r73 === R3 && (r73 = this._$AH[n63]), o73 ||= !st3(r73) || r73 !== this._$AH[n63], r73 === D3 ? t73 = D3 : t73 !== D3 && (t73 += (r73 ?? "") + h53[n63 + 1]), this._$AH[n63] = r73;
    }
    o73 && !e73 && this.j(t73);
  }
  j(t73) {
    t73 === D3 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t73 ?? "");
  }
};
var Y3 = class extends G3 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t73) {
    this.element[this.name] = t73 === D3 ? void 0 : t73;
  }
};
var Z3 = class extends G3 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t73) {
    this.element.toggleAttribute(this.name, !!t73 && t73 !== D3);
  }
};
var q3 = class extends G3 {
  constructor(t73, i43, s33, e73, h53) {
    super(t73, i43, s33, e73, h53), this.type = 5;
  }
  _$AI(t73, i43 = this) {
    if ((t73 = z3(this, t73, i43, 0) ?? D3) === R3) return;
    const s33 = this._$AH, e73 = t73 === D3 && s33 !== D3 || t73.capture !== s33.capture || t73.once !== s33.once || t73.passive !== s33.passive, h53 = t73 !== D3 && (s33 === D3 || e73);
    e73 && this.element.removeEventListener(this.name, this, s33), h53 && this.element.addEventListener(this.name, this, t73), this._$AH = t73;
  }
  handleEvent(t73) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t73) : this._$AH.handleEvent(t73);
  }
};
var K3 = class {
  constructor(t73, i43, s33) {
    this.element = t73, this.type = 6, this._$AN = void 0, this._$AM = i43, this.options = s33;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t73) {
    z3(this, t73);
  }
};
var si2 = { M: f23, P: v3, A: m3, C: 1, L: U3, R: F3, D: $3, V: z3, I: et4, H: G3, N: Z3, U: q3, B: Y3, F: K3 };
var Re3 = n33.litHtmlPolyfillSupport;
Re3?.(B3, et4), (n33.litHtmlVersions ??= []).push("3.2.0");
var Q3 = (t73, i43, s33) => {
  const e73 = s33?.renderBefore ?? i43;
  let h53 = e73._$litPart$;
  if (void 0 === h53) {
    const t83 = s33?.renderBefore ?? null;
    e73._$litPart$ = h53 = new et4(i43.insertBefore(lt3(), t83), t83, void 0, s33 ?? {});
  }
  return h53._$AI(t73), h53;
};
var h33 = class extends b3 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t73 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t73.firstChild, t73;
  }
  update(t73) {
    const e73 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t73), this.o = Q3(e73, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R3;
  }
};
h33._$litElement$ = true, h33["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h33 });
var f33 = globalThis.litElementPolyfillSupport;
f33?.({ LitElement: h33 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var t22 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e32 = (t73) => (...e73) => ({ _$litDirective$: t73, values: e73 });
var i32 = class {
  constructor(t73) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t73, e73, i43) {
    this.t = t73, this._$AM = e73, this.i = i43;
  }
  _$AS(t73, e73) {
    return this.update(t73, e73);
  }
  update(t73, e73) {
    return this.render(...e73);
  }
};
var ee = "important";
var ie = " !" + ee;
var se = e32(class extends i32 {
  constructor(e73) {
    if (super(e73), e73.type !== t22.ATTRIBUTE || "style" !== e73.name || e73.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t73) {
    return Object.keys(t73).reduce((e73, r73) => {
      const s33 = t73[r73];
      return null == s33 ? e73 : e73 + `${r73 = r73.includes("-") ? r73 : r73.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s33};`;
    }, "");
  }
  update(t73, [e73]) {
    const { style: r73 } = t73.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(e73)), this.render(e73);
    for (const t83 of this.ft) null == e73[t83] && (this.ft.delete(t83), t83.includes("-") ? r73.removeProperty(t83) : r73[t83] = null);
    for (const t83 in e73) {
      const s33 = e73[t83];
      if (null != s33) {
        this.ft.add(t83);
        const e83 = "string" == typeof s33 && s33.endsWith(ie);
        t83.includes("-") || e83 ? r73.setProperty(t83, e83 ? s33.slice(0, -11) : s33, e83 ? ee : "") : r73[t83] = s33;
      }
    }
    return R3;
  }
});
var __create22 = Object.create;
var __defProp22 = Object.defineProperty;
var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
var __knownSymbol22 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError22 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name22 = (target, value) => __defProp22(target, "name", { value, configurable: true });
var __decoratorStart22 = (base) => [, , , __create22(base?.[__knownSymbol22("metadata")] ?? null)];
var __decoratorStrings22 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn22 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError22("Function expected") : fn;
var __decoratorContext22 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings22[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError22("Already initialized") : fns.push(__expectFn22(fn || null)) });
var __decoratorMetadata22 = (array, target) => __defNormalProp22(target, __knownSymbol22("metadata"), array[3]);
var __runInitializers22 = (array, flags, self2, value) => {
  for (var i322 = 0, fns = array[flags >> 1], n522 = fns && fns.length; i322 < n522; i322++) flags & 1 ? fns[i322].call(self2) : value = fns[i322].call(self2, value);
  return value;
};
var __decorateElement22 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k222 = flags & 7, s222 = !!(flags & 8), p222 = !!(flags & 16);
  var j222 = k222 > 3 ? array.length + 1 : k222 ? s222 ? 1 : 2 : 0, key = __decoratorStrings22[k222 + 5];
  var initializers = k222 > 3 && (array[j222 - 1] = []), extraInitializers = array[j222] || (array[j222] = []);
  var desc = k222 && (!p222 && !s222 && (target = target.prototype), k222 < 5 && (k222 > 3 || !p222) && __getOwnPropDesc22(k222 < 4 ? target : { get [name]() {
    return __privateGet22(this, extra);
  }, set [name](x222) {
    return __privateSet22(this, extra, x222);
  } }, name));
  k222 ? p222 && k222 < 4 && __name22(extra, (k222 > 2 ? "set " : k222 > 1 ? "get " : "") + name) : __name22(target, name);
  for (var i322 = decorators.length - 1; i322 >= 0; i322--) {
    ctx = __decoratorContext22(k222, name, done = {}, array[3], extraInitializers);
    if (k222) {
      ctx.static = s222, ctx.private = p222, access = ctx.access = { has: p222 ? (x222) => __privateIn22(target, x222) : (x222) => name in x222 };
      if (k222 ^ 3) access.get = p222 ? (x222) => (k222 ^ 1 ? __privateGet22 : __privateMethod22)(x222, target, k222 ^ 4 ? extra : desc.get) : (x222) => x222[name];
      if (k222 > 2) access.set = p222 ? (x222, y222) => __privateSet22(x222, target, y222, k222 ^ 4 ? extra : desc.set) : (x222, y222) => x222[name] = y222;
    }
    it = (0, decorators[i322])(k222 ? k222 < 4 ? p222 ? extra : desc[key] : k222 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k222 ^ 4 || it === void 0) __expectFn22(it) && (k222 > 4 ? initializers.unshift(it) : k222 ? p222 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError22("Object expected");
    else __expectFn22(fn = it.get) && (desc.get = fn), __expectFn22(fn = it.set) && (desc.set = fn), __expectFn22(fn = it.init) && initializers.unshift(fn);
  }
  return k222 || __decoratorMetadata22(array, target), desc && __defProp22(target, name, desc), p222 ? k222 ^ 4 ? extra : desc : target;
};
var __publicField22 = (obj, key, value) => __defNormalProp22(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck22 = (obj, member, msg) => member.has(obj) || __typeError22("Cannot " + msg);
var __privateIn22 = (member, obj) => Object(obj) !== obj ? __typeError22('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet22 = (obj, member, getter) => (__accessCheck22(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd22 = (obj, member, value) => member.has(obj) ? __typeError22("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet22 = (obj, member, value, setter) => (__accessCheck22(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod22 = (obj, member, method) => (__accessCheck22(obj, member, "access private method"), method);
var t32 = globalThis;
var e42 = t32.ShadowRoot && (void 0 === t32.ShadyCSS || t32.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s22 = Symbol();
var o33 = /* @__PURE__ */ new WeakMap();
var n43 = class {
  constructor(t222, e422, o422) {
    if (this._$cssResult$ = true, o422 !== s22) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t222, this.t = e422;
  }
  get styleSheet() {
    let t222 = this.o;
    const s222 = this.t;
    if (e42 && void 0 === t222) {
      const e422 = void 0 !== s222 && 1 === s222.length;
      e422 && (t222 = o33.get(s222)), void 0 === t222 && ((this.o = t222 = new CSSStyleSheet()).replaceSync(this.cssText), e422 && o33.set(s222, t222));
    }
    return t222;
  }
  toString() {
    return this.cssText;
  }
};
var r33 = (t222) => new n43("string" == typeof t222 ? t222 : t222 + "", void 0, s22);
var S32 = (s222, o422) => {
  if (e42) s222.adoptedStyleSheets = o422.map((t222) => t222 instanceof CSSStyleSheet ? t222 : t222.styleSheet);
  else for (const e422 of o422) {
    const o522 = document.createElement("style"), n522 = t32.litNonce;
    void 0 !== n522 && o522.setAttribute("nonce", n522), o522.textContent = e422.cssText, s222.appendChild(o522);
  }
};
var c42 = e42 ? (t222) => t222 : (t222) => t222 instanceof CSSStyleSheet ? ((t322) => {
  let e422 = "";
  for (const s222 of t322.cssRules) e422 += s222.cssText;
  return r33(e422);
})(t222) : t222;
var { is: i222, defineProperty: e222, getOwnPropertyDescriptor: r222, getOwnPropertyNames: h42, getOwnPropertySymbols: o222, getPrototypeOf: n222 } = Object;
var a22 = globalThis;
var c222 = a22.trustedTypes;
var l22 = c222 ? c222.emptyScript : "";
var p22 = a22.reactiveElementPolyfillSupport;
var d22 = (t222, s222) => t222;
var u22 = { toAttribute(t222, s222) {
  switch (s222) {
    case Boolean:
      t222 = t222 ? l22 : null;
      break;
    case Object:
    case Array:
      t222 = null == t222 ? t222 : JSON.stringify(t222);
  }
  return t222;
}, fromAttribute(t222, s222) {
  let i322 = t222;
  switch (s222) {
    case Boolean:
      i322 = null !== t222;
      break;
    case Number:
      i322 = null === t222 ? null : Number(t222);
      break;
    case Object:
    case Array:
      try {
        i322 = JSON.parse(t222);
      } catch (t322) {
        i322 = null;
      }
  }
  return i322;
} };
var f42 = (t222, s222) => !i222(t222, s222);
var y22 = { attribute: true, type: String, converter: u22, reflect: false, hasChanged: f42 };
Symbol.metadata ??= Symbol("metadata"), a22.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b22 = class extends HTMLElement {
  static addInitializer(t222) {
    this._$Ei(), (this.l ??= []).push(t222);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t222, s222 = y22) {
    if (s222.state && (s222.attribute = false), this._$Ei(), this.elementProperties.set(t222, s222), !s222.noAccessor) {
      const i322 = Symbol(), r422 = this.getPropertyDescriptor(t222, i322, s222);
      void 0 !== r422 && e222(this.prototype, t222, r422);
    }
  }
  static getPropertyDescriptor(t222, s222, i322) {
    const { get: e422, set: h422 } = r222(this.prototype, t222) ?? { get() {
      return this[s222];
    }, set(t322) {
      this[s222] = t322;
    } };
    return { get() {
      return e422?.call(this);
    }, set(s33) {
      const r422 = e422?.call(this);
      h422.call(this, s33), this.requestUpdate(t222, r422, i322);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t222) {
    return this.elementProperties.get(t222) ?? y22;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d22("elementProperties"))) return;
    const t222 = n222(this);
    t222.finalize(), void 0 !== t222.l && (this.l = [...t222.l]), this.elementProperties = new Map(t222.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d22("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d22("properties"))) {
      const t322 = this.properties, s222 = [...h42(t322), ...o222(t322)];
      for (const i322 of s222) this.createProperty(i322, t322[i322]);
    }
    const t222 = this[Symbol.metadata];
    if (null !== t222) {
      const s222 = litPropertyMetadata.get(t222);
      if (void 0 !== s222) for (const [t322, i322] of s222) this.elementProperties.set(t322, i322);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t322, s222] of this.elementProperties) {
      const i322 = this._$Eu(t322, s222);
      void 0 !== i322 && this._$Eh.set(i322, t322);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s222) {
    const i322 = [];
    if (Array.isArray(s222)) {
      const e422 = new Set(s222.flat(1 / 0).reverse());
      for (const s33 of e422) i322.unshift(c42(s33));
    } else void 0 !== s222 && i322.push(c42(s222));
    return i322;
  }
  static _$Eu(t222, s222) {
    const i322 = s222.attribute;
    return false === i322 ? void 0 : "string" == typeof i322 ? i322 : "string" == typeof t222 ? t222.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t222) => this.enableUpdating = t222), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t222) => t222(this));
  }
  addController(t222) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t222), void 0 !== this.renderRoot && this.isConnected && t222.hostConnected?.();
  }
  removeController(t222) {
    this._$EO?.delete(t222);
  }
  _$E_() {
    const t222 = /* @__PURE__ */ new Map(), s222 = this.constructor.elementProperties;
    for (const i322 of s222.keys()) this.hasOwnProperty(i322) && (t222.set(i322, this[i322]), delete this[i322]);
    t222.size > 0 && (this._$Ep = t222);
  }
  createRenderRoot() {
    const t222 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S32(t222, this.constructor.elementStyles), t222;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t222) => t222.hostConnected?.());
  }
  enableUpdating(t222) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t222) => t222.hostDisconnected?.());
  }
  attributeChangedCallback(t222, s222, i322) {
    this._$AK(t222, i322);
  }
  _$EC(t222, s222) {
    const i322 = this.constructor.elementProperties.get(t222), e422 = this.constructor._$Eu(t222, i322);
    if (void 0 !== e422 && true === i322.reflect) {
      const r422 = (void 0 !== i322.converter?.toAttribute ? i322.converter : u22).toAttribute(s222, i322.type);
      this._$Em = t222, null == r422 ? this.removeAttribute(e422) : this.setAttribute(e422, r422), this._$Em = null;
    }
  }
  _$AK(t222, s222) {
    const i322 = this.constructor, e422 = i322._$Eh.get(t222);
    if (void 0 !== e422 && this._$Em !== e422) {
      const t322 = i322.getPropertyOptions(e422), r422 = "function" == typeof t322.converter ? { fromAttribute: t322.converter } : void 0 !== t322.converter?.fromAttribute ? t322.converter : u22;
      this._$Em = e422, this[e422] = r422.fromAttribute(s222, t322.type), this._$Em = null;
    }
  }
  requestUpdate(t222, s222, i322) {
    if (void 0 !== t222) {
      if (i322 ??= this.constructor.getPropertyOptions(t222), !(i322.hasChanged ?? f42)(this[t222], s222)) return;
      this.P(t222, s222, i322);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t222, s222, i322) {
    this._$AL.has(t222) || this._$AL.set(t222, s222), true === i322.reflect && this._$Em !== t222 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t222);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t322) {
      Promise.reject(t322);
    }
    const t222 = this.scheduleUpdate();
    return null != t222 && await t222, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t422, s33] of this._$Ep) this[t422] = s33;
        this._$Ep = void 0;
      }
      const t322 = this.constructor.elementProperties;
      if (t322.size > 0) for (const [s33, i322] of t322) true !== i322.wrapped || this._$AL.has(s33) || void 0 === this[s33] || this.P(s33, this[s33], i322);
    }
    let t222 = false;
    const s222 = this._$AL;
    try {
      t222 = this.shouldUpdate(s222), t222 ? (this.willUpdate(s222), this._$EO?.forEach((t322) => t322.hostUpdate?.()), this.update(s222)) : this._$EU();
    } catch (s33) {
      throw t222 = false, this._$EU(), s33;
    }
    t222 && this._$AE(s222);
  }
  willUpdate(t222) {
  }
  _$AE(t222) {
    this._$EO?.forEach((t322) => t322.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t222)), this.updated(t222);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t222) {
    return true;
  }
  update(t222) {
    this._$Ej &&= this._$Ej.forEach((t322) => this._$EC(t322, this[t322])), this._$EU();
  }
  updated(t222) {
  }
  firstUpdated(t222) {
  }
};
b22.elementStyles = [], b22.shadowRootOptions = { mode: "open" }, b22[d22("elementProperties")] = /* @__PURE__ */ new Map(), b22[d22("finalized")] = /* @__PURE__ */ new Map(), p22?.({ ReactiveElement: b22 }), (a22.reactiveElementVersions ??= []).push("2.0.4");
var n322 = globalThis;
var c322 = n322.trustedTypes;
var h222 = c322 ? c322.createPolicy("lit-html", { createHTML: (t222) => t222 }) : void 0;
var f222 = "$lit$";
var v22 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m22 = "?" + v22;
var _22 = `<${m22}>`;
var w22 = document;
var lt22 = () => w22.createComment("");
var st22 = (t222) => null === t222 || "object" != typeof t222 && "function" != typeof t222;
var g22 = Array.isArray;
var $22 = (t222) => g22(t222) || "function" == typeof t222?.[Symbol.iterator];
var x22 = "[ 	\n\f\r]";
var T22 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E22 = /-->/g;
var k22 = />/g;
var O22 = RegExp(`>|${x22}(?:([^\\s"'>=/]+)(${x22}*=${x22}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S222 = /'/g;
var j22 = /"/g;
var M22 = /^(?:script|style|textarea|title)$/i;
var P22 = (t222) => (i322, ...s222) => ({ _$litType$: t222, strings: i322, values: s222 });
var ke22 = P22(1);
var Oe22 = P22(2);
var Se22 = P22(3);
var R22 = Symbol.for("lit-noChange");
var D22 = Symbol.for("lit-nothing");
var V22 = /* @__PURE__ */ new WeakMap();
var I22 = w22.createTreeWalker(w22, 129);
function N22(t222, i322) {
  if (!g22(t222) || !t222.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h222 ? h222.createHTML(i322) : i322;
}
var U22 = (t222, i322) => {
  const s222 = t222.length - 1, e422 = [];
  let h422, o422 = 2 === i322 ? "<svg>" : 3 === i322 ? "<math>" : "", n522 = T22;
  for (let i43 = 0; i43 < s222; i43++) {
    const s33 = t222[i43];
    let r422, l222, c422 = -1, a222 = 0;
    for (; a222 < s33.length && (n522.lastIndex = a222, l222 = n522.exec(s33), null !== l222); ) a222 = n522.lastIndex, n522 === T22 ? "!--" === l222[1] ? n522 = E22 : void 0 !== l222[1] ? n522 = k22 : void 0 !== l222[2] ? (M22.test(l222[2]) && (h422 = RegExp("</" + l222[2], "g")), n522 = O22) : void 0 !== l222[3] && (n522 = O22) : n522 === O22 ? ">" === l222[0] ? (n522 = h422 ?? T22, c422 = -1) : void 0 === l222[1] ? c422 = -2 : (c422 = n522.lastIndex - l222[2].length, r422 = l222[1], n522 = void 0 === l222[3] ? O22 : '"' === l222[3] ? j22 : S222) : n522 === j22 || n522 === S222 ? n522 = O22 : n522 === E22 || n522 === k22 ? n522 = T22 : (n522 = O22, h422 = void 0);
    const u222 = n522 === O22 && t222[i43 + 1].startsWith("/>") ? " " : "";
    o422 += n522 === T22 ? s33 + _22 : c422 >= 0 ? (e422.push(r422), s33.slice(0, c422) + f222 + s33.slice(c422) + v22 + u222) : s33 + v22 + (-2 === c422 ? i43 : u222);
  }
  return [N22(t222, o422 + (t222[s222] || "<?>") + (2 === i322 ? "</svg>" : 3 === i322 ? "</math>" : "")), e422];
};
var B22 = class _B3 {
  constructor({ strings: t222, _$litType$: i322 }, s222) {
    let e422;
    this.parts = [];
    let h422 = 0, o422 = 0;
    const n522 = t222.length - 1, r422 = this.parts, [l222, a222] = U22(t222, i322);
    if (this.el = _B3.createElement(l222, s222), I22.currentNode = this.el.content, 2 === i322 || 3 === i322) {
      const t322 = this.el.content.firstChild;
      t322.replaceWith(...t322.childNodes);
    }
    for (; null !== (e422 = I22.nextNode()) && r422.length < n522; ) {
      if (1 === e422.nodeType) {
        if (e422.hasAttributes()) for (const t322 of e422.getAttributeNames()) if (t322.endsWith(f222)) {
          const i43 = a222[o422++], s33 = e422.getAttribute(t322).split(v22), n63 = /([.?@])?(.*)/.exec(i43);
          r422.push({ type: 1, index: h422, name: n63[2], strings: s33, ctor: "." === n63[1] ? Y22 : "?" === n63[1] ? Z22 : "@" === n63[1] ? q22 : G22 }), e422.removeAttribute(t322);
        } else t322.startsWith(v22) && (r422.push({ type: 6, index: h422 }), e422.removeAttribute(t322));
        if (M22.test(e422.tagName)) {
          const t322 = e422.textContent.split(v22), i43 = t322.length - 1;
          if (i43 > 0) {
            e422.textContent = c322 ? c322.emptyScript : "";
            for (let s33 = 0; s33 < i43; s33++) e422.append(t322[s33], lt22()), I22.nextNode(), r422.push({ type: 2, index: ++h422 });
            e422.append(t322[i43], lt22());
          }
        }
      } else if (8 === e422.nodeType) if (e422.data === m22) r422.push({ type: 2, index: h422 });
      else {
        let t322 = -1;
        for (; -1 !== (t322 = e422.data.indexOf(v22, t322 + 1)); ) r422.push({ type: 7, index: h422 }), t322 += v22.length - 1;
      }
      h422++;
    }
  }
  static createElement(t222, i322) {
    const s222 = w22.createElement("template");
    return s222.innerHTML = t222, s222;
  }
};
function z22(t222, i322, s222 = t222, e422) {
  if (i322 === R22) return i322;
  let h422 = void 0 !== e422 ? s222.o?.[e422] : s222.l;
  const o422 = st22(i322) ? void 0 : i322._$litDirective$;
  return h422?.constructor !== o422 && (h422?._$AO?.(false), void 0 === o422 ? h422 = void 0 : (h422 = new o422(t222), h422._$AT(t222, s222, e422)), void 0 !== e422 ? (s222.o ??= [])[e422] = h422 : s222.l = h422), void 0 !== h422 && (i322 = z22(t222, h422._$AS(t222, i322.values), h422, e422)), i322;
}
var F22 = class {
  constructor(t222, i322) {
    this._$AV = [], this._$AN = void 0, this._$AD = t222, this._$AM = i322;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t222) {
    const { el: { content: i322 }, parts: s222 } = this._$AD, e422 = (t222?.creationScope ?? w22).importNode(i322, true);
    I22.currentNode = e422;
    let h422 = I22.nextNode(), o422 = 0, n522 = 0, r422 = s222[0];
    for (; void 0 !== r422; ) {
      if (o422 === r422.index) {
        let i43;
        2 === r422.type ? i43 = new et22(h422, h422.nextSibling, this, t222) : 1 === r422.type ? i43 = new r422.ctor(h422, r422.name, r422.strings, this, t222) : 6 === r422.type && (i43 = new K22(h422, this, t222)), this._$AV.push(i43), r422 = s222[++n522];
      }
      o422 !== r422?.index && (h422 = I22.nextNode(), o422++);
    }
    return I22.currentNode = w22, e422;
  }
  p(t222) {
    let i322 = 0;
    for (const s222 of this._$AV) void 0 !== s222 && (void 0 !== s222.strings ? (s222._$AI(t222, s222, i322), i322 += s222.strings.length - 2) : s222._$AI(t222[i322])), i322++;
  }
};
var et22 = class _et3 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t222, i322, s222, e422) {
    this.type = 2, this._$AH = D22, this._$AN = void 0, this._$AA = t222, this._$AB = i322, this._$AM = s222, this.options = e422, this.v = e422?.isConnected ?? true;
  }
  get parentNode() {
    let t222 = this._$AA.parentNode;
    const i322 = this._$AM;
    return void 0 !== i322 && 11 === t222?.nodeType && (t222 = i322.parentNode), t222;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t222, i322 = this) {
    t222 = z22(this, t222, i322), st22(t222) ? t222 === D22 || null == t222 || "" === t222 ? (this._$AH !== D22 && this._$AR(), this._$AH = D22) : t222 !== this._$AH && t222 !== R22 && this._(t222) : void 0 !== t222._$litType$ ? this.$(t222) : void 0 !== t222.nodeType ? this.T(t222) : $22(t222) ? this.k(t222) : this._(t222);
  }
  O(t222) {
    return this._$AA.parentNode.insertBefore(t222, this._$AB);
  }
  T(t222) {
    this._$AH !== t222 && (this._$AR(), this._$AH = this.O(t222));
  }
  _(t222) {
    this._$AH !== D22 && st22(this._$AH) ? this._$AA.nextSibling.data = t222 : this.T(w22.createTextNode(t222)), this._$AH = t222;
  }
  $(t222) {
    const { values: i322, _$litType$: s222 } = t222, e422 = "number" == typeof s222 ? this._$AC(t222) : (void 0 === s222.el && (s222.el = B22.createElement(N22(s222.h, s222.h[0]), this.options)), s222);
    if (this._$AH?._$AD === e422) this._$AH.p(i322);
    else {
      const t322 = new F22(e422, this), s33 = t322.u(this.options);
      t322.p(i322), this.T(s33), this._$AH = t322;
    }
  }
  _$AC(t222) {
    let i322 = V22.get(t222.strings);
    return void 0 === i322 && V22.set(t222.strings, i322 = new B22(t222)), i322;
  }
  k(t222) {
    g22(this._$AH) || (this._$AH = [], this._$AR());
    const i322 = this._$AH;
    let s222, e422 = 0;
    for (const h422 of t222) e422 === i322.length ? i322.push(s222 = new _et3(this.O(lt22()), this.O(lt22()), this, this.options)) : s222 = i322[e422], s222._$AI(h422), e422++;
    e422 < i322.length && (this._$AR(s222 && s222._$AB.nextSibling, e422), i322.length = e422);
  }
  _$AR(t222 = this._$AA.nextSibling, i322) {
    for (this._$AP?.(false, true, i322); t222 && t222 !== this._$AB; ) {
      const i43 = t222.nextSibling;
      t222.remove(), t222 = i43;
    }
  }
  setConnected(t222) {
    void 0 === this._$AM && (this.v = t222, this._$AP?.(t222));
  }
};
var G22 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t222, i322, s222, e422, h422) {
    this.type = 1, this._$AH = D22, this._$AN = void 0, this.element = t222, this.name = i322, this._$AM = e422, this.options = h422, s222.length > 2 || "" !== s222[0] || "" !== s222[1] ? (this._$AH = Array(s222.length - 1).fill(new String()), this.strings = s222) : this._$AH = D22;
  }
  _$AI(t222, i322 = this, s222, e422) {
    const h422 = this.strings;
    let o422 = false;
    if (void 0 === h422) t222 = z22(this, t222, i322, 0), o422 = !st22(t222) || t222 !== this._$AH && t222 !== R22, o422 && (this._$AH = t222);
    else {
      const e522 = t222;
      let n522, r422;
      for (t222 = h422[0], n522 = 0; n522 < h422.length - 1; n522++) r422 = z22(this, e522[s222 + n522], i322, n522), r422 === R22 && (r422 = this._$AH[n522]), o422 ||= !st22(r422) || r422 !== this._$AH[n522], r422 === D22 ? t222 = D22 : t222 !== D22 && (t222 += (r422 ?? "") + h422[n522 + 1]), this._$AH[n522] = r422;
    }
    o422 && !e422 && this.j(t222);
  }
  j(t222) {
    t222 === D22 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t222 ?? "");
  }
};
var Y22 = class extends G22 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t222) {
    this.element[this.name] = t222 === D22 ? void 0 : t222;
  }
};
var Z22 = class extends G22 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t222) {
    this.element.toggleAttribute(this.name, !!t222 && t222 !== D22);
  }
};
var q22 = class extends G22 {
  constructor(t222, i322, s222, e422, h422) {
    super(t222, i322, s222, e422, h422), this.type = 5;
  }
  _$AI(t222, i322 = this) {
    if ((t222 = z22(this, t222, i322, 0) ?? D22) === R22) return;
    const s222 = this._$AH, e422 = t222 === D22 && s222 !== D22 || t222.capture !== s222.capture || t222.once !== s222.once || t222.passive !== s222.passive, h422 = t222 !== D22 && (s222 === D22 || e422);
    e422 && this.element.removeEventListener(this.name, this, s222), h422 && this.element.addEventListener(this.name, this, t222), this._$AH = t222;
  }
  handleEvent(t222) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t222) : this._$AH.handleEvent(t222);
  }
};
var K22 = class {
  constructor(t222, i322, s222) {
    this.element = t222, this.type = 6, this._$AN = void 0, this._$AM = i322, this.options = s222;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t222) {
    z22(this, t222);
  }
};
var Re22 = n322.litHtmlPolyfillSupport;
Re22?.(B22, et22), (n322.litHtmlVersions ??= []).push("3.2.0");
var Q22 = (t222, i322, s222) => {
  const e422 = s222?.renderBefore ?? i322;
  let h422 = e422._$litPart$;
  if (void 0 === h422) {
    const t322 = s222?.renderBefore ?? null;
    e422._$litPart$ = h422 = new et22(i322.insertBefore(lt22(), t322), t322, void 0, s222 ?? {});
  }
  return h422._$AI(t222), h422;
};
var h322 = class extends b22 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t222 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t222.firstChild, t222;
  }
  update(t222) {
    const e422 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t222), this.o = Q22(e422, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R22;
  }
};
h322._$litElement$ = true, h322["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h322 });
var f322 = globalThis.litElementPolyfillSupport;
f322?.({ LitElement: h322 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o322 = { attribute: true, type: String, converter: u22, reflect: false, hasChanged: f42 };
var r322 = (t222 = o322, e422, r422) => {
  const { kind: n522, metadata: i322 } = r422;
  let s222 = globalThis.litPropertyMetadata.get(i322);
  if (void 0 === s222 && globalThis.litPropertyMetadata.set(i322, s222 = /* @__PURE__ */ new Map()), s222.set(r422.name, t222), "accessor" === n522) {
    const { name: o422 } = r422;
    return { set(r522) {
      const n63 = e422.get.call(this);
      e422.set.call(this, r522), this.requestUpdate(o422, n63, t222);
    }, init(e522) {
      return void 0 !== e522 && this.P(o422, void 0, t222), e522;
    } };
  }
  if ("setter" === n522) {
    const { name: o422 } = r422;
    return function(r522) {
      const n63 = this[o422];
      e422.call(this, r522), this.requestUpdate(o422, n63, t222);
    };
  }
  throw Error("Unsupported decorator location: " + n522);
};
function n422(t222) {
  return (e422, o422) => "object" == typeof o422 ? r322(t222, e422, o422) : ((t322, e522, o522) => {
    const r422 = e522.hasOwnProperty(o522);
    return e522.constructor.createProperty(o522, r422 ? { ...t322, wrapped: true } : t322), r422 ? Object.getOwnPropertyDescriptor(e522, o522) : void 0;
  })(t222, e422, o422);
}
var appliedClassMixins2 = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied2(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins2.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin2(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied2(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins2.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version2 = "3.0.0";
var versions2 = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions2.includes(version2)) {
  versions2.push(version2);
}
var ScopedElementsMixinImplementation3 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version2;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry22) {
      this.constructor.__registry = registry22;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin3 = dedupeMixin2(ScopedElementsMixinImplementation3);
var ScopedElementsMixinImplementation22 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin3(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S32(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin22 = dedupeMixin2(ScopedElementsMixinImplementation22);
var _lang_dec2;
var _contentEditable_dec2;
var _a3;
var _init3;
var _contentEditable2;
var _lang2;
var LitElementWw2 = class extends (_a3 = ScopedElementsMixin22(h322), _contentEditable_dec2 = [n422({ type: String, attribute: true, reflect: true })], _lang_dec2 = [n422({ type: String, attribute: true, reflect: true })], _a3) {
  constructor() {
    super(...arguments);
    __publicField22(this, "options");
    __publicField22(this, "actions", {});
    __privateAdd22(this, _contentEditable2, __runInitializers22(_init3, 8, this)), __runInitializers22(_init3, 11, this);
    __privateAdd22(this, _lang2, __runInitializers22(_init3, 12, this)), __runInitializers22(_init3, 15, this);
    __publicField22(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k222) => this.setAttribute(k222, this.getAttribute(k222)));
  }
};
_init3 = __decoratorStart22(_a3);
_contentEditable2 = /* @__PURE__ */ new WeakMap();
_lang2 = /* @__PURE__ */ new WeakMap();
__decorateElement22(_init3, 4, "contentEditable", _contentEditable_dec2, LitElementWw2, _contentEditable2);
__decorateElement22(_init3, 4, "lang", _lang_dec2, LitElementWw2, _lang2);
__decoratorMetadata22(_init3, LitElementWw2);
__publicField22(LitElementWw2, "shadowRootOptions", { ...h322.shadowRootOptions });
__publicField22(LitElementWw2, "options", {});
__publicField22(LitElementWw2, "actions", {});
var t42 = (t73) => (e73, o73) => {
  void 0 !== o73 ? o73.addInitializer(() => {
    customElements.define(t73, e73);
  }) : customElements.define(t73, e73);
};
var o42 = { attribute: true, type: String, converter: u3, reflect: false, hasChanged: f5 };
var r42 = (t73 = o42, e73, r73) => {
  const { kind: n63, metadata: i43 } = r73;
  let s33 = globalThis.litPropertyMetadata.get(i43);
  if (void 0 === s33 && globalThis.litPropertyMetadata.set(i43, s33 = /* @__PURE__ */ new Map()), s33.set(r73.name, t73), "accessor" === n63) {
    const { name: o73 } = r73;
    return { set(r83) {
      const n73 = e73.get.call(this);
      e73.set.call(this, r83), this.requestUpdate(o73, n73, t73);
    }, init(e83) {
      return void 0 !== e83 && this.P(o73, void 0, t73), e83;
    } };
  }
  if ("setter" === n63) {
    const { name: o73 } = r73;
    return function(r83) {
      const n73 = this[o73];
      e73.call(this, r83), this.requestUpdate(o73, n73, t73);
    };
  }
  throw Error("Unsupported decorator location: " + n63);
};
function n52(t73) {
  return (e73, o73) => "object" == typeof o73 ? r42(t73, e73, o73) : ((t83, e83, o83) => {
    const r73 = e83.hasOwnProperty(o83);
    return e83.constructor.createProperty(o83, r73 ? { ...t83, wrapped: true } : t83), r73 ? Object.getOwnPropertyDescriptor(e83, o83) : void 0;
  })(t73, e73, o73);
}
function r52(r73) {
  return n52({ ...r73, state: true, attribute: false });
}
function t52(t73) {
  return (n63, o73) => {
    const c53 = "function" == typeof n63 ? n63 : n63[o73];
    Object.assign(c53, t73);
  };
}
var e52 = (e73, t73, c53) => (c53.configurable = true, c53.enumerable = true, Reflect.decorate && "object" != typeof t73 && Object.defineProperty(e73, t73, c53), c53);
function e62(e73, r73) {
  return (n63, s33, i43) => {
    const o73 = (t73) => t73.renderRoot?.querySelector(e73) ?? null;
    if (r73) {
      const { get: e83, set: r83 } = "object" == typeof s33 ? n63 : i43 ?? (() => {
        const t73 = Symbol();
        return { get() {
          return this[t73];
        }, set(e93) {
          this[t73] = e93;
        } };
      })();
      return e52(n63, s33, { get() {
        let t73 = e83.call(this);
        return void 0 === t73 && (t73 = o73(this), (null !== t73 || this.hasUpdated) && r83.call(this, t73)), t73;
      } });
    }
    return e52(n63, s33, { get() {
      return o73(this);
    } });
  };
}
function o52(o73) {
  return (e73, n63) => {
    const { slot: r73, selector: s33 } = o73 ?? {}, c53 = "slot" + (r73 ? `[name=${r73}]` : ":not([name])");
    return e52(e73, n63, { get() {
      const t73 = this.renderRoot?.querySelector(c53), e83 = t73?.assignedElements(o73) ?? [];
      return void 0 === s33 ? e83 : e83.filter((t83) => t83.matches(s33));
    } });
  };
}
var icon_button_styles_default = i4`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;
var basePath2 = "";
function setBasePath2(path) {
  basePath2 = path;
}
function getBasePath2(subpath = "") {
  if (!basePath2) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath2(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s33) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s33.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s33.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath2(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath2.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}
var library2 = {
  name: "default",
  resolver: (name) => getBasePath2(`assets/icons/${name}.svg`)
};
var library_default_default2 = library2;
var icons2 = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary2 = {
  name: "system",
  resolver: (name) => {
    if (name in icons2) {
      return `data:image/svg+xml,${encodeURIComponent(icons2[name])}`;
    }
    return "";
  }
};
var library_system_default2 = systemLibrary2;
var registry2 = [library_default_default2, library_system_default2];
var watchedIcons2 = [];
function watchIcon2(icon) {
  watchedIcons2.push(icon);
}
function unwatchIcon2(icon) {
  watchedIcons2 = watchedIcons2.filter((el) => el !== icon);
}
function getIconLibrary2(name) {
  return registry2.find((lib) => lib.name === name);
}
var icon_styles_default2 = i4`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
var __defProp32 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc32 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp32 = (obj, key, value) => key in obj ? __defProp32(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a33, b33) => {
  for (var prop in b33 || (b33 = {}))
    if (__hasOwnProp2.call(b33, prop))
      __defNormalProp32(a33, prop, b33[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b33)) {
      if (__propIsEnum2.call(b33, prop))
        __defNormalProp32(a33, prop, b33[prop]);
    }
  return a33;
};
var __spreadProps2 = (a33, b33) => __defProps2(a33, __getOwnPropDescs2(b33));
var __decorateClass2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc32(target, key) : target;
  for (var i43 = decorators.length - 1, decorator; i43 >= 0; i43--)
    if (decorator = decorators[i43])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp32(target, key, result);
  return result;
};
var __accessCheck32 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet32 = (obj, member, getter) => {
  __accessCheck32(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd32 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet32 = (obj, member, value, setter) => {
  __accessCheck32(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
function watch2(propertyName, options) {
  const resolvedOptions = __spreadValues2({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update22 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update22.call(this, changedProps);
    };
  };
}
var component_styles_default2 = i4`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
var _hasRecordedInitialProperties2;
var ShoelaceElement2 = class extends h33 {
  constructor() {
    super();
    __privateAdd32(this, _hasRecordedInitialProperties2, false);
    this.initialReflectedProperties = /* @__PURE__ */ new Map();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues2({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      try {
        customElements.define(name, elementConstructor, options);
      } catch (_err) {
        customElements.define(name, class extends elementConstructor {
        }, options);
      }
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (!__privateGet32(this, _hasRecordedInitialProperties2)) {
      this.constructor.elementProperties.forEach(
        (obj, prop) => {
          if (obj.reflect && this[prop] != null) {
            this.initialReflectedProperties.set(prop, this[prop]);
          }
        }
      );
      __privateSet32(this, _hasRecordedInitialProperties2, true);
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    this.initialReflectedProperties.forEach((value, prop) => {
      if (changedProperties.has(prop) && this[prop] == null) {
        this[prop] = value;
      }
    });
  }
};
_hasRecordedInitialProperties2 = /* @__PURE__ */ new WeakMap();
ShoelaceElement2.version = "2.17.1";
ShoelaceElement2.dependencies = {};
__decorateClass2([
  n52()
], ShoelaceElement2.prototype, "dir", 2);
__decorateClass2([
  n52()
], ShoelaceElement2.prototype, "lang", 2);
var { I: et32 } = si2;
var nt2 = (o73, t73) => void 0 === t73 ? void 0 !== o73?._$litType$ : o73?._$litType$ === t73;
var CACHEABLE_ERROR2 = Symbol();
var RETRYABLE_ERROR2 = Symbol();
var parser2;
var iconCache2 = /* @__PURE__ */ new Map();
var SlIcon2 = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library22) {
    var _a33;
    let fileData;
    if (library22 == null ? void 0 : library22.spriteSheet) {
      this.svg = ke4`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR2 : RETRYABLE_ERROR2;
    } catch (e73) {
      return RETRYABLE_ERROR2;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a33 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a33.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR2;
      if (!parser2)
        parser2 = new DOMParser();
      const doc = parser2.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR2;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e73) {
      return CACHEABLE_ERROR2;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon2(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon2(this);
  }
  getIconSource() {
    const library22 = getIconLibrary2(this.library);
    if (this.name && library22) {
      return {
        url: library22.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a33;
    const { url, fromLibrary } = this.getIconSource();
    const library22 = fromLibrary ? getIconLibrary2(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache2.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library22);
      iconCache2.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR2) {
      iconCache2.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt2(svg)) {
      this.svg = svg;
      if (library22) {
        await this.updateComplete;
        const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library22.mutator === "function" && shadowSVG) {
          library22.mutator(shadowSVG);
        }
      }
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR2:
      case CACHEABLE_ERROR2:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a33 = library22 == null ? void 0 : library22.mutator) == null ? void 0 : _a33.call(library22, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon2.styles = [component_styles_default2, icon_styles_default2];
__decorateClass2([
  r52()
], SlIcon2.prototype, "svg", 2);
__decorateClass2([
  n52({ reflect: true })
], SlIcon2.prototype, "name", 2);
__decorateClass2([
  n52()
], SlIcon2.prototype, "src", 2);
__decorateClass2([
  n52()
], SlIcon2.prototype, "label", 2);
__decorateClass2([
  n52({ reflect: true })
], SlIcon2.prototype, "library", 2);
__decorateClass2([
  watch2("label")
], SlIcon2.prototype, "handleLabelChange", 1);
__decorateClass2([
  watch2(["name", "src", "library"])
], SlIcon2.prototype, "setIcon", 1);
var Rt2 = e32(class extends i32 {
  constructor(s33) {
    if (super(s33), s33.type !== t22.ATTRIBUTE || "class" !== s33.name || s33.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t73) {
    return " " + Object.keys(t73).filter((s33) => t73[s33]).join(" ") + " ";
  }
  update(t73, [s33]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t73.strings && (this.nt = new Set(t73.strings.join(" ").split(/\s/).filter((t83) => "" !== t83)));
      for (const t83 in s33) s33[t83] && !this.nt?.has(t83) && this.st.add(t83);
      return this.render(s33);
    }
    const i43 = t73.element.classList;
    for (const t83 of this.st) t83 in s33 || (i43.remove(t83), this.st.delete(t83));
    for (const t83 in s33) {
      const r73 = !!s33[t83];
      r73 === this.st.has(t83) || this.nt?.has(t83) || (r73 ? (i43.add(t83), this.st.add(t83)) : (i43.remove(t83), this.st.delete(t83)));
    }
    return R3;
  }
});
var $e2 = Symbol.for("");
var xe2 = (t73) => {
  if (t73?.r === $e2) return t73?._$litStatic$;
};
var er2 = (t73, ...r73) => ({ _$litStatic$: r73.reduce((r83, e73, a33) => r83 + ((t83) => {
  if (void 0 !== t83._$litStatic$) return t83._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t83}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e73) + t73[a33 + 1], t73[0]), r: $e2 });
var Te2 = /* @__PURE__ */ new Map();
var Ee2 = (t73) => (r73, ...e73) => {
  const a33 = e73.length;
  let o73, s33;
  const i43 = [], l33 = [];
  let n63, u33 = 0, c53 = false;
  for (; u33 < a33; ) {
    for (n63 = r73[u33]; u33 < a33 && void 0 !== (s33 = e73[u33], o73 = xe2(s33)); ) n63 += o73 + r73[++u33], c53 = true;
    u33 !== a33 && l33.push(s33), i43.push(n63), u33++;
  }
  if (u33 === a33 && i43.push(r73[a33]), c53) {
    const t83 = i43.join("$$lit$$");
    void 0 === (r73 = Te2.get(t83)) && (i43.raw = i43, Te2.set(t83, r73 = i43)), e73 = l33;
  }
  return t73(r73, ...e73);
};
var ke32 = Ee2(ke4);
var Oe32 = Ee2(Oe4);
var Se32 = Ee2(Se4);
var to2 = (t73) => t73 ?? D3;
var SlIconButton = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? er2`a` : er2`button`;
    return ke32`
      <${tag}
        part="base"
        class=${Rt2({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${to2(isLink ? void 0 : this.disabled)}
        type=${to2(isLink ? void 0 : "button")}
        href=${to2(isLink ? this.href : void 0)}
        target=${to2(isLink ? this.target : void 0)}
        download=${to2(isLink ? this.download : void 0)}
        rel=${to2(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${to2(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${to2(this.name)}
          library=${to2(this.library)}
          src=${to2(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default2, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon2 };
__decorateClass2([
  e62(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass2([
  r52()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "name", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "library", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "src", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "href", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "target", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "download", 2);
__decorateClass2([
  n52()
], SlIconButton.prototype, "label", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);
var spinner_styles_default2 = i4`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;
var connectedElements2 = /* @__PURE__ */ new Set();
var documentElementObserver2 = new MutationObserver(update2);
var translations2 = /* @__PURE__ */ new Map();
var documentDirection2 = document.documentElement.dir || "ltr";
var documentLanguage2 = document.documentElement.lang || navigator.language;
var fallback2;
documentElementObserver2.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation2(...translation22) {
  translation22.map((t73) => {
    const code = t73.$code.toLowerCase();
    if (translations2.has(code)) {
      translations2.set(code, Object.assign(Object.assign({}, translations2.get(code)), t73));
    } else {
      translations2.set(code, t73);
    }
    if (!fallback2) {
      fallback2 = t73;
    }
  });
  update2();
}
function update2() {
  documentDirection2 = document.documentElement.dir || "ltr";
  documentLanguage2 = document.documentElement.lang || navigator.language;
  [...connectedElements2.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController3 = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements2.add(this.host);
  }
  hostDisconnected() {
    connectedElements2.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection2}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage2}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a33, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a33 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a33 === void 0 ? void 0 : _a33.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations2.get(`${language}-${region}`);
    const secondary = translations2.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a33;
    const { primary, secondary } = this.getTranslationData((_a33 = options.lang) !== null && _a33 !== void 0 ? _a33 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback2 && fallback2[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback2 && fallback2[key]) {
      term = fallback2[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};
var translation2 = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation2(translation2);
var en_default2 = translation2;
var LocalizeController22 = class extends LocalizeController3 {
};
registerTranslation2(en_default2);
var SlSpinner2 = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController22(this);
  }
  render() {
    return ke4`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner2.styles = [component_styles_default2, spinner_styles_default2];
var formCollections2 = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads2 = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads2 = /* @__PURE__ */ new WeakMap();
var userInteractedControls2 = /* @__PURE__ */ new WeakSet();
var interactions2 = /* @__PURE__ */ new WeakMap();
var FormControlController2 = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a33;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a33 = formCollections2.get(this.form)) == null ? void 0 : _a33.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions2.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions2.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues2({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a33;
        return (_a33 = input.disabled) != null ? _a33 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions2.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions2.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections2.has(this.form)) {
        formCollections2.get(this.form).add(this.host);
      } else {
        formCollections2.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads2.has(this.form)) {
        reportValidityOverloads2.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads2.has(this.form)) {
        checkValidityOverloads2.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections2.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads2.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads2.get(this.form);
        reportValidityOverloads2.delete(this.form);
      }
      if (checkValidityOverloads2.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads2.get(this.form);
        checkValidityOverloads2.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls2.add(el);
    } else {
      userInteractedControls2.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a33;
    return (_a33 = this.form) != null ? _a33 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls2.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState2 = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState2 = Object.freeze(__spreadProps2(__spreadValues2({}, validValidityState2), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState2 = Object.freeze(__spreadProps2(__spreadValues2({}, validValidityState2), {
  valid: false,
  customError: true
}));
var button_styles_default2 = i4`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`;
var HasSlotController2 = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
var SlButton2 = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController2(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController2(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController22(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState2;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? er2`a` : er2`button`;
    return ke32`
      <${tag}
        part="base"
        class=${Rt2({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to2(isLink ? void 0 : this.disabled)}
        type=${to2(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to2(isLink ? void 0 : this.name)}
        value=${to2(isLink ? void 0 : this.value)}
        href=${to2(isLink && !this.disabled ? this.href : void 0)}
        target=${to2(isLink ? this.target : void 0)}
        download=${to2(isLink ? this.download : void 0)}
        rel=${to2(isLink ? this.rel : void 0)}
        role=${to2(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke32` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke32`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton2.styles = [component_styles_default2, button_styles_default2];
SlButton2.dependencies = {
  "sl-icon": SlIcon2,
  "sl-spinner": SlSpinner2
};
__decorateClass2([
  e62(".button")
], SlButton2.prototype, "button", 2);
__decorateClass2([
  r52()
], SlButton2.prototype, "hasFocus", 2);
__decorateClass2([
  r52()
], SlButton2.prototype, "invalid", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "title", 2);
__decorateClass2([
  n52({ reflect: true })
], SlButton2.prototype, "variant", 2);
__decorateClass2([
  n52({ reflect: true })
], SlButton2.prototype, "size", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlButton2.prototype, "caret", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlButton2.prototype, "disabled", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlButton2.prototype, "loading", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlButton2.prototype, "outline", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlButton2.prototype, "pill", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlButton2.prototype, "circle", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "type", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "name", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "value", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "href", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "target", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "rel", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "download", 2);
__decorateClass2([
  n52()
], SlButton2.prototype, "form", 2);
__decorateClass2([
  n52({ attribute: "formaction" })
], SlButton2.prototype, "formAction", 2);
__decorateClass2([
  n52({ attribute: "formenctype" })
], SlButton2.prototype, "formEnctype", 2);
__decorateClass2([
  n52({ attribute: "formmethod" })
], SlButton2.prototype, "formMethod", 2);
__decorateClass2([
  n52({ attribute: "formnovalidate", type: Boolean })
], SlButton2.prototype, "formNoValidate", 2);
__decorateClass2([
  n52({ attribute: "formtarget" })
], SlButton2.prototype, "formTarget", 2);
__decorateClass2([
  watch2("disabled", { waitUntilFirstUpdate: true })
], SlButton2.prototype, "handleDisabledChange", 1);
var details_styles_default = i4`
  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`;
var defaultAnimationRegistry2 = /* @__PURE__ */ new Map();
var customAnimationRegistry2 = /* @__PURE__ */ new WeakMap();
function ensureAnimation2(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation2(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation2(animationName, animation) {
  defaultAnimationRegistry2.set(animationName, ensureAnimation2(animation));
}
function getAnimation2(el, animationName, options) {
  const customAnimation = customAnimationRegistry2.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation2(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry2.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation2(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}
function waitForEvent2(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}
function animateTo2(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps2(__spreadValues2({}, options), {
      duration: prefersReducedMotion2() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion2() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations2(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}
function shimKeyframesHeightAuto(keyframes, calculatedHeight) {
  return keyframes.map((keyframe) => __spreadProps2(__spreadValues2({}, keyframe), {
    height: keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height
  }));
}
var SlDetails = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController22(this);
    this.open = false;
    this.disabled = false;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0";
    if (this.open) {
      this.details.open = true;
    }
    this.detailsObserver = new MutationObserver((changes) => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName === "open") {
          if (this.details.open) {
            this.show();
          } else {
            this.hide();
          }
        }
      }
    });
    this.detailsObserver.observe(this.details, { attributes: true });
  }
  disconnectedCallback() {
    var _a33;
    super.disconnectedCallback();
    (_a33 = this.detailsObserver) == null ? void 0 : _a33.disconnect();
  }
  handleSummaryClick(event) {
    event.preventDefault();
    if (!this.disabled) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
      this.header.focus();
    }
  }
  handleSummaryKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
    if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
      event.preventDefault();
      this.hide();
    }
    if (event.key === "ArrowDown" || event.key === "ArrowRight") {
      event.preventDefault();
      this.show();
    }
  }
  async handleOpenChange() {
    if (this.open) {
      this.details.open = true;
      const slShow = this.emit("sl-show", { cancelable: true });
      if (slShow.defaultPrevented) {
        this.open = false;
        this.details.open = false;
        return;
      }
      await stopAnimations2(this.body);
      const { keyframes, options } = getAnimation2(this, "details.show", { dir: this.localize.dir() });
      await animateTo2(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.emit("sl-after-show");
    } else {
      const slHide = this.emit("sl-hide", { cancelable: true });
      if (slHide.defaultPrevented) {
        this.details.open = true;
        this.open = true;
        return;
      }
      await stopAnimations2(this.body);
      const { keyframes, options } = getAnimation2(this, "details.hide", { dir: this.localize.dir() });
      await animateTo2(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.details.open = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (this.open || this.disabled) {
      return void 0;
    }
    this.open = true;
    return waitForEvent2(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!this.open || this.disabled) {
      return void 0;
    }
    this.open = false;
    return waitForEvent2(this, "sl-after-hide");
  }
  render() {
    const isRtl = this.matches(":dir(rtl)");
    return ke4`
      <details
        part="base"
        class=${Rt2({
      details: true,
      "details--open": this.open,
      "details--disabled": this.disabled,
      "details--rtl": isRtl
    })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails.styles = [component_styles_default2, details_styles_default];
SlDetails.dependencies = {
  "sl-icon": SlIcon2
};
__decorateClass2([
  e62(".details")
], SlDetails.prototype, "details", 2);
__decorateClass2([
  e62(".details__header")
], SlDetails.prototype, "header", 2);
__decorateClass2([
  e62(".details__body")
], SlDetails.prototype, "body", 2);
__decorateClass2([
  e62(".details__expand-icon-slot")
], SlDetails.prototype, "expandIconSlot", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlDetails.prototype, "open", 2);
__decorateClass2([
  n52()
], SlDetails.prototype, "summary", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlDetails.prototype, "disabled", 2);
__decorateClass2([
  watch2("open", { waitUntilFirstUpdate: true })
], SlDetails.prototype, "handleOpenChange", 1);
setDefaultAnimation2("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" }
  ],
  options: { duration: 250, easing: "linear" }
});
setDefaultAnimation2("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" }
  ],
  options: { duration: 250, easing: "linear" }
});
var popup_styles_default2 = i4`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords2 = (v33) => ({
  x: v33,
  y: v33
});
var oppositeSideMap2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap2 = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate2(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide2(placement) {
  return placement.split("-")[0];
}
function getAlignment2(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis2(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength2(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis2(placement) {
  return ["top", "bottom"].includes(getSide2(placement)) ? "y" : "x";
}
function getAlignmentAxis2(placement) {
  return getOppositeAxis2(getSideAxis2(placement));
}
function getAlignmentSides2(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment2(placement);
  const alignmentAxis = getAlignmentAxis2(placement);
  const length = getAxisLength2(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement2(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement2(mainAlignmentSide)];
}
function getExpandedPlacements2(placement) {
  const oppositePlacement = getOppositePlacement2(placement);
  return [getOppositeAlignmentPlacement2(placement), oppositePlacement, getOppositeAlignmentPlacement2(oppositePlacement)];
}
function getOppositeAlignmentPlacement2(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap2[alignment]);
}
function getSideList2(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements2(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment2(placement);
  let list = getSideList2(getSide2(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement2));
    }
  }
  return list;
}
function getOppositePlacement2(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap2[side]);
}
function expandPaddingObject2(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject2(padding) {
  return typeof padding !== "number" ? expandPaddingObject2(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect2(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement2(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis2(placement);
  const alignmentAxis = getAlignmentAxis2(placement);
  const alignLength = getAxisLength2(alignmentAxis);
  const side = getSide2(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment2(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition3 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform22
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(floating));
  let rects = await platform22.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x32,
    y: y33
  } = computeCoordsFromPlacement2(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i43 = 0; i43 < validMiddleware.length; i43++) {
    const {
      name,
      fn
    } = validMiddleware[i43];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x32,
      y: y33,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform22,
      elements: {
        reference,
        floating
      }
    });
    x32 = nextX != null ? nextX : x32;
    y33 = nextY != null ? nextY : y33;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform22.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x32,
          y: y33
        } = computeCoordsFromPlacement2(rects, statefulPlacement, rtl));
      }
      i43 = -1;
      continue;
    }
  }
  return {
    x: x32,
    y: y33,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow2(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x32,
    y: y33,
    platform: platform22,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate2(options, state);
  const paddingObject = getPaddingObject2(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect2(await platform22.getClippingRect({
    element: ((_await$platform$isEle = await (platform22.isElement == null ? void 0 : platform22.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform22.getDocumentElement == null ? void 0 : platform22.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x32,
    y: y33
  } : rects.reference;
  const offsetParent = await (platform22.getOffsetParent == null ? void 0 : platform22.getOffsetParent(elements.floating));
  const offsetScale = await (platform22.isElement == null ? void 0 : platform22.isElement(offsetParent)) ? await (platform22.getScale == null ? void 0 : platform22.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect2(platform22.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform22.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow2 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x32,
      y: y33,
      placement,
      rects,
      platform: platform22,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate2(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject2(padding);
    const coords = {
      x: x32,
      y: y33
    };
    const axis = getAlignmentAxis2(placement);
    const length = getAxisLength2(axis);
    const arrowDimensions = await platform22.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform22.getOffsetParent == null ? void 0 : platform22.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform22.isElement == null ? void 0 : platform22.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max22 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset22 = clamp2(min$1, center, max22);
    const shouldAddOffset = !middlewareData.arrow && getAlignment2(placement) != null && center != offset22 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max22 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset22,
        centerOffset: center - offset22 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform22,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate2(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide2(placement);
      const isBasePlacement = getSide2(initialPlacement) === initialPlacement;
      const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement2(initialPlacement)] : getExpandedPlacements2(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements2(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow2(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides2(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d33) => d33.overflows[0] <= 0).sort((a33, b33) => a33.overflows[1] - b33.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d33) => [d33.placement, d33.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a33, b33) => a33[1] - b33[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords2(state, options) {
  const {
    placement,
    platform: platform22,
    elements
  } = state;
  const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating));
  const side = getSide2(placement);
  const alignment = getAlignment2(placement);
  const isVertical = getSideAxis2(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate2(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x32,
        y: y33
      } = state;
      const diffCoords = await convertValueToCoords2(state, options);
      return {
        x: x32 + diffCoords.x,
        y: y33 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x32,
        y: y33,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x43,
              y: y42
            } = _ref;
            return {
              x: x43,
              y: y42
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate2(options, state);
      const coords = {
        x: x32,
        y: y33
      };
      const overflow = await detectOverflow2(state, detectOverflowOptions);
      const crossAxis = getSideAxis2(getSide2(placement));
      const mainAxis = getOppositeAxis2(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min22 = mainAxisCoord + overflow[minSide];
        const max22 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min22, mainAxisCoord, max22);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min22 = crossAxisCoord + overflow[minSide];
        const max22 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min22, crossAxisCoord, max22);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x32,
          y: limitedCoords.y - y33
        }
      };
    }
  };
};
var size2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform22,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate2(options, state);
      const overflow = await detectOverflow2(state, detectOverflowOptions);
      const side = getSide2(placement);
      const alignment = getAlignment2(placement);
      const isYAxis = getSideAxis2(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min2(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min2(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform22.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle22(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement2(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isContainingBlock2(element) {
  const webkit = isWebKit2();
  const css2 = getComputedStyle22(element);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock2(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    if (isContainingBlock2(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode2(currentNode);
    }
  }
  return null;
}
function isWebKit2() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode2(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle22(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll2(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode2(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors2(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions2(element) {
  const css2 = getComputedStyle22(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement2(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale2(element) {
  const domElement = unwrapElement2(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords2(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $33
  } = getCssDimensions2(domElement);
  let x32 = ($33 ? round2(rect.width) : rect.width) / width;
  let y33 = ($33 ? round2(rect.height) : rect.height) / height;
  if (!x32 || !Number.isFinite(x32)) {
    x32 = 1;
  }
  if (!y33 || !Number.isFinite(y33)) {
    y33 = 1;
  }
  return {
    x: x32,
    y: y33
  };
}
var noOffsets2 = /* @__PURE__ */ createCoords2(0);
function getVisualOffsets2(element) {
  const win = getWindow2(element);
  if (!isWebKit2() || !win.visualViewport) {
    return noOffsets2;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets2(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement2(element);
  let scale = createCoords2(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale2(offsetParent);
      }
    } else {
      scale = getScale2(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets2(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets2(domElement) : createCoords2(0);
  let x32 = (clientRect.left + visualOffsets.x) / scale.x;
  let y33 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale2(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle22(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x32 *= iframeScale.x;
      y33 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x32 += left;
      y33 += top;
      currentIFrame = getWindow2(currentIFrame).frameElement;
    }
  }
  return rectToClientRect2({
    width,
    height,
    x: x32,
    y: y33
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect2(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords2(1);
  const offsets = createCoords2(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect2(offsetParent);
      scale = getScale2(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects2(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX2(element) {
  return getBoundingClientRect2(getDocumentElement2(element)).left + getNodeScroll2(element).scrollLeft;
}
function getDocumentRect2(element) {
  const html2 = getDocumentElement2(element);
  const scroll = getNodeScroll2(element);
  const body = element.ownerDocument.body;
  const width = max2(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x32 = -scroll.scrollLeft + getWindowScrollBarX2(element);
  const y33 = -scroll.scrollTop;
  if (getComputedStyle22(body).direction === "rtl") {
    x32 += max2(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x32,
    y: y33
  };
}
function getViewportRect2(element, strategy) {
  const win = getWindow2(element);
  const html2 = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x32 = 0;
  let y33 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit2();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x32 = visualViewport.offsetLeft;
      y33 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x32,
    y: y33
  };
}
function getInnerBoundingClientRect2(element, strategy) {
  const clientRect = getBoundingClientRect2(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale2(element) : createCoords2(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x32 = left * scale.x;
  const y33 = top * scale.y;
  return {
    width,
    height,
    x: x32,
    y: y33
  };
}
function getClientRectFromClippingAncestor2(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect2(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect2(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect2(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets2(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect2(rect);
}
function hasFixedPositionAncestor2(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode2(parentNode)) {
    return false;
  }
  return getComputedStyle22(parentNode).position === "fixed" || hasFixedPositionAncestor2(parentNode, stopNode);
}
function getClippingElementAncestors2(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle22(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode2(currentNode)) {
    const computedStyle = getComputedStyle22(currentNode);
    const currentNodeIsContaining = isContainingBlock2(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor2(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect2(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors2(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor2(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor2(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions2(element) {
  return getCssDimensions2(element);
}
function getRectRelativeToOffsetParent2(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect2(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords2(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect2(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX2(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent2(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle22(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent2(element, polyfill) {
  const window2 = getWindow2(element);
  if (!isHTMLElement2(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent2(element, polyfill);
  while (offsetParent && isTableElement2(offsetParent) && getComputedStyle22(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent2(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName2(offsetParent) === "html" || getNodeName2(offsetParent) === "body" && getComputedStyle22(offsetParent).position === "static" && !isContainingBlock2(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock2(element) || window2;
}
var getElementRects2 = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent2;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent2(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL2(element) {
  return getComputedStyle22(element).direction === "rtl";
}
var platform2 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect2,
  getDocumentElement: getDocumentElement2,
  getClippingRect: getClippingRect2,
  getOffsetParent: getOffsetParent2,
  getElementRects: getElementRects2,
  getClientRects: getClientRects2,
  getDimensions: getDimensions2,
  getScale: getScale2,
  isElement: isElement2,
  isRTL: isRTL2
};
function observeMove2(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e73) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate2(reference, floating, update22, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement2(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update22, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update22);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove2(referenceEl, update22) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update22();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect2(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect2(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update22();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update22();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update22);
      ancestorResize && ancestor.removeEventListener("resize", update22);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition22 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform2,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition3(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function t62(t73) {
  return r62(t73);
}
function o62(t73) {
  return t73.assignedSlot ? t73.assignedSlot : t73.parentNode instanceof ShadowRoot ? t73.parentNode.host : t73.parentNode;
}
function r62(t73) {
  for (let e73 = t73; e73; e73 = o62(e73)) if (e73 instanceof Element && "none" === getComputedStyle(e73).display) return null;
  for (let e73 = o62(t73); e73; e73 = o62(e73)) {
    if (!(e73 instanceof Element)) continue;
    const t83 = getComputedStyle(e73);
    if ("contents" !== t83.display) {
      if ("static" !== t83.position || "none" !== t83.filter) return e73;
      if ("BODY" === e73.tagName) return e73;
    }
  }
  return null;
}
function isVirtualElement2(e73) {
  return e73 !== null && typeof e73 === "object" && "getBoundingClientRect" in e73 && ("contextElement" in e73 ? e73 instanceof Element : true);
}
var SlPopup2 = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement2(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl && this.active) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate2(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent22 = this.strategy === "absolute" ? (element) => platform2.getOffsetParent(element, t62) : platform2.getOffsetParent;
    computePosition22(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps2(__spreadValues2({}, platform2), {
        getOffsetParent: getOffsetParent22
      })
    }).then(({ x: x32, y: y33, middlewareData, placement }) => {
      const isRtl = this.matches(":dir(rtl)");
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x32}px`,
        top: `${y33}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return ke4`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt2({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt2({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke4`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup2.styles = [component_styles_default2, popup_styles_default2];
__decorateClass2([
  e62(".popup")
], SlPopup2.prototype, "popup", 2);
__decorateClass2([
  e62(".popup__arrow")
], SlPopup2.prototype, "arrowEl", 2);
__decorateClass2([
  n52()
], SlPopup2.prototype, "anchor", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlPopup2.prototype, "active", 2);
__decorateClass2([
  n52({ reflect: true })
], SlPopup2.prototype, "placement", 2);
__decorateClass2([
  n52({ reflect: true })
], SlPopup2.prototype, "strategy", 2);
__decorateClass2([
  n52({ type: Number })
], SlPopup2.prototype, "distance", 2);
__decorateClass2([
  n52({ type: Number })
], SlPopup2.prototype, "skidding", 2);
__decorateClass2([
  n52({ type: Boolean })
], SlPopup2.prototype, "arrow", 2);
__decorateClass2([
  n52({ attribute: "arrow-placement" })
], SlPopup2.prototype, "arrowPlacement", 2);
__decorateClass2([
  n52({ attribute: "arrow-padding", type: Number })
], SlPopup2.prototype, "arrowPadding", 2);
__decorateClass2([
  n52({ type: Boolean })
], SlPopup2.prototype, "flip", 2);
__decorateClass2([
  n52({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p33) => p33.trim()).filter((p33) => p33 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup2.prototype, "flipFallbackPlacements", 2);
__decorateClass2([
  n52({ attribute: "flip-fallback-strategy" })
], SlPopup2.prototype, "flipFallbackStrategy", 2);
__decorateClass2([
  n52({ type: Object })
], SlPopup2.prototype, "flipBoundary", 2);
__decorateClass2([
  n52({ attribute: "flip-padding", type: Number })
], SlPopup2.prototype, "flipPadding", 2);
__decorateClass2([
  n52({ type: Boolean })
], SlPopup2.prototype, "shift", 2);
__decorateClass2([
  n52({ type: Object })
], SlPopup2.prototype, "shiftBoundary", 2);
__decorateClass2([
  n52({ attribute: "shift-padding", type: Number })
], SlPopup2.prototype, "shiftPadding", 2);
__decorateClass2([
  n52({ attribute: "auto-size" })
], SlPopup2.prototype, "autoSize", 2);
__decorateClass2([
  n52()
], SlPopup2.prototype, "sync", 2);
__decorateClass2([
  n52({ type: Object })
], SlPopup2.prototype, "autoSizeBoundary", 2);
__decorateClass2([
  n52({ attribute: "auto-size-padding", type: Number })
], SlPopup2.prototype, "autoSizePadding", 2);
__decorateClass2([
  n52({ attribute: "hover-bridge", type: Boolean })
], SlPopup2.prototype, "hoverBridge", 2);
var button_group_styles_default2 = i4`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;
var SlButtonGroup2 = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton2(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", true);
  }
  handleBlur(event) {
    const button = findButton2(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", false);
  }
  handleMouseOver(event) {
    const button = findButton2(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", true);
  }
  handleMouseOut(event) {
    const button = findButton2(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", false);
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton2(el);
      if (button) {
        button.toggleAttribute("data-sl-button-group__button", true);
        button.toggleAttribute("data-sl-button-group__button--first", index === 0);
        button.toggleAttribute("data-sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.toggleAttribute("data-sl-button-group__button--last", index === slottedElements.length - 1);
        button.toggleAttribute(
          "data-sl-button-group__button--radio",
          button.tagName.toLowerCase() === "sl-radio-button"
        );
      }
    });
  }
  render() {
    return ke4`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup2.styles = [component_styles_default2, button_group_styles_default2];
__decorateClass2([
  e62("slot")
], SlButtonGroup2.prototype, "defaultSlot", 2);
__decorateClass2([
  r52()
], SlButtonGroup2.prototype, "disableRole", 2);
__decorateClass2([
  n52()
], SlButtonGroup2.prototype, "label", 2);
function findButton2(el) {
  var _a33;
  const selector = "sl-button, sl-radio-button";
  return (_a33 = el.closest(selector)) != null ? _a33 : el.querySelector(selector);
}
var tab_group_styles_default = i4`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group--has-scroll-controls .tab-group__scroll-button--start--hidden,
  .tab-group--has-scroll-controls .tab-group__scroll-button--end--hidden {
    visibility: hidden;
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;
var resize_observer_styles_default = i4`
  :host {
    display: contents;
  }
`;
var SlResizeObserver = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.observedElements = [];
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver((entries) => {
      this.emit("sl-resize", { detail: { entries } });
    });
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  handleSlotChange() {
    if (!this.disabled) {
      this.startObserver();
    }
  }
  startObserver() {
    const slot = this.shadowRoot.querySelector("slot");
    if (slot !== null) {
      const elements = slot.assignedElements({ flatten: true });
      this.observedElements.forEach((el) => this.resizeObserver.unobserve(el));
      this.observedElements = [];
      elements.forEach((el) => {
        this.resizeObserver.observe(el);
        this.observedElements.push(el);
      });
    }
  }
  stopObserver() {
    this.resizeObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  render() {
    return ke4` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlResizeObserver.styles = [component_styles_default2, resize_observer_styles_default];
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlResizeObserver.prototype, "disabled", 2);
__decorateClass2([
  watch2("disabled", { waitUntilFirstUpdate: true })
], SlResizeObserver.prototype, "handleDisabledChange", 1);
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset22 = getOffset(element, container);
  const offsetTop = offset22.top + container.scrollTop;
  const offsetLeft = offset22.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}
var SlTabGroup = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController22(this);
    this.tabs = [];
    this.focusableTabs = [];
    this.panels = [];
    this.hasScrollControls = false;
    this.shouldHideScrollStartButton = false;
    this.shouldHideScrollEndButton = false;
    this.placement = "top";
    this.activation = "auto";
    this.noScrollControls = false;
    this.fixedScrollControls = false;
    this.scrollOffset = 1;
  }
  connectedCallback() {
    const whenAllDefined = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel")
    ]);
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator();
      this.updateScrollControls();
    });
    this.mutationObserver = new MutationObserver((mutations) => {
      if (mutations.some((m33) => !["aria-labelledby", "aria-controls"].includes(m33.attributeName))) {
        setTimeout(() => this.setAriaLabels());
      }
      if (mutations.some((m33) => m33.attributeName === "disabled")) {
        this.syncTabsAndPanels();
      }
    });
    this.updateComplete.then(() => {
      this.syncTabsAndPanels();
      this.mutationObserver.observe(this, { attributes: true, childList: true, subtree: true });
      this.resizeObserver.observe(this.nav);
      whenAllDefined.then(() => {
        const intersectionObserver = new IntersectionObserver((entries, observer) => {
          var _a33;
          if (entries[0].intersectionRatio > 0) {
            this.setAriaLabels();
            this.setActiveTab((_a33 = this.getActiveTab()) != null ? _a33 : this.tabs[0], { emitEvents: false });
            observer.unobserve(entries[0].target);
          }
        });
        intersectionObserver.observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    var _a33, _b;
    super.disconnectedCallback();
    (_a33 = this.mutationObserver) == null ? void 0 : _a33.disconnect();
    (_b = this.resizeObserver) == null ? void 0 : _b.unobserve(this.nav);
  }
  getAllTabs() {
    const slot = this.shadowRoot.querySelector('slot[name="nav"]');
    return slot.assignedElements();
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter((el) => el.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((el) => el.active);
  }
  handleClick(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (tab !== null) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (["Enter", " "].includes(event.key)) {
      if (tab !== null) {
        this.setActiveTab(tab, { scrollBehavior: "smooth" });
        event.preventDefault();
      }
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const activeEl = this.tabs.find((t73) => t73.matches(":focus"));
      const isRtl = this.matches(":dir(rtl)");
      let nextTab = null;
      if ((activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) === "sl-tab") {
        if (event.key === "Home") {
          nextTab = this.focusableTabs[0];
        } else if (event.key === "End") {
          nextTab = this.focusableTabs[this.focusableTabs.length - 1];
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && event.key === "ArrowUp") {
          const currentIndex = this.tabs.findIndex((el) => el === activeEl);
          nextTab = this.findNextFocusableTab(currentIndex, "backward");
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && event.key === "ArrowDown") {
          const currentIndex = this.tabs.findIndex((el) => el === activeEl);
          nextTab = this.findNextFocusableTab(currentIndex, "forward");
        }
        if (!nextTab) {
          return;
        }
        nextTab.tabIndex = 0;
        nextTab.focus({ preventScroll: true });
        if (this.activation === "auto") {
          this.setActiveTab(nextTab, { scrollBehavior: "smooth" });
        } else {
          this.tabs.forEach((tabEl) => {
            tabEl.tabIndex = tabEl === nextTab ? 0 : -1;
          });
        }
        if (["top", "bottom"].includes(this.placement)) {
          scrollIntoView(nextTab, this.nav, "horizontal");
        }
        event.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(tab, options) {
    options = __spreadValues2({
      emitEvents: true,
      scrollBehavior: "auto"
    }, options);
    if (tab !== this.activeTab && !tab.disabled) {
      const previousTab = this.activeTab;
      this.activeTab = tab;
      this.tabs.forEach((el) => {
        el.active = el === this.activeTab;
        el.tabIndex = el === this.activeTab ? 0 : -1;
      });
      this.panels.forEach((el) => {
        var _a33;
        return el.active = el.name === ((_a33 = this.activeTab) == null ? void 0 : _a33.panel);
      });
      this.syncIndicator();
      if (["top", "bottom"].includes(this.placement)) {
        scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
      }
      if (options.emitEvents) {
        if (previousTab) {
          this.emit("sl-tab-hide", { detail: { name: previousTab.panel } });
        }
        this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } });
      }
    }
  }
  setAriaLabels() {
    this.tabs.forEach((tab) => {
      const panel = this.panels.find((el) => el.name === tab.panel);
      if (panel) {
        tab.setAttribute("aria-controls", panel.getAttribute("id"));
        panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
      }
    });
  }
  repositionIndicator() {
    const currentTab = this.getActiveTab();
    if (!currentTab) {
      return;
    }
    const width = currentTab.clientWidth;
    const height = currentTab.clientHeight;
    const isRtl = this.matches(":dir(rtl)");
    const allTabs = this.getAllTabs();
    const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
    const offset22 = precedingTabs.reduce(
      (previous, current) => ({
        left: previous.left + current.clientWidth,
        top: previous.top + current.clientHeight
      }),
      { left: 0, top: 0 }
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${width}px`;
        this.indicator.style.height = "auto";
        this.indicator.style.translate = isRtl ? `${-1 * offset22.left}px` : `${offset22.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto";
        this.indicator.style.height = `${height}px`;
        this.indicator.style.translate = `0 ${offset22.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs();
    this.focusableTabs = this.tabs.filter((el) => !el.disabled);
    this.panels = this.getAllPanels();
    this.syncIndicator();
    this.updateComplete.then(() => this.updateScrollControls());
  }
  findNextFocusableTab(currentIndex, direction) {
    let nextTab = null;
    const iterator = direction === "forward" ? 1 : -1;
    let nextIndex = currentIndex + iterator;
    while (currentIndex < this.tabs.length) {
      nextTab = this.tabs[nextIndex] || null;
      if (nextTab === null) {
        if (direction === "forward") {
          nextTab = this.focusableTabs[0];
        } else {
          nextTab = this.focusableTabs[this.focusableTabs.length - 1];
        }
        break;
      }
      if (!nextTab.disabled) {
        break;
      }
      nextIndex += iterator;
    }
    return nextTab;
  }
  updateScrollButtons() {
    if (this.hasScrollControls && !this.fixedScrollControls) {
      this.shouldHideScrollStartButton = this.scrollFromStart() <= this.scrollOffset;
      this.shouldHideScrollEndButton = this.isScrolledToEnd();
    }
  }
  isScrolledToEnd() {
    return this.scrollFromStart() + this.nav.clientWidth >= this.nav.scrollWidth - this.scrollOffset;
  }
  scrollFromStart() {
    return this.localize.dir() === "rtl" ? -this.nav.scrollLeft : this.nav.scrollLeft;
  }
  updateScrollControls() {
    if (this.noScrollControls) {
      this.hasScrollControls = false;
    } else {
      this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth + 1;
    }
    this.updateScrollButtons();
  }
  syncIndicator() {
    const tab = this.getActiveTab();
    if (tab) {
      this.indicator.style.display = "block";
      this.repositionIndicator();
    } else {
      this.indicator.style.display = "none";
    }
  }
  /** Shows the specified tab panel. */
  show(panel) {
    const tab = this.tabs.find((el) => el.panel === panel);
    if (tab) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  render() {
    const isRtl = this.matches(":dir(rtl)");
    return ke4`
      <div
        part="base"
        class=${Rt2({
      "tab-group": true,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? ke4`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class=${Rt2({
      "tab-group__scroll-button": true,
      "tab-group__scroll-button--start": true,
      "tab-group__scroll-button--start--hidden": this.shouldHideScrollStartButton
    })}
                  name=${isRtl ? "chevron-right" : "chevron-left"}
                  library="system"
                  tabindex="-1"
                  aria-hidden="true"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav" @scrollend=${this.updateScrollButtons}>
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <sl-resize-observer @sl-resize=${this.syncIndicator}>
                <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
              </sl-resize-observer>
            </div>
          </div>

          ${this.hasScrollControls ? ke4`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class=${Rt2({
      "tab-group__scroll-button": true,
      "tab-group__scroll-button--end": true,
      "tab-group__scroll-button--end--hidden": this.shouldHideScrollEndButton
    })}
                  name=${isRtl ? "chevron-left" : "chevron-right"}
                  library="system"
                  tabindex="-1"
                  aria-hidden="true"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default2, tab_group_styles_default];
SlTabGroup.dependencies = { "sl-icon-button": SlIconButton, "sl-resize-observer": SlResizeObserver };
__decorateClass2([
  e62(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass2([
  e62(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
__decorateClass2([
  e62(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
__decorateClass2([
  e62(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
__decorateClass2([
  r52()
], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass2([
  r52()
], SlTabGroup.prototype, "shouldHideScrollStartButton", 2);
__decorateClass2([
  r52()
], SlTabGroup.prototype, "shouldHideScrollEndButton", 2);
__decorateClass2([
  n52()
], SlTabGroup.prototype, "placement", 2);
__decorateClass2([
  n52()
], SlTabGroup.prototype, "activation", 2);
__decorateClass2([
  n52({ attribute: "no-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass2([
  n52({ attribute: "fixed-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "fixedScrollControls", 2);
__decorateClass2([
  t52({ passive: true })
], SlTabGroup.prototype, "updateScrollButtons", 1);
__decorateClass2([
  watch2("noScrollControls", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass2([
  watch2("placement", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "syncIndicator", 1);
var debounce = (fn, delay) => {
  let timerId = 0;
  return function(...args) {
    window.clearTimeout(timerId);
    timerId = window.setTimeout(() => {
      fn.call(this, ...args);
    }, delay);
  };
};
var decorate = (proto, method, decorateFn) => {
  const superFn = proto[method];
  proto[method] = function(...args) {
    superFn.call(this, ...args);
    decorateFn.call(this, superFn, ...args);
  };
};
var isSupported = "onscrollend" in window;
if (!isSupported) {
  const pointers = /* @__PURE__ */ new Set();
  const scrollHandlers = /* @__PURE__ */ new WeakMap();
  const handlePointerDown = (event) => {
    for (const touch of event.changedTouches) {
      pointers.add(touch.identifier);
    }
  };
  const handlePointerUp = (event) => {
    for (const touch of event.changedTouches) {
      pointers.delete(touch.identifier);
    }
  };
  document.addEventListener("touchstart", handlePointerDown, true);
  document.addEventListener("touchend", handlePointerUp, true);
  document.addEventListener("touchcancel", handlePointerUp, true);
  decorate(EventTarget.prototype, "addEventListener", function(addEventListener, type) {
    if (type !== "scrollend")
      return;
    const handleScrollEnd = debounce(() => {
      if (!pointers.size) {
        this.dispatchEvent(new Event("scrollend"));
      } else {
        handleScrollEnd();
      }
    }, 100);
    addEventListener.call(this, "scroll", handleScrollEnd, { passive: true });
    scrollHandlers.set(this, handleScrollEnd);
  });
  decorate(EventTarget.prototype, "removeEventListener", function(removeEventListener, type) {
    if (type !== "scrollend")
      return;
    const scrollHandler = scrollHandlers.get(this);
    if (scrollHandler) {
      removeEventListener.call(this, "scroll", scrollHandler, { passive: true });
    }
  });
}
var tab_styles_default = i4`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  :host(:focus) {
    outline: transparent;
  }

  :host(:focus-visible):not([disabled]) {
    color: var(--sl-color-primary-600);
  }

  :host(:focus-visible) {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`;
var id = 0;
var SlTab = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController22(this);
    this.attrId = ++id;
    this.componentId = `sl-tab-${this.attrId}`;
    this.panel = "";
    this.active = false;
    this.closable = false;
    this.disabled = false;
    this.tabIndex = 0;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tab");
  }
  handleCloseClick(event) {
    event.stopPropagation();
    this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    if (this.disabled && !this.active) {
      this.tabIndex = -1;
    } else {
      this.tabIndex = 0;
    }
  }
  render() {
    this.id = this.id.length > 0 ? this.id : this.componentId;
    return ke4`
      <div
        part="base"
        class=${Rt2({
      tab: true,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
      >
        <slot></slot>
        ${this.closable ? ke4`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default2, tab_styles_default];
SlTab.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass2([
  e62(".tab")
], SlTab.prototype, "tab", 2);
__decorateClass2([
  n52({ reflect: true })
], SlTab.prototype, "panel", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlTab.prototype, "active", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlTab.prototype, "closable", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlTab.prototype, "disabled", 2);
__decorateClass2([
  n52({ type: Number, reflect: true })
], SlTab.prototype, "tabIndex", 2);
__decorateClass2([
  watch2("active")
], SlTab.prototype, "handleActiveChange", 1);
__decorateClass2([
  watch2("disabled")
], SlTab.prototype, "handleDisabledChange", 1);
var tab_panel_styles_default = i4`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;
var id2 = 0;
var SlTabPanel = class extends ShoelaceElement2 {
  constructor() {
    super(...arguments);
    this.attrId = ++id2;
    this.componentId = `sl-tab-panel-${this.attrId}`;
    this.name = "";
    this.active = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.id = this.id.length > 0 ? this.id : this.componentId;
    this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return ke4`
      <slot
        part="base"
        class=${Rt2({
      "tab-panel": true,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default2, tab_panel_styles_default];
__decorateClass2([
  n52({ reflect: true })
], SlTabPanel.prototype, "name", 2);
__decorateClass2([
  n52({ type: Boolean, reflect: true })
], SlTabPanel.prototype, "active", 2);
__decorateClass2([
  watch2("active")
], SlTabPanel.prototype, "handleActiveChange", 1);
var patch_question_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-patch-question" viewBox="0 0 16 16">%0A  <path d="M8.05 9.6c.336 0 .504-.24.554-.627.04-.534.198-.815.847-1.26.673-.475 1.049-1.09 1.049-1.986 0-1.325-.92-2.227-2.262-2.227-1.02 0-1.792.492-2.1 1.29A1.7 1.7 0 0 0 6 5.48c0 .393.203.64.545.64.272 0 .455-.147.564-.51.158-.592.525-.915 1.074-.915.61 0 1.03.446 1.03 1.084 0 .563-.208.885-.822 1.325-.619.433-.926.914-.926 1.64v.111c0 .428.208.745.585.745"/>%0A  <path d="m10.273 2.513-.921-.944.715-.698.622.637.89-.011a2.89 2.89 0 0 1 2.924 2.924l-.01.89.636.622a2.89 2.89 0 0 1 0 4.134l-.637.622.011.89a2.89 2.89 0 0 1-2.924 2.924l-.89-.01-.622.636a2.89 2.89 0 0 1-4.134 0l-.622-.637-.89.011a2.89 2.89 0 0 1-2.924-2.924l.01-.89-.636-.622a2.89 2.89 0 0 1 0-4.134l.637-.622-.011-.89a2.89 2.89 0 0 1 2.924-2.924l.89.01.622-.636a2.89 2.89 0 0 1 4.134 0l-.715.698a1.89 1.89 0 0 0-2.704 0l-.92.944-1.32-.016a1.89 1.89 0 0 0-1.911 1.912l.016 1.318-.944.921a1.89 1.89 0 0 0 0 2.704l.944.92-.016 1.32a1.89 1.89 0 0 0 1.912 1.911l1.318-.016.921.944a1.89 1.89 0 0 0 2.704 0l.92-.944 1.32.016a1.89 1.89 0 0 0 1.911-1.912l-.016-1.318.944-.921a1.89 1.89 0 0 0 0-2.704l-.944-.92.016-1.32a1.89 1.89 0 0 0-1.912-1.911z"/>%0A  <path d="M7.001 11a1 1 0 1 1 2 0 1 1 0 0 1-2 0"/>%0A</svg>';
var patch_question_fill_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-patch-question-fill" viewBox="0 0 16 16">%0A  <path d="M5.933.87a2.89 2.89 0 0 1 4.134 0l.622.638.89-.011a2.89 2.89 0 0 1 2.924 2.924l-.01.89.636.622a2.89 2.89 0 0 1 0 4.134l-.637.622.011.89a2.89 2.89 0 0 1-2.924 2.924l-.89-.01-.622.636a2.89 2.89 0 0 1-4.134 0l-.622-.637-.89.011a2.89 2.89 0 0 1-2.924-2.924l.01-.89-.636-.622a2.89 2.89 0 0 1 0-4.134l.637-.622-.011-.89a2.89 2.89 0 0 1 2.924-2.924l.89.01zM7.002 11a1 1 0 1 0 2 0 1 1 0 0 0-2 0m1.602-2.027c.04-.534.198-.815.846-1.26.674-.475 1.05-1.09 1.05-1.986 0-1.325-.92-2.227-2.262-2.227-1.02 0-1.792.492-2.1 1.29A1.7 1.7 0 0 0 6 5.48c0 .393.203.64.545.64.272 0 .455-.147.564-.51.158-.592.525-.915 1.074-.915.61 0 1.03.446 1.03 1.084 0 .563-.208.885-.822 1.325-.619.433-.926.914-.926 1.64v.111c0 .428.208.745.585.745.336 0 .504-.24.554-.627"/>%0A</svg>';
var patch_check_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-patch-check" viewBox="0 0 16 16">%0A  <path fill-rule="evenodd" d="M10.354 6.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7 8.793l2.646-2.647a.5.5 0 0 1 .708 0"/>%0A  <path d="m10.273 2.513-.921-.944.715-.698.622.637.89-.011a2.89 2.89 0 0 1 2.924 2.924l-.01.89.636.622a2.89 2.89 0 0 1 0 4.134l-.637.622.011.89a2.89 2.89 0 0 1-2.924 2.924l-.89-.01-.622.636a2.89 2.89 0 0 1-4.134 0l-.622-.637-.89.011a2.89 2.89 0 0 1-2.924-2.924l.01-.89-.636-.622a2.89 2.89 0 0 1 0-4.134l.637-.622-.011-.89a2.89 2.89 0 0 1 2.924-2.924l.89.01.622-.636a2.89 2.89 0 0 1 4.134 0l-.715.698a1.89 1.89 0 0 0-2.704 0l-.92.944-1.32-.016a1.89 1.89 0 0 0-1.911 1.912l.016 1.318-.944.921a1.89 1.89 0 0 0 0 2.704l.944.92-.016 1.32a1.89 1.89 0 0 0 1.912 1.911l1.318-.016.921.944a1.89 1.89 0 0 0 2.704 0l.92-.944 1.32.016a1.89 1.89 0 0 0 1.911-1.912l-.016-1.318.944-.921a1.89 1.89 0 0 0 0-2.704l-.944-.92.016-1.32a1.89 1.89 0 0 0-1.912-1.911z"/>%0A</svg>';
var patch_check_fill_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-patch-check-fill" viewBox="0 0 16 16">%0A  <path d="M10.067.87a2.89 2.89 0 0 0-4.134 0l-.622.638-.89-.011a2.89 2.89 0 0 0-2.924 2.924l.01.89-.636.622a2.89 2.89 0 0 0 0 4.134l.637.622-.011.89a2.89 2.89 0 0 0 2.924 2.924l.89-.01.622.636a2.89 2.89 0 0 0 4.134 0l.622-.637.89.011a2.89 2.89 0 0 0 2.924-2.924l-.01-.89.636-.622a2.89 2.89 0 0 0 0-4.134l-.637-.622.011-.89a2.89 2.89 0 0 0-2.924-2.924l-.89.01zm.287 5.984-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7 8.793l2.646-2.647a.5.5 0 0 1 .708.708"/>%0A</svg>';
async function arrayBufferToDataUrl(buffer) {
  return new Promise((r73) => {
    const reader = new FileReader();
    reader.onload = () => r73(reader.result);
    reader.readAsDataURL(new Blob([buffer]));
  });
}
async function dataUrlToArrayBuffer(url) {
  return await (await (await fetch(url)).blob()).arrayBuffer();
}
function getKeyMaterial(password) {
  let enc = new TextEncoder();
  return window.crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveBits", "deriveKey"]
  );
}
function getKey(keyMaterial, salt) {
  return window.crypto.subtle.deriveKey(
    {
      "name": "PBKDF2",
      salt,
      "iterations": 1e5,
      "hash": "SHA-256"
    },
    keyMaterial,
    { "name": "AES-GCM", "length": 256 },
    true,
    ["encrypt", "decrypt"]
  );
}
function romanOrdinal(num, capitalize = false) {
  let roman = {
    m: 1e3,
    cm: 900,
    d: 500,
    cd: 400,
    c: 100,
    xc: 90,
    l: 50,
    xl: 40,
    x: 10,
    ix: 9,
    v: 5,
    iv: 4,
    i: 1
  };
  let str = "";
  for (let i43 of Object.keys(roman)) {
    let q32 = Math.floor(num / roman[i43]);
    num -= q32 * roman[i43];
    str += i43.repeat(q32);
  }
  return capitalize ? str.toUpperCase() : str;
}
function alphabeticalOrdinal(num, capitalize = false, alphabet = "abcdefghijklmnopqrstuvwxyz") {
  const a33 = alphabet[0];
  const k33 = alphabet.length;
  const str = a33.repeat(Math.floor(num / k33)) + alphabet[num % k33];
  return capitalize ? str.toUpperCase() : str;
}
var _activeExplainer_dec;
var _hintSlotEl_dec;
var _slotEl_dec2;
var _iv_dec;
var _salt_dec;
var _password_dec;
var _solution_dec;
var _counter_dec2;
var _hintOpen_dec;
var _submitted_dec2;
var _directSubmit_dec;
var _isChanged_dec;
var _hint_dec;
var _hints_dec;
var _a22;
var _WebwriterTask_decorators;
var _init22;
var _hints;
var _hint;
var _isChanged;
var _submitted2;
var _hintOpen;
var _counter;
var _solution;
var _password;
var _salt;
var _iv;
var _WebwriterTask_instances;
var encodeSolution_fn;
var decodeSolution_fn;
var _slotEl2;
var _hintSlotEl;
var _activeExplainer;
_WebwriterTask_decorators = [t42("webwriter-task")];
var _WebwriterTask = class _WebwriterTask2 extends (_a22 = LitElementWw2, _hints_dec = [o52({ slot: "hint" })], _hint_dec = [n52({ type: Boolean, attribute: true, reflect: true })], _isChanged_dec = [n52({ type: Boolean, state: true, attribute: false, reflect: false })], _directSubmit_dec = [n52({ type: Boolean, attribute: false, reflect: true })], _submitted_dec2 = [n52({ type: Boolean, attribute: true, reflect: true })], _hintOpen_dec = [n52({ attribute: false, state: true })], _counter_dec2 = [n52({ attribute: true, reflect: true })], _solution_dec = [n52({ type: String, attribute: true, reflect: true })], _password_dec = [n52({ type: String, attribute: false, reflect: false })], _salt_dec = [n52({ type: String, attribute: true, reflect: true })], _iv_dec = [n52({ type: String, attribute: true, reflect: true })], _slotEl_dec2 = [e62("slot:not([name])")], _hintSlotEl_dec = [e62("slot[name=hint]")], _activeExplainer_dec = [n52()], _a22) {
  constructor() {
    super(...arguments);
    __runInitializers3(_init22, 5, this);
    __privateAdd4(this, _WebwriterTask_instances);
    __publicField3(this, "msg", (str) => this.lang in _WebwriterTask2.localization ? _WebwriterTask2.localization[this.lang][str] ?? str : str);
    __privateAdd4(this, _hints, __runInitializers3(_init22, 8, this)), __runInitializers3(_init22, 11, this);
    __privateAdd4(this, _hint, __runInitializers3(_init22, 12, this, false)), __runInitializers3(_init22, 15, this);
    __privateAdd4(this, _isChanged, __runInitializers3(_init22, 16, this, false)), __runInitializers3(_init22, 19, this);
    __privateAdd4(this, _submitted2, __runInitializers3(_init22, 20, this, false)), __runInitializers3(_init22, 23, this);
    __publicField3(this, "toggleExplainers", () => {
      if (this.explainers.length) {
        this.explainers.forEach((explainer) => explainer.remove());
        this.activeExplainer = void 0;
      } else {
        const solutionExplainer = this.ownerDocument.createElement("webwriter-task-explainer");
        solutionExplainer.slot = "explainer";
        solutionExplainer.id = "solution";
        solutionExplainer.active = true;
        this.append(solutionExplainer);
        this.ownerDocument.getSelection().setBaseAndExtent(solutionExplainer, 0, solutionExplainer, 0);
        this.requestUpdate();
        this.activeExplainer = "solution";
      }
    });
    __privateAdd4(this, _hintOpen, __runInitializers3(_init22, 24, this, false)), __runInitializers3(_init22, 27, this);
    __privateAdd4(this, _counter, __runInitializers3(_init22, 28, this)), __runInitializers3(_init22, 31, this);
    __publicField3(this, "observer");
    __privateAdd4(this, _solution, __runInitializers3(_init22, 32, this)), __runInitializers3(_init22, 35, this);
    __privateAdd4(this, _password, __runInitializers3(_init22, 36, this, "B08bxd82SAOf")), __runInitializers3(_init22, 39, this);
    __privateAdd4(this, _salt, __runInitializers3(_init22, 40, this)), __runInitializers3(_init22, 43, this);
    __privateAdd4(this, _iv, __runInitializers3(_init22, 44, this)), __runInitializers3(_init22, 47, this);
    __privateAdd4(this, _slotEl2, __runInitializers3(_init22, 48, this)), __runInitializers3(_init22, 51, this);
    __privateAdd4(this, _hintSlotEl, __runInitializers3(_init22, 52, this)), __runInitializers3(_init22, 55, this);
    __publicField3(this, "handleHintSlotChange", (e73) => {
      if (!this.hasHintElement) {
        this.hintOpen = false;
        this.hint = false;
      }
    });
    __publicField3(this, "handleHintKeydown", (e73) => {
      console.log(document.getSelection().anchorOffset === 0, this.hints.includes(document.getSelection().anchorNode.parentElement));
      if (e73.key === "Backspace" && document.getSelection().anchorOffset === 0 && this.hints.includes(document.getSelection().anchorNode.parentElement)) {
        this.hintOpen = false;
        this.hint = false;
      }
    });
    __publicField3(this, "handleSubmit", async () => {
      await __privateMethod3(this, _WebwriterTask_instances, decodeSolution_fn).call(this);
      this.answer.reportSolution();
      this.dispatchEvent(new SubmitEvent("submit", { bubbles: true, composed: true }));
      this.activeExplainer = this.explainers[0].id;
      this.submitted = true;
    });
    __publicField3(this, "handleReset", () => {
      this.answer.reset && this.answer.reset();
      this.isChanged = false;
      this.submitted = false;
    });
    __publicField3(this, "handleAnswerChange", async (e73) => {
      this.isChanged = true;
      if (this.isContentEditable) {
        __privateMethod3(this, _WebwriterTask_instances, encodeSolution_fn).call(this);
      }
    });
    __publicField3(this, "handleSlotChange", (e73) => {
      this.requestUpdate();
      if (this.isContentEditable) {
        const solution = __privateMethod3(this, _WebwriterTask_instances, decodeSolution_fn).call(this) ?? {};
        Object.entries(solution).forEach(([k33, v33]) => {
          this.answer[k33] = v33;
        });
      }
    });
    __privateAdd4(this, _activeExplainer, __runInitializers3(_init22, 56, this)), __runInitializers3(_init22, 59, this);
  }
  get hasHintElement() {
    return this.hints.length > 0;
  }
  get hasHintContent() {
    return this.hints.some((hint) => hint.innerText.trim() !== "");
  }
  get directSubmit() {
    return !this.closest("webwriter-quiz");
  }
  set directSubmit(value) {
    return;
  }
  toggleHint() {
    this.hintOpen = !this.hintOpen;
    if (this.isContentEditable && this.hintOpen) {
      this.hint = true;
      if (!this.hasHintElement) {
        const hintEl = this.ownerDocument.createElement("webwriter-task-hint");
        hintEl.slot = "hint";
        this.answer.insertAdjacentElement("beforebegin", hintEl);
        this.ownerDocument.getSelection().setBaseAndExtent(hintEl, 0, hintEl, 0);
      }
    } else if (this.isContentEditable && !this.hintOpen) {
      if (!this.hasHintContent) {
        this.hint = false;
        this.hintSlotEl.assignedElements().forEach((el) => el.remove());
      }
    }
  }
  get explainers() {
    return Array.from(this.querySelectorAll("webwriter-task-explainer"));
  }
  get index() {
    return [...this?.parentElement?.children ?? []].indexOf(this);
  }
  get ordinalExpr() {
    if (this.index === void 0 || this.index === -1) {
      return void 0;
    }
    if (this.counter === "number") {
      return `${this.index + 1}.`;
    } else if (this.counter === "roman") {
      return `${romanOrdinal(this.index + 1)}.`;
    } else if (this.counter === "roman-capitalized") {
      return `${romanOrdinal(this.index + 1, true)}.`;
    } else if (this.counter === "alphabetical") {
      return `${alphabeticalOrdinal(this.index)}.`;
    } else if (this.counter === "alphabetical-capitalized") {
      return `${alphabeticalOrdinal(this.index, true)}.`;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.observer = new MutationObserver(() => this.requestUpdate());
    this.parentElement && this.observer.observe(this.parentElement, { childList: true });
    this.addEventListener("keydown", (e73) => this.handleHintKeydown(e73));
  }
  firstUpdated(_changedProperties) {
    if (this.isContentEditable) {
      __privateMethod3(this, _WebwriterTask_instances, decodeSolution_fn).call(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.observer.disconnect();
  }
  checkSolution() {
    const solution = __privateMethod3(this, _WebwriterTask_instances, decodeSolution_fn).call(this);
    return Object.entries(solution).every(([k33, v33]) => {
      return JSON.stringify(this.answer[k33]) === JSON.stringify(v33);
    });
  }
  reportSolution() {
    this.answer.reportSolution(__privateMethod3(this, _WebwriterTask_instances, decodeSolution_fn).call(this));
  }
  get answer() {
    return this.slotEl?.assignedElements()[0];
  }
  selectExplainer(id3) {
    const explainer = this.explainers.find((node) => node.id === id3);
    explainer.active = true;
    this.explainers.filter((node) => node.id !== id3).forEach((node) => node.active = false);
    this.activeExplainer = id3;
    setTimeout(() => this.ownerDocument.getSelection().setBaseAndExtent(explainer, 0, explainer, 0));
  }
  get explainerLabels() {
    return {
      "solution": "Explainer",
      "else": "Else"
    };
  }
  render() {
    return ke4`
      <header>
        <span>${this.ordinalExpr}</span>
        <slot name="prompt"></slot>
        <div id="task-buttons">
          <sl-icon-button class="author-only" id="feedback" src=${!this.explainers.length ? patch_check_default : patch_check_fill_default} @click=${() => this.toggleExplainers()}></sl-icon-button>
          <sl-popup id="hint-popup" ?active=${this.hintOpen} placement="left" arrow auto-size shift @selectstart=${(e73) => e73.stopImmediatePropagation()}>
            <sl-icon-button class="author-only" slot="anchor" id="hint" src=${!this.hasHintContent && !this.hintOpen ? patch_question_default : patch_question_fill_default} @click=${() => this.toggleHint()}></sl-icon-button>
            <div id="hint-content">
              <slot name="hint" @slotchange=${this.handleHintSlotChange}></slot>
            </div>
          </sl-popup>
        </div>
      </header>
      <slot @ww-answer-change=${this.handleAnswerChange} @slotchange=${this.handleSlotChange} ?inert=${this.submitted}></slot>
      <sl-tab-group id="explainer-group" placement="end" ?data-empty=${!this.explainers.length} ?data-single=${this.explainers.length === 1}>
        ${this.explainers.map((explainer, i43) => ke4`<sl-tab ?active=${this.activeExplainer === explainer.id} slot="nav" @click=${() => this.selectExplainer(explainer.id)}>${this.explainerLabels[explainer.id] ?? explainer.id}</sl-tab>`)}
        <slot name="explainer" style=${se({ "--ww-placeholder": `"${this.msg("Explanation")}"` })}></slot>
      </sl-tab-group>
      ${!this.directSubmit || !this.answer?.reportSolution ? null : ke4`
        <sl-button-group class="user-only user-actions">
          <sl-button id="submit" @click=${this.handleSubmit}>Check your answers</sl-button>
          <sl-button ?disabled=${!this.isChanged && !this.submitted} id="reset" class="user-only" @click=${this.handleReset}>Try again</sl-button>
        </sl-button-group>
      `}
    `;
  }
};
_init22 = __decoratorStart3(_a22);
_hints = /* @__PURE__ */ new WeakMap();
_hint = /* @__PURE__ */ new WeakMap();
_isChanged = /* @__PURE__ */ new WeakMap();
_submitted2 = /* @__PURE__ */ new WeakMap();
_hintOpen = /* @__PURE__ */ new WeakMap();
_counter = /* @__PURE__ */ new WeakMap();
_solution = /* @__PURE__ */ new WeakMap();
_password = /* @__PURE__ */ new WeakMap();
_salt = /* @__PURE__ */ new WeakMap();
_iv = /* @__PURE__ */ new WeakMap();
_WebwriterTask_instances = /* @__PURE__ */ new WeakSet();
encodeSolution_fn = async function() {
  const value = this.answer.solution;
  console.log(value);
  let keyMaterial = await getKeyMaterial(this.password);
  let salt = window.crypto.getRandomValues(new Uint8Array(16));
  let iv = window.crypto.getRandomValues(new Uint8Array(12));
  let key = await getKey(keyMaterial, salt);
  let encoder = new TextEncoder();
  let encodedMessage = encoder.encode(JSON.stringify(value));
  const solution = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    encodedMessage
  );
  this.solution = await arrayBufferToDataUrl(solution);
  this.iv = await arrayBufferToDataUrl(iv);
  this.salt = await arrayBufferToDataUrl(salt);
};
decodeSolution_fn = async function() {
  if (!this.solution) {
    return;
  }
  const encodedSolution = await dataUrlToArrayBuffer(this.solution);
  const iv = await dataUrlToArrayBuffer(this.iv);
  const salt = await dataUrlToArrayBuffer(this.salt);
  let keyMaterial = await getKeyMaterial(this.password);
  let key = await getKey(keyMaterial, new Uint8Array(salt));
  try {
    const solutionBuffer = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encodedSolution);
    let decoder = new TextDecoder();
    const solution = JSON.parse(decoder.decode(solutionBuffer));
    this.answer.solution = solution;
  } catch (err) {
    console.error(err);
    throw new Error("Invalid password");
  }
};
_slotEl2 = /* @__PURE__ */ new WeakMap();
_hintSlotEl = /* @__PURE__ */ new WeakMap();
_activeExplainer = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init22, 4, "hints", _hints_dec, _WebwriterTask, _hints);
__decorateElement3(_init22, 4, "hint", _hint_dec, _WebwriterTask, _hint);
__decorateElement3(_init22, 4, "isChanged", _isChanged_dec, _WebwriterTask, _isChanged);
__decorateElement3(_init22, 3, "directSubmit", _directSubmit_dec, _WebwriterTask);
__decorateElement3(_init22, 4, "submitted", _submitted_dec2, _WebwriterTask, _submitted2);
__decorateElement3(_init22, 4, "hintOpen", _hintOpen_dec, _WebwriterTask, _hintOpen);
__decorateElement3(_init22, 4, "counter", _counter_dec2, _WebwriterTask, _counter);
__decorateElement3(_init22, 4, "solution", _solution_dec, _WebwriterTask, _solution);
__decorateElement3(_init22, 4, "password", _password_dec, _WebwriterTask, _password);
__decorateElement3(_init22, 4, "salt", _salt_dec, _WebwriterTask, _salt);
__decorateElement3(_init22, 4, "iv", _iv_dec, _WebwriterTask, _iv);
__decorateElement3(_init22, 4, "slotEl", _slotEl_dec2, _WebwriterTask, _slotEl2);
__decorateElement3(_init22, 4, "hintSlotEl", _hintSlotEl_dec, _WebwriterTask, _hintSlotEl);
__decorateElement3(_init22, 4, "activeExplainer", _activeExplainer_dec, _WebwriterTask, _activeExplainer);
_WebwriterTask = __decorateElement3(_init22, 0, "WebwriterTask", _WebwriterTask_decorators, _WebwriterTask);
__publicField3(_WebwriterTask, "localization", {});
__publicField3(_WebwriterTask, "scopedElements", {
  "sl-icon-button": SlIconButton,
  "sl-details": SlDetails,
  "sl-popup": SlPopup2,
  "sl-button": SlButton2,
  "sl-button-group": SlButtonGroup2,
  "sl-tab-group": SlTabGroup,
  "sl-tab": SlTab,
  "sl-tab-panel": SlTabPanel
});
__publicField3(_WebwriterTask, "styles", i4`
    :host {
      display: flex !important;
      flex-direction: column;
      gap: 1rem;
      position: relative;
      z-index: 1;
    }


    :host(:not([hint])) details {
      display: none;
    }

    sl-tooltip::part(base__popup) {
      cursor: text;
    }

    #hint-popup {
      --arrow-color: var(--sl-color-neutral-700);
      z-index: 1000;
    }

    #hint-popup::part(popup) {
      z-index: 100;
      max-width: 200px;
    }

    :host(:not([contenteditable=true]):not([contenteditable=""]):not([hint])) #hint {
      display: none;
    }
    
    :host(:not([contenteditable=true]):not([contenteditable=""])) .author-only {
      display: none;
    }

    :host(:is([contenteditable=true], [contenteditable=""])) .user-only {
      display: none;
    }

    :host(:not([contenteditable=true]):not([contenteditable=""])) {
      ::slotted([slot=prompt]:empty) {
        display: none;
      }
    }

    :host(:not([submitted]):not([contenteditable=true]):not([contenteditable=""])) #explainer-group {
      display: none;
    }

    #task-buttons {
      position: absolute;
      right: 0;
      top: 0;
      background: rgba(255, 255, 255, 0.9);
      user-select: none;
      z-index: 100;
    }

    #hint-content {
      background: var(--sl-color-neutral-700);
      color: var(--sl-color-neutral-50);
      min-width: 2ch;
      font-size: 0.75rem;
      padding: 0.5rem;
      border-radius: 4px;
      user-select: auto;
    }

    ::slotted([slot=explainer]:not([active])) {
      display: none !important;
    }

    sl-tab-group {
      &[data-empty] {
        display: none;
      }

      &[data-single] sl-tab {
        display: none;
      }

      & sl-tab::part(base) {
        padding: 10px;
      }

      &::part(tabs) {
        height: 100px;
        margin-left: -1px;
        z-index: 10;
      }

      & ::slotted([name=explainer]) {
        height: 100%;
      }
    }

    header {
      display: flex;
      flex-direction: row;
      gap: 1ch;

      & span:empty {
        display: none;
      } 

      & slot {
        display: block;
        flex-grow: 1;
      }
    }

    .user-actions {
      & #submit {
        flex-grow: 3;
      }

      & #reset {
        flex-grow: 1;
      }
    }

  `);
__runInitializers3(_init22, 1, _WebwriterTask);

// https:/cdn.jsdelivr.net/npm/@webwriter/quiz@1.0.5/dist/widgets/webwriter-task-prompt.js
var __create4 = Object.create;
var __defProp5 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __knownSymbol4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name4 = (target, value) => __defProp5(target, "name", { value, configurable: true });
var __decoratorStart4 = (base) => [, , , __create4(base?.[__knownSymbol4("metadata")] ?? null)];
var __decoratorStrings4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError4("Function expected") : fn;
var __decoratorContext4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings4[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError4("Already initialized") : fns.push(__expectFn4(fn || null)) });
var __decoratorMetadata4 = (array, target) => __defNormalProp5(target, __knownSymbol4("metadata"), array[3]);
var __runInitializers4 = (array, flags, self2, value) => {
  for (var i43 = 0, fns = array[flags >> 1], n63 = fns && fns.length; i43 < n63; i43++) flags & 1 ? fns[i43].call(self2) : value = fns[i43].call(self2, value);
  return value;
};
var __decorateElement4 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k33 = flags & 7, s33 = !!(flags & 8), p33 = !!(flags & 16);
  var j33 = k33 > 3 ? array.length + 1 : k33 ? s33 ? 1 : 2 : 0, key = __decoratorStrings4[k33 + 5];
  var initializers = k33 > 3 && (array[j33 - 1] = []), extraInitializers = array[j33] || (array[j33] = []);
  var desc = k33 && (!p33 && !s33 && (target = target.prototype), k33 < 5 && (k33 > 3 || !p33) && __getOwnPropDesc5(k33 < 4 ? target : { get [name]() {
    return __privateGet5(this, extra);
  }, set [name](x32) {
    return __privateSet5(this, extra, x32);
  } }, name));
  k33 ? p33 && k33 < 4 && __name4(extra, (k33 > 2 ? "set " : k33 > 1 ? "get " : "") + name) : __name4(target, name);
  for (var i43 = decorators.length - 1; i43 >= 0; i43--) {
    ctx = __decoratorContext4(k33, name, done = {}, array[3], extraInitializers);
    if (k33) {
      ctx.static = s33, ctx.private = p33, access = ctx.access = { has: p33 ? (x32) => __privateIn4(target, x32) : (x32) => name in x32 };
      if (k33 ^ 3) access.get = p33 ? (x32) => (k33 ^ 1 ? __privateGet5 : __privateMethod4)(x32, target, k33 ^ 4 ? extra : desc.get) : (x32) => x32[name];
      if (k33 > 2) access.set = p33 ? (x32, y33) => __privateSet5(x32, target, y33, k33 ^ 4 ? extra : desc.set) : (x32, y33) => x32[name] = y33;
    }
    it = (0, decorators[i43])(k33 ? k33 < 4 ? p33 ? extra : desc[key] : k33 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k33 ^ 4 || it === void 0) __expectFn4(it) && (k33 > 4 ? initializers.unshift(it) : k33 ? p33 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError4("Object expected");
    else __expectFn4(fn = it.get) && (desc.get = fn), __expectFn4(fn = it.set) && (desc.set = fn), __expectFn4(fn = it.init) && initializers.unshift(fn);
  }
  return k33 || __decoratorMetadata4(array, target), desc && __defProp5(target, name, desc), p33 ? k33 ^ 4 ? extra : desc : target;
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateIn4 = (member, obj) => Object(obj) !== obj ? __typeError4('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var t7 = globalThis;
var e8 = t7.ShadowRoot && (void 0 === t7.ShadyCSS || t7.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s4 = Symbol();
var o8 = /* @__PURE__ */ new WeakMap();
var n7 = class {
  constructor(t54, e66, o46) {
    if (this._$cssResult$ = true, o46 !== s4) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t54, this.t = e66;
  }
  get styleSheet() {
    let t54 = this.o;
    const s33 = this.t;
    if (e8 && void 0 === t54) {
      const e66 = void 0 !== s33 && 1 === s33.length;
      e66 && (t54 = o8.get(s33)), void 0 === t54 && ((this.o = t54 = new CSSStyleSheet()).replaceSync(this.cssText), e66 && o8.set(s33, t54));
    }
    return t54;
  }
  toString() {
    return this.cssText;
  }
};
var r8 = (t54) => new n7("string" == typeof t54 ? t54 : t54 + "", void 0, s4);
var S5 = (s33, o46) => {
  if (e8) s33.adoptedStyleSheets = o46.map((t54) => t54 instanceof CSSStyleSheet ? t54 : t54.styleSheet);
  else for (const e66 of o46) {
    const o55 = document.createElement("style"), n63 = t7.litNonce;
    void 0 !== n63 && o55.setAttribute("nonce", n63), o55.textContent = e66.cssText, s33.appendChild(o55);
  }
};
var c6 = e8 ? (t54) => t54 : (t54) => t54 instanceof CSSStyleSheet ? ((t64) => {
  let e66 = "";
  for (const s33 of t64.cssRules) e66 += s33.cssText;
  return r8(e66);
})(t54) : t54;
var { is: i24, defineProperty: e24, getOwnPropertyDescriptor: r24, getOwnPropertyNames: h6, getOwnPropertySymbols: o24, getPrototypeOf: n24 } = Object;
var a4 = globalThis;
var c24 = a4.trustedTypes;
var l4 = c24 ? c24.emptyScript : "";
var p4 = a4.reactiveElementPolyfillSupport;
var d4 = (t54, s33) => t54;
var u4 = { toAttribute(t54, s33) {
  switch (s33) {
    case Boolean:
      t54 = t54 ? l4 : null;
      break;
    case Object:
    case Array:
      t54 = null == t54 ? t54 : JSON.stringify(t54);
  }
  return t54;
}, fromAttribute(t54, s33) {
  let i43 = t54;
  switch (s33) {
    case Boolean:
      i43 = null !== t54;
      break;
    case Number:
      i43 = null === t54 ? null : Number(t54);
      break;
    case Object:
    case Array:
      try {
        i43 = JSON.parse(t54);
      } catch (t64) {
        i43 = null;
      }
  }
  return i43;
} };
var f6 = (t54, s33) => !i24(t54, s33);
var y4 = { attribute: true, type: String, converter: u4, reflect: false, hasChanged: f6 };
Symbol.metadata ??= Symbol("metadata"), a4.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b4 = class extends HTMLElement {
  static addInitializer(t54) {
    this._$Ei(), (this.l ??= []).push(t54);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t54, s33 = y4) {
    if (s33.state && (s33.attribute = false), this._$Ei(), this.elementProperties.set(t54, s33), !s33.noAccessor) {
      const i43 = Symbol(), r46 = this.getPropertyDescriptor(t54, i43, s33);
      void 0 !== r46 && e24(this.prototype, t54, r46);
    }
  }
  static getPropertyDescriptor(t54, s33, i43) {
    const { get: e66, set: h53 } = r24(this.prototype, t54) ?? { get() {
      return this[s33];
    }, set(t64) {
      this[s33] = t64;
    } };
    return { get() {
      return e66?.call(this);
    }, set(s43) {
      const r46 = e66?.call(this);
      h53.call(this, s43), this.requestUpdate(t54, r46, i43);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t54) {
    return this.elementProperties.get(t54) ?? y4;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d4("elementProperties"))) return;
    const t54 = n24(this);
    t54.finalize(), void 0 !== t54.l && (this.l = [...t54.l]), this.elementProperties = new Map(t54.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d4("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d4("properties"))) {
      const t64 = this.properties, s33 = [...h6(t64), ...o24(t64)];
      for (const i43 of s33) this.createProperty(i43, t64[i43]);
    }
    const t54 = this[Symbol.metadata];
    if (null !== t54) {
      const s33 = litPropertyMetadata.get(t54);
      if (void 0 !== s33) for (const [t64, i43] of s33) this.elementProperties.set(t64, i43);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t64, s33] of this.elementProperties) {
      const i43 = this._$Eu(t64, s33);
      void 0 !== i43 && this._$Eh.set(i43, t64);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s33) {
    const i43 = [];
    if (Array.isArray(s33)) {
      const e66 = new Set(s33.flat(1 / 0).reverse());
      for (const s43 of e66) i43.unshift(c6(s43));
    } else void 0 !== s33 && i43.push(c6(s33));
    return i43;
  }
  static _$Eu(t54, s33) {
    const i43 = s33.attribute;
    return false === i43 ? void 0 : "string" == typeof i43 ? i43 : "string" == typeof t54 ? t54.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t54) => this.enableUpdating = t54), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t54) => t54(this));
  }
  addController(t54) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t54), void 0 !== this.renderRoot && this.isConnected && t54.hostConnected?.();
  }
  removeController(t54) {
    this._$EO?.delete(t54);
  }
  _$E_() {
    const t54 = /* @__PURE__ */ new Map(), s33 = this.constructor.elementProperties;
    for (const i43 of s33.keys()) this.hasOwnProperty(i43) && (t54.set(i43, this[i43]), delete this[i43]);
    t54.size > 0 && (this._$Ep = t54);
  }
  createRenderRoot() {
    const t54 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S5(t54, this.constructor.elementStyles), t54;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t54) => t54.hostConnected?.());
  }
  enableUpdating(t54) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t54) => t54.hostDisconnected?.());
  }
  attributeChangedCallback(t54, s33, i43) {
    this._$AK(t54, i43);
  }
  _$EC(t54, s33) {
    const i43 = this.constructor.elementProperties.get(t54), e66 = this.constructor._$Eu(t54, i43);
    if (void 0 !== e66 && true === i43.reflect) {
      const r46 = (void 0 !== i43.converter?.toAttribute ? i43.converter : u4).toAttribute(s33, i43.type);
      this._$Em = t54, null == r46 ? this.removeAttribute(e66) : this.setAttribute(e66, r46), this._$Em = null;
    }
  }
  _$AK(t54, s33) {
    const i43 = this.constructor, e66 = i43._$Eh.get(t54);
    if (void 0 !== e66 && this._$Em !== e66) {
      const t64 = i43.getPropertyOptions(e66), r46 = "function" == typeof t64.converter ? { fromAttribute: t64.converter } : void 0 !== t64.converter?.fromAttribute ? t64.converter : u4;
      this._$Em = e66, this[e66] = r46.fromAttribute(s33, t64.type), this._$Em = null;
    }
  }
  requestUpdate(t54, s33, i43) {
    if (void 0 !== t54) {
      if (i43 ??= this.constructor.getPropertyOptions(t54), !(i43.hasChanged ?? f6)(this[t54], s33)) return;
      this.P(t54, s33, i43);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t54, s33, i43) {
    this._$AL.has(t54) || this._$AL.set(t54, s33), true === i43.reflect && this._$Em !== t54 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t54);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t64) {
      Promise.reject(t64);
    }
    const t54 = this.scheduleUpdate();
    return null != t54 && await t54, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t73, s43] of this._$Ep) this[t73] = s43;
        this._$Ep = void 0;
      }
      const t64 = this.constructor.elementProperties;
      if (t64.size > 0) for (const [s43, i43] of t64) true !== i43.wrapped || this._$AL.has(s43) || void 0 === this[s43] || this.P(s43, this[s43], i43);
    }
    let t54 = false;
    const s33 = this._$AL;
    try {
      t54 = this.shouldUpdate(s33), t54 ? (this.willUpdate(s33), this._$EO?.forEach((t64) => t64.hostUpdate?.()), this.update(s33)) : this._$EU();
    } catch (s43) {
      throw t54 = false, this._$EU(), s43;
    }
    t54 && this._$AE(s33);
  }
  willUpdate(t54) {
  }
  _$AE(t54) {
    this._$EO?.forEach((t64) => t64.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t54)), this.updated(t54);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t54) {
    return true;
  }
  update(t54) {
    this._$Ej &&= this._$Ej.forEach((t64) => this._$EC(t64, this[t64])), this._$EU();
  }
  updated(t54) {
  }
  firstUpdated(t54) {
  }
};
b4.elementStyles = [], b4.shadowRootOptions = { mode: "open" }, b4[d4("elementProperties")] = /* @__PURE__ */ new Map(), b4[d4("finalized")] = /* @__PURE__ */ new Map(), p4?.({ ReactiveElement: b4 }), (a4.reactiveElementVersions ??= []).push("2.0.4");
var n34 = globalThis;
var c34 = n34.trustedTypes;
var h24 = c34 ? c34.createPolicy("lit-html", { createHTML: (t54) => t54 }) : void 0;
var f24 = "$lit$";
var v4 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m4 = "?" + v4;
var _4 = `<${m4}>`;
var w4 = document;
var lt4 = () => w4.createComment("");
var st4 = (t54) => null === t54 || "object" != typeof t54 && "function" != typeof t54;
var g4 = Array.isArray;
var $4 = (t54) => g4(t54) || "function" == typeof t54?.[Symbol.iterator];
var x4 = "[ 	\n\f\r]";
var T4 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E4 = /-->/g;
var k4 = />/g;
var O4 = RegExp(`>|${x4}(?:([^\\s"'>=/]+)(${x4}*=${x4}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S24 = /'/g;
var j4 = /"/g;
var M4 = /^(?:script|style|textarea|title)$/i;
var P4 = (t54) => (i43, ...s33) => ({ _$litType$: t54, strings: i43, values: s33 });
var ke5 = P4(1);
var Oe5 = P4(2);
var Se5 = P4(3);
var R4 = Symbol.for("lit-noChange");
var D4 = Symbol.for("lit-nothing");
var V4 = /* @__PURE__ */ new WeakMap();
var I4 = w4.createTreeWalker(w4, 129);
function N4(t54, i43) {
  if (!g4(t54) || !t54.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h24 ? h24.createHTML(i43) : i43;
}
var U4 = (t54, i43) => {
  const s33 = t54.length - 1, e66 = [];
  let h53, o46 = 2 === i43 ? "<svg>" : 3 === i43 ? "<math>" : "", n63 = T4;
  for (let i53 = 0; i53 < s33; i53++) {
    const s43 = t54[i53];
    let r46, l33, c53 = -1, a33 = 0;
    for (; a33 < s43.length && (n63.lastIndex = a33, l33 = n63.exec(s43), null !== l33); ) a33 = n63.lastIndex, n63 === T4 ? "!--" === l33[1] ? n63 = E4 : void 0 !== l33[1] ? n63 = k4 : void 0 !== l33[2] ? (M4.test(l33[2]) && (h53 = RegExp("</" + l33[2], "g")), n63 = O4) : void 0 !== l33[3] && (n63 = O4) : n63 === O4 ? ">" === l33[0] ? (n63 = h53 ?? T4, c53 = -1) : void 0 === l33[1] ? c53 = -2 : (c53 = n63.lastIndex - l33[2].length, r46 = l33[1], n63 = void 0 === l33[3] ? O4 : '"' === l33[3] ? j4 : S24) : n63 === j4 || n63 === S24 ? n63 = O4 : n63 === E4 || n63 === k4 ? n63 = T4 : (n63 = O4, h53 = void 0);
    const u33 = n63 === O4 && t54[i53 + 1].startsWith("/>") ? " " : "";
    o46 += n63 === T4 ? s43 + _4 : c53 >= 0 ? (e66.push(r46), s43.slice(0, c53) + f24 + s43.slice(c53) + v4 + u33) : s43 + v4 + (-2 === c53 ? i53 : u33);
  }
  return [N4(t54, o46 + (t54[s33] || "<?>") + (2 === i43 ? "</svg>" : 3 === i43 ? "</math>" : "")), e66];
};
var B4 = class _B23 {
  constructor({ strings: t54, _$litType$: i43 }, s33) {
    let e66;
    this.parts = [];
    let h53 = 0, o46 = 0;
    const n63 = t54.length - 1, r46 = this.parts, [l33, a33] = U4(t54, i43);
    if (this.el = _B23.createElement(l33, s33), I4.currentNode = this.el.content, 2 === i43 || 3 === i43) {
      const t64 = this.el.content.firstChild;
      t64.replaceWith(...t64.childNodes);
    }
    for (; null !== (e66 = I4.nextNode()) && r46.length < n63; ) {
      if (1 === e66.nodeType) {
        if (e66.hasAttributes()) for (const t64 of e66.getAttributeNames()) if (t64.endsWith(f24)) {
          const i53 = a33[o46++], s43 = e66.getAttribute(t64).split(v4), n73 = /([.?@])?(.*)/.exec(i53);
          r46.push({ type: 1, index: h53, name: n73[2], strings: s43, ctor: "." === n73[1] ? Y4 : "?" === n73[1] ? Z4 : "@" === n73[1] ? q4 : G4 }), e66.removeAttribute(t64);
        } else t64.startsWith(v4) && (r46.push({ type: 6, index: h53 }), e66.removeAttribute(t64));
        if (M4.test(e66.tagName)) {
          const t64 = e66.textContent.split(v4), i53 = t64.length - 1;
          if (i53 > 0) {
            e66.textContent = c34 ? c34.emptyScript : "";
            for (let s43 = 0; s43 < i53; s43++) e66.append(t64[s43], lt4()), I4.nextNode(), r46.push({ type: 2, index: ++h53 });
            e66.append(t64[i53], lt4());
          }
        }
      } else if (8 === e66.nodeType) if (e66.data === m4) r46.push({ type: 2, index: h53 });
      else {
        let t64 = -1;
        for (; -1 !== (t64 = e66.data.indexOf(v4, t64 + 1)); ) r46.push({ type: 7, index: h53 }), t64 += v4.length - 1;
      }
      h53++;
    }
  }
  static createElement(t54, i43) {
    const s33 = w4.createElement("template");
    return s33.innerHTML = t54, s33;
  }
};
function z4(t54, i43, s33 = t54, e66) {
  if (i43 === R4) return i43;
  let h53 = void 0 !== e66 ? s33.o?.[e66] : s33.l;
  const o46 = st4(i43) ? void 0 : i43._$litDirective$;
  return h53?.constructor !== o46 && (h53?._$AO?.(false), void 0 === o46 ? h53 = void 0 : (h53 = new o46(t54), h53._$AT(t54, s33, e66)), void 0 !== e66 ? (s33.o ??= [])[e66] = h53 : s33.l = h53), void 0 !== h53 && (i43 = z4(t54, h53._$AS(t54, i43.values), h53, e66)), i43;
}
var F4 = class {
  constructor(t54, i43) {
    this._$AV = [], this._$AN = void 0, this._$AD = t54, this._$AM = i43;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t54) {
    const { el: { content: i43 }, parts: s33 } = this._$AD, e66 = (t54?.creationScope ?? w4).importNode(i43, true);
    I4.currentNode = e66;
    let h53 = I4.nextNode(), o46 = 0, n63 = 0, r46 = s33[0];
    for (; void 0 !== r46; ) {
      if (o46 === r46.index) {
        let i53;
        2 === r46.type ? i53 = new et5(h53, h53.nextSibling, this, t54) : 1 === r46.type ? i53 = new r46.ctor(h53, r46.name, r46.strings, this, t54) : 6 === r46.type && (i53 = new K4(h53, this, t54)), this._$AV.push(i53), r46 = s33[++n63];
      }
      o46 !== r46?.index && (h53 = I4.nextNode(), o46++);
    }
    return I4.currentNode = w4, e66;
  }
  p(t54) {
    let i43 = 0;
    for (const s33 of this._$AV) void 0 !== s33 && (void 0 !== s33.strings ? (s33._$AI(t54, s33, i43), i43 += s33.strings.length - 2) : s33._$AI(t54[i43])), i43++;
  }
};
var et5 = class _et23 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t54, i43, s33, e66) {
    this.type = 2, this._$AH = D4, this._$AN = void 0, this._$AA = t54, this._$AB = i43, this._$AM = s33, this.options = e66, this.v = e66?.isConnected ?? true;
  }
  get parentNode() {
    let t54 = this._$AA.parentNode;
    const i43 = this._$AM;
    return void 0 !== i43 && 11 === t54?.nodeType && (t54 = i43.parentNode), t54;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t54, i43 = this) {
    t54 = z4(this, t54, i43), st4(t54) ? t54 === D4 || null == t54 || "" === t54 ? (this._$AH !== D4 && this._$AR(), this._$AH = D4) : t54 !== this._$AH && t54 !== R4 && this._(t54) : void 0 !== t54._$litType$ ? this.$(t54) : void 0 !== t54.nodeType ? this.T(t54) : $4(t54) ? this.k(t54) : this._(t54);
  }
  O(t54) {
    return this._$AA.parentNode.insertBefore(t54, this._$AB);
  }
  T(t54) {
    this._$AH !== t54 && (this._$AR(), this._$AH = this.O(t54));
  }
  _(t54) {
    this._$AH !== D4 && st4(this._$AH) ? this._$AA.nextSibling.data = t54 : this.T(w4.createTextNode(t54)), this._$AH = t54;
  }
  $(t54) {
    const { values: i43, _$litType$: s33 } = t54, e66 = "number" == typeof s33 ? this._$AC(t54) : (void 0 === s33.el && (s33.el = B4.createElement(N4(s33.h, s33.h[0]), this.options)), s33);
    if (this._$AH?._$AD === e66) this._$AH.p(i43);
    else {
      const t64 = new F4(e66, this), s43 = t64.u(this.options);
      t64.p(i43), this.T(s43), this._$AH = t64;
    }
  }
  _$AC(t54) {
    let i43 = V4.get(t54.strings);
    return void 0 === i43 && V4.set(t54.strings, i43 = new B4(t54)), i43;
  }
  k(t54) {
    g4(this._$AH) || (this._$AH = [], this._$AR());
    const i43 = this._$AH;
    let s33, e66 = 0;
    for (const h53 of t54) e66 === i43.length ? i43.push(s33 = new _et23(this.O(lt4()), this.O(lt4()), this, this.options)) : s33 = i43[e66], s33._$AI(h53), e66++;
    e66 < i43.length && (this._$AR(s33 && s33._$AB.nextSibling, e66), i43.length = e66);
  }
  _$AR(t54 = this._$AA.nextSibling, i43) {
    for (this._$AP?.(false, true, i43); t54 && t54 !== this._$AB; ) {
      const i53 = t54.nextSibling;
      t54.remove(), t54 = i53;
    }
  }
  setConnected(t54) {
    void 0 === this._$AM && (this.v = t54, this._$AP?.(t54));
  }
};
var G4 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t54, i43, s33, e66, h53) {
    this.type = 1, this._$AH = D4, this._$AN = void 0, this.element = t54, this.name = i43, this._$AM = e66, this.options = h53, s33.length > 2 || "" !== s33[0] || "" !== s33[1] ? (this._$AH = Array(s33.length - 1).fill(new String()), this.strings = s33) : this._$AH = D4;
  }
  _$AI(t54, i43 = this, s33, e66) {
    const h53 = this.strings;
    let o46 = false;
    if (void 0 === h53) t54 = z4(this, t54, i43, 0), o46 = !st4(t54) || t54 !== this._$AH && t54 !== R4, o46 && (this._$AH = t54);
    else {
      const e73 = t54;
      let n63, r46;
      for (t54 = h53[0], n63 = 0; n63 < h53.length - 1; n63++) r46 = z4(this, e73[s33 + n63], i43, n63), r46 === R4 && (r46 = this._$AH[n63]), o46 ||= !st4(r46) || r46 !== this._$AH[n63], r46 === D4 ? t54 = D4 : t54 !== D4 && (t54 += (r46 ?? "") + h53[n63 + 1]), this._$AH[n63] = r46;
    }
    o46 && !e66 && this.j(t54);
  }
  j(t54) {
    t54 === D4 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t54 ?? "");
  }
};
var Y4 = class extends G4 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t54) {
    this.element[this.name] = t54 === D4 ? void 0 : t54;
  }
};
var Z4 = class extends G4 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t54) {
    this.element.toggleAttribute(this.name, !!t54 && t54 !== D4);
  }
};
var q4 = class extends G4 {
  constructor(t54, i43, s33, e66, h53) {
    super(t54, i43, s33, e66, h53), this.type = 5;
  }
  _$AI(t54, i43 = this) {
    if ((t54 = z4(this, t54, i43, 0) ?? D4) === R4) return;
    const s33 = this._$AH, e66 = t54 === D4 && s33 !== D4 || t54.capture !== s33.capture || t54.once !== s33.once || t54.passive !== s33.passive, h53 = t54 !== D4 && (s33 === D4 || e66);
    e66 && this.element.removeEventListener(this.name, this, s33), h53 && this.element.addEventListener(this.name, this, t54), this._$AH = t54;
  }
  handleEvent(t54) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t54) : this._$AH.handleEvent(t54);
  }
};
var K4 = class {
  constructor(t54, i43, s33) {
    this.element = t54, this.type = 6, this._$AN = void 0, this._$AM = i43, this.options = s33;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t54) {
    z4(this, t54);
  }
};
var Re4 = n34.litHtmlPolyfillSupport;
Re4?.(B4, et5), (n34.litHtmlVersions ??= []).push("3.2.0");
var Q4 = (t54, i43, s33) => {
  const e66 = s33?.renderBefore ?? i43;
  let h53 = e66._$litPart$;
  if (void 0 === h53) {
    const t64 = s33?.renderBefore ?? null;
    e66._$litPart$ = h53 = new et5(i43.insertBefore(lt4(), t64), t64, void 0, s33 ?? {});
  }
  return h53._$AI(t54), h53;
};
var h34 = class extends b4 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t54 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t54.firstChild, t54;
  }
  update(t54) {
    const e66 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t54), this.o = Q4(e66, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R4;
  }
};
h34._$litElement$ = true, h34["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h34 });
var f34 = globalThis.litElementPolyfillSupport;
f34?.({ LitElement: h34 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var __create23 = Object.create;
var __defProp23 = Object.defineProperty;
var __getOwnPropDesc23 = Object.getOwnPropertyDescriptor;
var __knownSymbol23 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError23 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name23 = (target, value) => __defProp23(target, "name", { value, configurable: true });
var __decoratorStart23 = (base) => [, , , __create23(base?.[__knownSymbol23("metadata")] ?? null)];
var __decoratorStrings23 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn23 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError23("Function expected") : fn;
var __decoratorContext23 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings23[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError23("Already initialized") : fns.push(__expectFn23(fn || null)) });
var __decoratorMetadata23 = (array, target) => __defNormalProp23(target, __knownSymbol23("metadata"), array[3]);
var __runInitializers23 = (array, flags, self2, value) => {
  for (var i322 = 0, fns = array[flags >> 1], n522 = fns && fns.length; i322 < n522; i322++) flags & 1 ? fns[i322].call(self2) : value = fns[i322].call(self2, value);
  return value;
};
var __decorateElement23 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k222 = flags & 7, s222 = !!(flags & 8), p222 = !!(flags & 16);
  var j222 = k222 > 3 ? array.length + 1 : k222 ? s222 ? 1 : 2 : 0, key = __decoratorStrings23[k222 + 5];
  var initializers = k222 > 3 && (array[j222 - 1] = []), extraInitializers = array[j222] || (array[j222] = []);
  var desc = k222 && (!p222 && !s222 && (target = target.prototype), k222 < 5 && (k222 > 3 || !p222) && __getOwnPropDesc23(k222 < 4 ? target : { get [name]() {
    return __privateGet23(this, extra);
  }, set [name](x222) {
    return __privateSet23(this, extra, x222);
  } }, name));
  k222 ? p222 && k222 < 4 && __name23(extra, (k222 > 2 ? "set " : k222 > 1 ? "get " : "") + name) : __name23(target, name);
  for (var i322 = decorators.length - 1; i322 >= 0; i322--) {
    ctx = __decoratorContext23(k222, name, done = {}, array[3], extraInitializers);
    if (k222) {
      ctx.static = s222, ctx.private = p222, access = ctx.access = { has: p222 ? (x222) => __privateIn23(target, x222) : (x222) => name in x222 };
      if (k222 ^ 3) access.get = p222 ? (x222) => (k222 ^ 1 ? __privateGet23 : __privateMethod23)(x222, target, k222 ^ 4 ? extra : desc.get) : (x222) => x222[name];
      if (k222 > 2) access.set = p222 ? (x222, y222) => __privateSet23(x222, target, y222, k222 ^ 4 ? extra : desc.set) : (x222, y222) => x222[name] = y222;
    }
    it = (0, decorators[i322])(k222 ? k222 < 4 ? p222 ? extra : desc[key] : k222 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k222 ^ 4 || it === void 0) __expectFn23(it) && (k222 > 4 ? initializers.unshift(it) : k222 ? p222 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError23("Object expected");
    else __expectFn23(fn = it.get) && (desc.get = fn), __expectFn23(fn = it.set) && (desc.set = fn), __expectFn23(fn = it.init) && initializers.unshift(fn);
  }
  return k222 || __decoratorMetadata23(array, target), desc && __defProp23(target, name, desc), p222 ? k222 ^ 4 ? extra : desc : target;
};
var __publicField4 = (obj, key, value) => __defNormalProp23(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck23 = (obj, member, msg) => member.has(obj) || __typeError23("Cannot " + msg);
var __privateIn23 = (member, obj) => Object(obj) !== obj ? __typeError23('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet23 = (obj, member, getter) => (__accessCheck23(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError23("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet23 = (obj, member, value, setter) => (__accessCheck23(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod23 = (obj, member, method) => (__accessCheck23(obj, member, "access private method"), method);
var t23 = globalThis;
var e33 = t23.ShadowRoot && (void 0 === t23.ShadyCSS || t23.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s23 = Symbol();
var o34 = /* @__PURE__ */ new WeakMap();
var n44 = class {
  constructor(t222, e422, o46) {
    if (this._$cssResult$ = true, o46 !== s23) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t222, this.t = e422;
  }
  get styleSheet() {
    let t222 = this.o;
    const s222 = this.t;
    if (e33 && void 0 === t222) {
      const e422 = void 0 !== s222 && 1 === s222.length;
      e422 && (t222 = o34.get(s222)), void 0 === t222 && ((this.o = t222 = new CSSStyleSheet()).replaceSync(this.cssText), e422 && o34.set(s222, t222));
    }
    return t222;
  }
  toString() {
    return this.cssText;
  }
};
var r34 = (t222) => new n44("string" == typeof t222 ? t222 : t222 + "", void 0, s23);
var S33 = (s222, o46) => {
  if (e33) s222.adoptedStyleSheets = o46.map((t222) => t222 instanceof CSSStyleSheet ? t222 : t222.styleSheet);
  else for (const e422 of o46) {
    const o55 = document.createElement("style"), n522 = t23.litNonce;
    void 0 !== n522 && o55.setAttribute("nonce", n522), o55.textContent = e422.cssText, s222.appendChild(o55);
  }
};
var c43 = e33 ? (t222) => t222 : (t222) => t222 instanceof CSSStyleSheet ? ((t322) => {
  let e422 = "";
  for (const s222 of t322.cssRules) e422 += s222.cssText;
  return r34(e422);
})(t222) : t222;
var { is: i223, defineProperty: e223, getOwnPropertyDescriptor: r223, getOwnPropertyNames: h43, getOwnPropertySymbols: o223, getPrototypeOf: n223 } = Object;
var a23 = globalThis;
var c223 = a23.trustedTypes;
var l23 = c223 ? c223.emptyScript : "";
var p23 = a23.reactiveElementPolyfillSupport;
var d23 = (t222, s222) => t222;
var u23 = { toAttribute(t222, s222) {
  switch (s222) {
    case Boolean:
      t222 = t222 ? l23 : null;
      break;
    case Object:
    case Array:
      t222 = null == t222 ? t222 : JSON.stringify(t222);
  }
  return t222;
}, fromAttribute(t222, s222) {
  let i322 = t222;
  switch (s222) {
    case Boolean:
      i322 = null !== t222;
      break;
    case Number:
      i322 = null === t222 ? null : Number(t222);
      break;
    case Object:
    case Array:
      try {
        i322 = JSON.parse(t222);
      } catch (t322) {
        i322 = null;
      }
  }
  return i322;
} };
var f43 = (t222, s222) => !i223(t222, s222);
var y23 = { attribute: true, type: String, converter: u23, reflect: false, hasChanged: f43 };
Symbol.metadata ??= Symbol("metadata"), a23.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b23 = class extends HTMLElement {
  static addInitializer(t222) {
    this._$Ei(), (this.l ??= []).push(t222);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t222, s222 = y23) {
    if (s222.state && (s222.attribute = false), this._$Ei(), this.elementProperties.set(t222, s222), !s222.noAccessor) {
      const i322 = Symbol(), r46 = this.getPropertyDescriptor(t222, i322, s222);
      void 0 !== r46 && e223(this.prototype, t222, r46);
    }
  }
  static getPropertyDescriptor(t222, s222, i322) {
    const { get: e422, set: h422 } = r223(this.prototype, t222) ?? { get() {
      return this[s222];
    }, set(t322) {
      this[s222] = t322;
    } };
    return { get() {
      return e422?.call(this);
    }, set(s33) {
      const r46 = e422?.call(this);
      h422.call(this, s33), this.requestUpdate(t222, r46, i322);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t222) {
    return this.elementProperties.get(t222) ?? y23;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d23("elementProperties"))) return;
    const t222 = n223(this);
    t222.finalize(), void 0 !== t222.l && (this.l = [...t222.l]), this.elementProperties = new Map(t222.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d23("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d23("properties"))) {
      const t322 = this.properties, s222 = [...h43(t322), ...o223(t322)];
      for (const i322 of s222) this.createProperty(i322, t322[i322]);
    }
    const t222 = this[Symbol.metadata];
    if (null !== t222) {
      const s222 = litPropertyMetadata.get(t222);
      if (void 0 !== s222) for (const [t322, i322] of s222) this.elementProperties.set(t322, i322);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t322, s222] of this.elementProperties) {
      const i322 = this._$Eu(t322, s222);
      void 0 !== i322 && this._$Eh.set(i322, t322);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s222) {
    const i322 = [];
    if (Array.isArray(s222)) {
      const e422 = new Set(s222.flat(1 / 0).reverse());
      for (const s33 of e422) i322.unshift(c43(s33));
    } else void 0 !== s222 && i322.push(c43(s222));
    return i322;
  }
  static _$Eu(t222, s222) {
    const i322 = s222.attribute;
    return false === i322 ? void 0 : "string" == typeof i322 ? i322 : "string" == typeof t222 ? t222.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t222) => this.enableUpdating = t222), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t222) => t222(this));
  }
  addController(t222) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t222), void 0 !== this.renderRoot && this.isConnected && t222.hostConnected?.();
  }
  removeController(t222) {
    this._$EO?.delete(t222);
  }
  _$E_() {
    const t222 = /* @__PURE__ */ new Map(), s222 = this.constructor.elementProperties;
    for (const i322 of s222.keys()) this.hasOwnProperty(i322) && (t222.set(i322, this[i322]), delete this[i322]);
    t222.size > 0 && (this._$Ep = t222);
  }
  createRenderRoot() {
    const t222 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S33(t222, this.constructor.elementStyles), t222;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t222) => t222.hostConnected?.());
  }
  enableUpdating(t222) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t222) => t222.hostDisconnected?.());
  }
  attributeChangedCallback(t222, s222, i322) {
    this._$AK(t222, i322);
  }
  _$EC(t222, s222) {
    const i322 = this.constructor.elementProperties.get(t222), e422 = this.constructor._$Eu(t222, i322);
    if (void 0 !== e422 && true === i322.reflect) {
      const r46 = (void 0 !== i322.converter?.toAttribute ? i322.converter : u23).toAttribute(s222, i322.type);
      this._$Em = t222, null == r46 ? this.removeAttribute(e422) : this.setAttribute(e422, r46), this._$Em = null;
    }
  }
  _$AK(t222, s222) {
    const i322 = this.constructor, e422 = i322._$Eh.get(t222);
    if (void 0 !== e422 && this._$Em !== e422) {
      const t322 = i322.getPropertyOptions(e422), r46 = "function" == typeof t322.converter ? { fromAttribute: t322.converter } : void 0 !== t322.converter?.fromAttribute ? t322.converter : u23;
      this._$Em = e422, this[e422] = r46.fromAttribute(s222, t322.type), this._$Em = null;
    }
  }
  requestUpdate(t222, s222, i322) {
    if (void 0 !== t222) {
      if (i322 ??= this.constructor.getPropertyOptions(t222), !(i322.hasChanged ?? f43)(this[t222], s222)) return;
      this.P(t222, s222, i322);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t222, s222, i322) {
    this._$AL.has(t222) || this._$AL.set(t222, s222), true === i322.reflect && this._$Em !== t222 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t222);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t322) {
      Promise.reject(t322);
    }
    const t222 = this.scheduleUpdate();
    return null != t222 && await t222, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t422, s33] of this._$Ep) this[t422] = s33;
        this._$Ep = void 0;
      }
      const t322 = this.constructor.elementProperties;
      if (t322.size > 0) for (const [s33, i322] of t322) true !== i322.wrapped || this._$AL.has(s33) || void 0 === this[s33] || this.P(s33, this[s33], i322);
    }
    let t222 = false;
    const s222 = this._$AL;
    try {
      t222 = this.shouldUpdate(s222), t222 ? (this.willUpdate(s222), this._$EO?.forEach((t322) => t322.hostUpdate?.()), this.update(s222)) : this._$EU();
    } catch (s33) {
      throw t222 = false, this._$EU(), s33;
    }
    t222 && this._$AE(s222);
  }
  willUpdate(t222) {
  }
  _$AE(t222) {
    this._$EO?.forEach((t322) => t322.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t222)), this.updated(t222);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t222) {
    return true;
  }
  update(t222) {
    this._$Ej &&= this._$Ej.forEach((t322) => this._$EC(t322, this[t322])), this._$EU();
  }
  updated(t222) {
  }
  firstUpdated(t222) {
  }
};
b23.elementStyles = [], b23.shadowRootOptions = { mode: "open" }, b23[d23("elementProperties")] = /* @__PURE__ */ new Map(), b23[d23("finalized")] = /* @__PURE__ */ new Map(), p23?.({ ReactiveElement: b23 }), (a23.reactiveElementVersions ??= []).push("2.0.4");
var n323 = globalThis;
var c323 = n323.trustedTypes;
var h223 = c323 ? c323.createPolicy("lit-html", { createHTML: (t222) => t222 }) : void 0;
var f223 = "$lit$";
var v23 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m23 = "?" + v23;
var _23 = `<${m23}>`;
var w23 = document;
var lt23 = () => w23.createComment("");
var st23 = (t222) => null === t222 || "object" != typeof t222 && "function" != typeof t222;
var g23 = Array.isArray;
var $23 = (t222) => g23(t222) || "function" == typeof t222?.[Symbol.iterator];
var x23 = "[ 	\n\f\r]";
var T23 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E23 = /-->/g;
var k23 = />/g;
var O23 = RegExp(`>|${x23}(?:([^\\s"'>=/]+)(${x23}*=${x23}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S223 = /'/g;
var j23 = /"/g;
var M23 = /^(?:script|style|textarea|title)$/i;
var P23 = (t222) => (i322, ...s222) => ({ _$litType$: t222, strings: i322, values: s222 });
var ke23 = P23(1);
var Oe23 = P23(2);
var Se23 = P23(3);
var R23 = Symbol.for("lit-noChange");
var D23 = Symbol.for("lit-nothing");
var V23 = /* @__PURE__ */ new WeakMap();
var I23 = w23.createTreeWalker(w23, 129);
function N23(t222, i322) {
  if (!g23(t222) || !t222.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h223 ? h223.createHTML(i322) : i322;
}
var U23 = (t222, i322) => {
  const s222 = t222.length - 1, e422 = [];
  let h422, o46 = 2 === i322 ? "<svg>" : 3 === i322 ? "<math>" : "", n522 = T23;
  for (let i43 = 0; i43 < s222; i43++) {
    const s33 = t222[i43];
    let r46, l222, c422 = -1, a222 = 0;
    for (; a222 < s33.length && (n522.lastIndex = a222, l222 = n522.exec(s33), null !== l222); ) a222 = n522.lastIndex, n522 === T23 ? "!--" === l222[1] ? n522 = E23 : void 0 !== l222[1] ? n522 = k23 : void 0 !== l222[2] ? (M23.test(l222[2]) && (h422 = RegExp("</" + l222[2], "g")), n522 = O23) : void 0 !== l222[3] && (n522 = O23) : n522 === O23 ? ">" === l222[0] ? (n522 = h422 ?? T23, c422 = -1) : void 0 === l222[1] ? c422 = -2 : (c422 = n522.lastIndex - l222[2].length, r46 = l222[1], n522 = void 0 === l222[3] ? O23 : '"' === l222[3] ? j23 : S223) : n522 === j23 || n522 === S223 ? n522 = O23 : n522 === E23 || n522 === k23 ? n522 = T23 : (n522 = O23, h422 = void 0);
    const u222 = n522 === O23 && t222[i43 + 1].startsWith("/>") ? " " : "";
    o46 += n522 === T23 ? s33 + _23 : c422 >= 0 ? (e422.push(r46), s33.slice(0, c422) + f223 + s33.slice(c422) + v23 + u222) : s33 + v23 + (-2 === c422 ? i43 : u222);
  }
  return [N23(t222, o46 + (t222[s222] || "<?>") + (2 === i322 ? "</svg>" : 3 === i322 ? "</math>" : "")), e422];
};
var B23 = class _B4 {
  constructor({ strings: t222, _$litType$: i322 }, s222) {
    let e422;
    this.parts = [];
    let h422 = 0, o46 = 0;
    const n522 = t222.length - 1, r46 = this.parts, [l222, a222] = U23(t222, i322);
    if (this.el = _B4.createElement(l222, s222), I23.currentNode = this.el.content, 2 === i322 || 3 === i322) {
      const t322 = this.el.content.firstChild;
      t322.replaceWith(...t322.childNodes);
    }
    for (; null !== (e422 = I23.nextNode()) && r46.length < n522; ) {
      if (1 === e422.nodeType) {
        if (e422.hasAttributes()) for (const t322 of e422.getAttributeNames()) if (t322.endsWith(f223)) {
          const i43 = a222[o46++], s33 = e422.getAttribute(t322).split(v23), n63 = /([.?@])?(.*)/.exec(i43);
          r46.push({ type: 1, index: h422, name: n63[2], strings: s33, ctor: "." === n63[1] ? Y23 : "?" === n63[1] ? Z23 : "@" === n63[1] ? q23 : G23 }), e422.removeAttribute(t322);
        } else t322.startsWith(v23) && (r46.push({ type: 6, index: h422 }), e422.removeAttribute(t322));
        if (M23.test(e422.tagName)) {
          const t322 = e422.textContent.split(v23), i43 = t322.length - 1;
          if (i43 > 0) {
            e422.textContent = c323 ? c323.emptyScript : "";
            for (let s33 = 0; s33 < i43; s33++) e422.append(t322[s33], lt23()), I23.nextNode(), r46.push({ type: 2, index: ++h422 });
            e422.append(t322[i43], lt23());
          }
        }
      } else if (8 === e422.nodeType) if (e422.data === m23) r46.push({ type: 2, index: h422 });
      else {
        let t322 = -1;
        for (; -1 !== (t322 = e422.data.indexOf(v23, t322 + 1)); ) r46.push({ type: 7, index: h422 }), t322 += v23.length - 1;
      }
      h422++;
    }
  }
  static createElement(t222, i322) {
    const s222 = w23.createElement("template");
    return s222.innerHTML = t222, s222;
  }
};
function z23(t222, i322, s222 = t222, e422) {
  if (i322 === R23) return i322;
  let h422 = void 0 !== e422 ? s222.o?.[e422] : s222.l;
  const o46 = st23(i322) ? void 0 : i322._$litDirective$;
  return h422?.constructor !== o46 && (h422?._$AO?.(false), void 0 === o46 ? h422 = void 0 : (h422 = new o46(t222), h422._$AT(t222, s222, e422)), void 0 !== e422 ? (s222.o ??= [])[e422] = h422 : s222.l = h422), void 0 !== h422 && (i322 = z23(t222, h422._$AS(t222, i322.values), h422, e422)), i322;
}
var F23 = class {
  constructor(t222, i322) {
    this._$AV = [], this._$AN = void 0, this._$AD = t222, this._$AM = i322;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t222) {
    const { el: { content: i322 }, parts: s222 } = this._$AD, e422 = (t222?.creationScope ?? w23).importNode(i322, true);
    I23.currentNode = e422;
    let h422 = I23.nextNode(), o46 = 0, n522 = 0, r46 = s222[0];
    for (; void 0 !== r46; ) {
      if (o46 === r46.index) {
        let i43;
        2 === r46.type ? i43 = new et23(h422, h422.nextSibling, this, t222) : 1 === r46.type ? i43 = new r46.ctor(h422, r46.name, r46.strings, this, t222) : 6 === r46.type && (i43 = new K23(h422, this, t222)), this._$AV.push(i43), r46 = s222[++n522];
      }
      o46 !== r46?.index && (h422 = I23.nextNode(), o46++);
    }
    return I23.currentNode = w23, e422;
  }
  p(t222) {
    let i322 = 0;
    for (const s222 of this._$AV) void 0 !== s222 && (void 0 !== s222.strings ? (s222._$AI(t222, s222, i322), i322 += s222.strings.length - 2) : s222._$AI(t222[i322])), i322++;
  }
};
var et23 = class _et4 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t222, i322, s222, e422) {
    this.type = 2, this._$AH = D23, this._$AN = void 0, this._$AA = t222, this._$AB = i322, this._$AM = s222, this.options = e422, this.v = e422?.isConnected ?? true;
  }
  get parentNode() {
    let t222 = this._$AA.parentNode;
    const i322 = this._$AM;
    return void 0 !== i322 && 11 === t222?.nodeType && (t222 = i322.parentNode), t222;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t222, i322 = this) {
    t222 = z23(this, t222, i322), st23(t222) ? t222 === D23 || null == t222 || "" === t222 ? (this._$AH !== D23 && this._$AR(), this._$AH = D23) : t222 !== this._$AH && t222 !== R23 && this._(t222) : void 0 !== t222._$litType$ ? this.$(t222) : void 0 !== t222.nodeType ? this.T(t222) : $23(t222) ? this.k(t222) : this._(t222);
  }
  O(t222) {
    return this._$AA.parentNode.insertBefore(t222, this._$AB);
  }
  T(t222) {
    this._$AH !== t222 && (this._$AR(), this._$AH = this.O(t222));
  }
  _(t222) {
    this._$AH !== D23 && st23(this._$AH) ? this._$AA.nextSibling.data = t222 : this.T(w23.createTextNode(t222)), this._$AH = t222;
  }
  $(t222) {
    const { values: i322, _$litType$: s222 } = t222, e422 = "number" == typeof s222 ? this._$AC(t222) : (void 0 === s222.el && (s222.el = B23.createElement(N23(s222.h, s222.h[0]), this.options)), s222);
    if (this._$AH?._$AD === e422) this._$AH.p(i322);
    else {
      const t322 = new F23(e422, this), s33 = t322.u(this.options);
      t322.p(i322), this.T(s33), this._$AH = t322;
    }
  }
  _$AC(t222) {
    let i322 = V23.get(t222.strings);
    return void 0 === i322 && V23.set(t222.strings, i322 = new B23(t222)), i322;
  }
  k(t222) {
    g23(this._$AH) || (this._$AH = [], this._$AR());
    const i322 = this._$AH;
    let s222, e422 = 0;
    for (const h422 of t222) e422 === i322.length ? i322.push(s222 = new _et4(this.O(lt23()), this.O(lt23()), this, this.options)) : s222 = i322[e422], s222._$AI(h422), e422++;
    e422 < i322.length && (this._$AR(s222 && s222._$AB.nextSibling, e422), i322.length = e422);
  }
  _$AR(t222 = this._$AA.nextSibling, i322) {
    for (this._$AP?.(false, true, i322); t222 && t222 !== this._$AB; ) {
      const i43 = t222.nextSibling;
      t222.remove(), t222 = i43;
    }
  }
  setConnected(t222) {
    void 0 === this._$AM && (this.v = t222, this._$AP?.(t222));
  }
};
var G23 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t222, i322, s222, e422, h422) {
    this.type = 1, this._$AH = D23, this._$AN = void 0, this.element = t222, this.name = i322, this._$AM = e422, this.options = h422, s222.length > 2 || "" !== s222[0] || "" !== s222[1] ? (this._$AH = Array(s222.length - 1).fill(new String()), this.strings = s222) : this._$AH = D23;
  }
  _$AI(t222, i322 = this, s222, e422) {
    const h422 = this.strings;
    let o46 = false;
    if (void 0 === h422) t222 = z23(this, t222, i322, 0), o46 = !st23(t222) || t222 !== this._$AH && t222 !== R23, o46 && (this._$AH = t222);
    else {
      const e522 = t222;
      let n522, r46;
      for (t222 = h422[0], n522 = 0; n522 < h422.length - 1; n522++) r46 = z23(this, e522[s222 + n522], i322, n522), r46 === R23 && (r46 = this._$AH[n522]), o46 ||= !st23(r46) || r46 !== this._$AH[n522], r46 === D23 ? t222 = D23 : t222 !== D23 && (t222 += (r46 ?? "") + h422[n522 + 1]), this._$AH[n522] = r46;
    }
    o46 && !e422 && this.j(t222);
  }
  j(t222) {
    t222 === D23 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t222 ?? "");
  }
};
var Y23 = class extends G23 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t222) {
    this.element[this.name] = t222 === D23 ? void 0 : t222;
  }
};
var Z23 = class extends G23 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t222) {
    this.element.toggleAttribute(this.name, !!t222 && t222 !== D23);
  }
};
var q23 = class extends G23 {
  constructor(t222, i322, s222, e422, h422) {
    super(t222, i322, s222, e422, h422), this.type = 5;
  }
  _$AI(t222, i322 = this) {
    if ((t222 = z23(this, t222, i322, 0) ?? D23) === R23) return;
    const s222 = this._$AH, e422 = t222 === D23 && s222 !== D23 || t222.capture !== s222.capture || t222.once !== s222.once || t222.passive !== s222.passive, h422 = t222 !== D23 && (s222 === D23 || e422);
    e422 && this.element.removeEventListener(this.name, this, s222), h422 && this.element.addEventListener(this.name, this, t222), this._$AH = t222;
  }
  handleEvent(t222) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t222) : this._$AH.handleEvent(t222);
  }
};
var K23 = class {
  constructor(t222, i322, s222) {
    this.element = t222, this.type = 6, this._$AN = void 0, this._$AM = i322, this.options = s222;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t222) {
    z23(this, t222);
  }
};
var Re23 = n323.litHtmlPolyfillSupport;
Re23?.(B23, et23), (n323.litHtmlVersions ??= []).push("3.2.0");
var Q23 = (t222, i322, s222) => {
  const e422 = s222?.renderBefore ?? i322;
  let h422 = e422._$litPart$;
  if (void 0 === h422) {
    const t322 = s222?.renderBefore ?? null;
    e422._$litPart$ = h422 = new et23(i322.insertBefore(lt23(), t322), t322, void 0, s222 ?? {});
  }
  return h422._$AI(t222), h422;
};
var h323 = class extends b23 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t222 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t222.firstChild, t222;
  }
  update(t222) {
    const e422 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t222), this.o = Q23(e422, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R23;
  }
};
h323._$litElement$ = true, h323["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h323 });
var f323 = globalThis.litElementPolyfillSupport;
f323?.({ LitElement: h323 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o323 = { attribute: true, type: String, converter: u23, reflect: false, hasChanged: f43 };
var r323 = (t222 = o323, e422, r46) => {
  const { kind: n522, metadata: i322 } = r46;
  let s222 = globalThis.litPropertyMetadata.get(i322);
  if (void 0 === s222 && globalThis.litPropertyMetadata.set(i322, s222 = /* @__PURE__ */ new Map()), s222.set(r46.name, t222), "accessor" === n522) {
    const { name: o46 } = r46;
    return { set(r56) {
      const n63 = e422.get.call(this);
      e422.set.call(this, r56), this.requestUpdate(o46, n63, t222);
    }, init(e522) {
      return void 0 !== e522 && this.P(o46, void 0, t222), e522;
    } };
  }
  if ("setter" === n522) {
    const { name: o46 } = r46;
    return function(r56) {
      const n63 = this[o46];
      e422.call(this, r56), this.requestUpdate(o46, n63, t222);
    };
  }
  throw Error("Unsupported decorator location: " + n522);
};
function n423(t222) {
  return (e422, o46) => "object" == typeof o46 ? r323(t222, e422, o46) : ((t322, e522, o55) => {
    const r46 = e522.hasOwnProperty(o55);
    return e522.constructor.createProperty(o55, r46 ? { ...t322, wrapped: true } : t322), r46 ? Object.getOwnPropertyDescriptor(e522, o55) : void 0;
  })(t222, e422, o46);
}
var appliedClassMixins3 = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied3(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins3.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin3(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied3(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins3.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version3 = "3.0.0";
var versions3 = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions3.includes(version3)) {
  versions3.push(version3);
}
var ScopedElementsMixinImplementation4 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version3;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry6) {
      this.constructor.__registry = registry6;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin4 = dedupeMixin3(ScopedElementsMixinImplementation4);
var ScopedElementsMixinImplementation23 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin4(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S33(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin23 = dedupeMixin3(ScopedElementsMixinImplementation23);
var _lang_dec3;
var _contentEditable_dec3;
var _a4;
var _init4;
var _contentEditable3;
var _lang3;
var LitElementWw3 = class extends (_a4 = ScopedElementsMixin23(h323), _contentEditable_dec3 = [n423({ type: String, attribute: true, reflect: true })], _lang_dec3 = [n423({ type: String, attribute: true, reflect: true })], _a4) {
  constructor() {
    super(...arguments);
    __publicField4(this, "options");
    __publicField4(this, "actions", {});
    __privateAdd5(this, _contentEditable3, __runInitializers23(_init4, 8, this)), __runInitializers23(_init4, 11, this);
    __privateAdd5(this, _lang3, __runInitializers23(_init4, 12, this)), __runInitializers23(_init4, 15, this);
    __publicField4(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k222) => this.setAttribute(k222, this.getAttribute(k222)));
  }
};
_init4 = __decoratorStart23(_a4);
_contentEditable3 = /* @__PURE__ */ new WeakMap();
_lang3 = /* @__PURE__ */ new WeakMap();
__decorateElement23(_init4, 4, "contentEditable", _contentEditable_dec3, LitElementWw3, _contentEditable3);
__decorateElement23(_init4, 4, "lang", _lang_dec3, LitElementWw3, _lang3);
__decoratorMetadata23(_init4, LitElementWw3);
__publicField4(LitElementWw3, "shadowRootOptions", { ...h323.shadowRootOptions });
__publicField4(LitElementWw3, "options", {});
__publicField4(LitElementWw3, "actions", {});
var t33 = (t54) => (e66, o46) => {
  void 0 !== o46 ? o46.addInitializer(() => {
    customElements.define(t54, e66);
  }) : customElements.define(t54, e66);
};
var t43 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e53 = (t54) => (...e66) => ({ _$litDirective$: t54, values: e66 });
var i33 = class {
  constructor(t54) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t54, e66, i43) {
    this.t = t54, this._$AM = e66, this.i = i43;
  }
  _$AS(t54, e66) {
    return this.update(t54, e66);
  }
  update(t54, e66) {
    return this.render(...e66);
  }
};
var ee2 = "important";
var ie2 = " !" + ee2;
var se2 = e53(class extends i33 {
  constructor(e66) {
    if (super(e66), e66.type !== t43.ATTRIBUTE || "style" !== e66.name || e66.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t54) {
    return Object.keys(t54).reduce((e66, r46) => {
      const s33 = t54[r46];
      return null == s33 ? e66 : e66 + `${r46 = r46.includes("-") ? r46 : r46.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s33};`;
    }, "");
  }
  update(t54, [e66]) {
    const { style: r46 } = t54.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(e66)), this.render(e66);
    for (const t64 of this.ft) null == e66[t64] && (this.ft.delete(t64), t64.includes("-") ? r46.removeProperty(t64) : r46[t64] = null);
    for (const t64 in e66) {
      const s33 = e66[t64];
      if (null != s33) {
        this.ft.add(t64);
        const e73 = "string" == typeof s33 && s33.endsWith(ie2);
        t64.includes("-") || e73 ? r46.setProperty(t64, e73 ? s33.slice(0, -11) : s33, e73 ? ee2 : "") : r46[t64] = s33;
      }
    }
    return R4;
  }
});
var _WebwriterTaskPrompt_decorators;
var _init23;
var _a23;
_WebwriterTaskPrompt_decorators = [t33("webwriter-task-prompt")];
var WebwriterTaskPrompt = class extends (_a23 = LitElementWw3) {
  render() {
    return ke5`<slot style=${se2({ "--ww-placeholder": `"Prompt"` })}>
      
    </slot>`;
  }
};
_init23 = __decoratorStart4(_a23);
WebwriterTaskPrompt = __decorateElement4(_init23, 0, "WebwriterTaskPrompt", _WebwriterTaskPrompt_decorators, WebwriterTaskPrompt);
__runInitializers4(_init23, 1, WebwriterTaskPrompt);

// https:/cdn.jsdelivr.net/npm/@webwriter/quiz@1.0.5/dist/widgets/webwriter-choice.js
var __create5 = Object.create;
var __defProp6 = Object.defineProperty;
var __getOwnPropDesc6 = Object.getOwnPropertyDescriptor;
var __knownSymbol5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name5 = (target, value) => __defProp6(target, "name", { value, configurable: true });
var __decoratorStart5 = (base) => [, , , __create5(base?.[__knownSymbol5("metadata")] ?? null)];
var __decoratorStrings5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn5 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError5("Function expected") : fn;
var __decoratorContext5 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings5[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError5("Already initialized") : fns.push(__expectFn5(fn || null)) });
var __decoratorMetadata5 = (array, target) => __defNormalProp6(target, __knownSymbol5("metadata"), array[3]);
var __runInitializers5 = (array, flags, self2, value) => {
  for (var i43 = 0, fns = array[flags >> 1], n63 = fns && fns.length; i43 < n63; i43++) flags & 1 ? fns[i43].call(self2) : value = fns[i43].call(self2, value);
  return value;
};
var __decorateElement5 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k33 = flags & 7, s33 = !!(flags & 8), p33 = !!(flags & 16);
  var j33 = k33 > 3 ? array.length + 1 : k33 ? s33 ? 1 : 2 : 0, key = __decoratorStrings5[k33 + 5];
  var initializers = k33 > 3 && (array[j33 - 1] = []), extraInitializers = array[j33] || (array[j33] = []);
  var desc = k33 && (!p33 && !s33 && (target = target.prototype), k33 < 5 && (k33 > 3 || !p33) && __getOwnPropDesc6(k33 < 4 ? target : { get [name]() {
    return __privateGet6(this, extra);
  }, set [name](x32) {
    return __privateSet6(this, extra, x32);
  } }, name));
  k33 ? p33 && k33 < 4 && __name5(extra, (k33 > 2 ? "set " : k33 > 1 ? "get " : "") + name) : __name5(target, name);
  for (var i43 = decorators.length - 1; i43 >= 0; i43--) {
    ctx = __decoratorContext5(k33, name, done = {}, array[3], extraInitializers);
    if (k33) {
      ctx.static = s33, ctx.private = p33, access = ctx.access = { has: p33 ? (x32) => __privateIn5(target, x32) : (x32) => name in x32 };
      if (k33 ^ 3) access.get = p33 ? (x32) => (k33 ^ 1 ? __privateGet6 : __privateMethod5)(x32, target, k33 ^ 4 ? extra : desc.get) : (x32) => x32[name];
      if (k33 > 2) access.set = p33 ? (x32, y33) => __privateSet6(x32, target, y33, k33 ^ 4 ? extra : desc.set) : (x32, y33) => x32[name] = y33;
    }
    it = (0, decorators[i43])(k33 ? k33 < 4 ? p33 ? extra : desc[key] : k33 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k33 ^ 4 || it === void 0) __expectFn5(it) && (k33 > 4 ? initializers.unshift(it) : k33 ? p33 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError5("Object expected");
    else __expectFn5(fn = it.get) && (desc.get = fn), __expectFn5(fn = it.set) && (desc.set = fn), __expectFn5(fn = it.init) && initializers.unshift(fn);
  }
  return k33 || __decoratorMetadata5(array, target), desc && __defProp6(target, name, desc), p33 ? k33 ^ 4 ? extra : desc : target;
};
var __publicField5 = (obj, key, value) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateIn5 = (member, obj) => Object(obj) !== obj ? __typeError5('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck6(obj, member, "access private method"), method);
var t8 = globalThis;
var e9 = t8.ShadowRoot && (void 0 === t8.ShadyCSS || t8.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s5 = Symbol();
var o9 = /* @__PURE__ */ new WeakMap();
var n8 = class {
  constructor(t54, e73, o64) {
    if (this._$cssResult$ = true, o64 !== s5) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t54, this.t = e73;
  }
  get styleSheet() {
    let t54 = this.o;
    const s33 = this.t;
    if (e9 && void 0 === t54) {
      const e73 = void 0 !== s33 && 1 === s33.length;
      e73 && (t54 = o9.get(s33)), void 0 === t54 && ((this.o = t54 = new CSSStyleSheet()).replaceSync(this.cssText), e73 && o9.set(s33, t54));
    }
    return t54;
  }
  toString() {
    return this.cssText;
  }
};
var r9 = (t54) => new n8("string" == typeof t54 ? t54 : t54 + "", void 0, s5);
var i5 = (t54, ...e73) => {
  const o64 = 1 === t54.length ? t54[0] : e73.reduce((e83, s33, o73) => e83 + ((t64) => {
    if (true === t64._$cssResult$) return t64.cssText;
    if ("number" == typeof t64) return t64;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t64 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s33) + t54[o73 + 1], t54[0]);
  return new n8(o64, t54, s5);
};
var S6 = (s33, o64) => {
  if (e9) s33.adoptedStyleSheets = o64.map((t54) => t54 instanceof CSSStyleSheet ? t54 : t54.styleSheet);
  else for (const e73 of o64) {
    const o73 = document.createElement("style"), n63 = t8.litNonce;
    void 0 !== n63 && o73.setAttribute("nonce", n63), o73.textContent = e73.cssText, s33.appendChild(o73);
  }
};
var c7 = e9 ? (t54) => t54 : (t54) => t54 instanceof CSSStyleSheet ? ((t64) => {
  let e73 = "";
  for (const s33 of t64.cssRules) e73 += s33.cssText;
  return r9(e73);
})(t54) : t54;
var { is: i25, defineProperty: e25, getOwnPropertyDescriptor: r25, getOwnPropertyNames: h7, getOwnPropertySymbols: o25, getPrototypeOf: n25 } = Object;
var a5 = globalThis;
var c25 = a5.trustedTypes;
var l5 = c25 ? c25.emptyScript : "";
var p5 = a5.reactiveElementPolyfillSupport;
var d5 = (t54, s33) => t54;
var u5 = { toAttribute(t54, s33) {
  switch (s33) {
    case Boolean:
      t54 = t54 ? l5 : null;
      break;
    case Object:
    case Array:
      t54 = null == t54 ? t54 : JSON.stringify(t54);
  }
  return t54;
}, fromAttribute(t54, s33) {
  let i43 = t54;
  switch (s33) {
    case Boolean:
      i43 = null !== t54;
      break;
    case Number:
      i43 = null === t54 ? null : Number(t54);
      break;
    case Object:
    case Array:
      try {
        i43 = JSON.parse(t54);
      } catch (t64) {
        i43 = null;
      }
  }
  return i43;
} };
var f7 = (t54, s33) => !i25(t54, s33);
var y5 = { attribute: true, type: String, converter: u5, reflect: false, hasChanged: f7 };
Symbol.metadata ??= Symbol("metadata"), a5.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b5 = class extends HTMLElement {
  static addInitializer(t54) {
    this._$Ei(), (this.l ??= []).push(t54);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t54, s33 = y5) {
    if (s33.state && (s33.attribute = false), this._$Ei(), this.elementProperties.set(t54, s33), !s33.noAccessor) {
      const i43 = Symbol(), r64 = this.getPropertyDescriptor(t54, i43, s33);
      void 0 !== r64 && e25(this.prototype, t54, r64);
    }
  }
  static getPropertyDescriptor(t54, s33, i43) {
    const { get: e73, set: h53 } = r25(this.prototype, t54) ?? { get() {
      return this[s33];
    }, set(t64) {
      this[s33] = t64;
    } };
    return { get() {
      return e73?.call(this);
    }, set(s43) {
      const r64 = e73?.call(this);
      h53.call(this, s43), this.requestUpdate(t54, r64, i43);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t54) {
    return this.elementProperties.get(t54) ?? y5;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d5("elementProperties"))) return;
    const t54 = n25(this);
    t54.finalize(), void 0 !== t54.l && (this.l = [...t54.l]), this.elementProperties = new Map(t54.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d5("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d5("properties"))) {
      const t64 = this.properties, s33 = [...h7(t64), ...o25(t64)];
      for (const i43 of s33) this.createProperty(i43, t64[i43]);
    }
    const t54 = this[Symbol.metadata];
    if (null !== t54) {
      const s33 = litPropertyMetadata.get(t54);
      if (void 0 !== s33) for (const [t64, i43] of s33) this.elementProperties.set(t64, i43);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t64, s33] of this.elementProperties) {
      const i43 = this._$Eu(t64, s33);
      void 0 !== i43 && this._$Eh.set(i43, t64);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s33) {
    const i43 = [];
    if (Array.isArray(s33)) {
      const e73 = new Set(s33.flat(1 / 0).reverse());
      for (const s43 of e73) i43.unshift(c7(s43));
    } else void 0 !== s33 && i43.push(c7(s33));
    return i43;
  }
  static _$Eu(t54, s33) {
    const i43 = s33.attribute;
    return false === i43 ? void 0 : "string" == typeof i43 ? i43 : "string" == typeof t54 ? t54.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t54) => this.enableUpdating = t54), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t54) => t54(this));
  }
  addController(t54) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t54), void 0 !== this.renderRoot && this.isConnected && t54.hostConnected?.();
  }
  removeController(t54) {
    this._$EO?.delete(t54);
  }
  _$E_() {
    const t54 = /* @__PURE__ */ new Map(), s33 = this.constructor.elementProperties;
    for (const i43 of s33.keys()) this.hasOwnProperty(i43) && (t54.set(i43, this[i43]), delete this[i43]);
    t54.size > 0 && (this._$Ep = t54);
  }
  createRenderRoot() {
    const t54 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S6(t54, this.constructor.elementStyles), t54;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t54) => t54.hostConnected?.());
  }
  enableUpdating(t54) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t54) => t54.hostDisconnected?.());
  }
  attributeChangedCallback(t54, s33, i43) {
    this._$AK(t54, i43);
  }
  _$EC(t54, s33) {
    const i43 = this.constructor.elementProperties.get(t54), e73 = this.constructor._$Eu(t54, i43);
    if (void 0 !== e73 && true === i43.reflect) {
      const r64 = (void 0 !== i43.converter?.toAttribute ? i43.converter : u5).toAttribute(s33, i43.type);
      this._$Em = t54, null == r64 ? this.removeAttribute(e73) : this.setAttribute(e73, r64), this._$Em = null;
    }
  }
  _$AK(t54, s33) {
    const i43 = this.constructor, e73 = i43._$Eh.get(t54);
    if (void 0 !== e73 && this._$Em !== e73) {
      const t64 = i43.getPropertyOptions(e73), r64 = "function" == typeof t64.converter ? { fromAttribute: t64.converter } : void 0 !== t64.converter?.fromAttribute ? t64.converter : u5;
      this._$Em = e73, this[e73] = r64.fromAttribute(s33, t64.type), this._$Em = null;
    }
  }
  requestUpdate(t54, s33, i43) {
    if (void 0 !== t54) {
      if (i43 ??= this.constructor.getPropertyOptions(t54), !(i43.hasChanged ?? f7)(this[t54], s33)) return;
      this.P(t54, s33, i43);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t54, s33, i43) {
    this._$AL.has(t54) || this._$AL.set(t54, s33), true === i43.reflect && this._$Em !== t54 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t54);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t64) {
      Promise.reject(t64);
    }
    const t54 = this.scheduleUpdate();
    return null != t54 && await t54, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t73, s43] of this._$Ep) this[t73] = s43;
        this._$Ep = void 0;
      }
      const t64 = this.constructor.elementProperties;
      if (t64.size > 0) for (const [s43, i43] of t64) true !== i43.wrapped || this._$AL.has(s43) || void 0 === this[s43] || this.P(s43, this[s43], i43);
    }
    let t54 = false;
    const s33 = this._$AL;
    try {
      t54 = this.shouldUpdate(s33), t54 ? (this.willUpdate(s33), this._$EO?.forEach((t64) => t64.hostUpdate?.()), this.update(s33)) : this._$EU();
    } catch (s43) {
      throw t54 = false, this._$EU(), s43;
    }
    t54 && this._$AE(s33);
  }
  willUpdate(t54) {
  }
  _$AE(t54) {
    this._$EO?.forEach((t64) => t64.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t54)), this.updated(t54);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t54) {
    return true;
  }
  update(t54) {
    this._$Ej &&= this._$Ej.forEach((t64) => this._$EC(t64, this[t64])), this._$EU();
  }
  updated(t54) {
  }
  firstUpdated(t54) {
  }
};
b5.elementStyles = [], b5.shadowRootOptions = { mode: "open" }, b5[d5("elementProperties")] = /* @__PURE__ */ new Map(), b5[d5("finalized")] = /* @__PURE__ */ new Map(), p5?.({ ReactiveElement: b5 }), (a5.reactiveElementVersions ??= []).push("2.0.4");
var n35 = globalThis;
var c35 = n35.trustedTypes;
var h25 = c35 ? c35.createPolicy("lit-html", { createHTML: (t54) => t54 }) : void 0;
var f25 = "$lit$";
var v5 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m5 = "?" + v5;
var _5 = `<${m5}>`;
var w5 = document;
var lt5 = () => w5.createComment("");
var st5 = (t54) => null === t54 || "object" != typeof t54 && "function" != typeof t54;
var g5 = Array.isArray;
var $5 = (t54) => g5(t54) || "function" == typeof t54?.[Symbol.iterator];
var x5 = "[ 	\n\f\r]";
var T5 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E5 = /-->/g;
var k5 = />/g;
var O5 = RegExp(`>|${x5}(?:([^\\s"'>=/]+)(${x5}*=${x5}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S25 = /'/g;
var j5 = /"/g;
var M5 = /^(?:script|style|textarea|title)$/i;
var P5 = (t54) => (i43, ...s33) => ({ _$litType$: t54, strings: i43, values: s33 });
var ke6 = P5(1);
var Oe6 = P5(2);
var Se6 = P5(3);
var R5 = Symbol.for("lit-noChange");
var D5 = Symbol.for("lit-nothing");
var V5 = /* @__PURE__ */ new WeakMap();
var I5 = w5.createTreeWalker(w5, 129);
function N5(t54, i43) {
  if (!g5(t54) || !t54.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h25 ? h25.createHTML(i43) : i43;
}
var U5 = (t54, i43) => {
  const s33 = t54.length - 1, e73 = [];
  let h53, o64 = 2 === i43 ? "<svg>" : 3 === i43 ? "<math>" : "", n63 = T5;
  for (let i53 = 0; i53 < s33; i53++) {
    const s43 = t54[i53];
    let r64, l33, c53 = -1, a33 = 0;
    for (; a33 < s43.length && (n63.lastIndex = a33, l33 = n63.exec(s43), null !== l33); ) a33 = n63.lastIndex, n63 === T5 ? "!--" === l33[1] ? n63 = E5 : void 0 !== l33[1] ? n63 = k5 : void 0 !== l33[2] ? (M5.test(l33[2]) && (h53 = RegExp("</" + l33[2], "g")), n63 = O5) : void 0 !== l33[3] && (n63 = O5) : n63 === O5 ? ">" === l33[0] ? (n63 = h53 ?? T5, c53 = -1) : void 0 === l33[1] ? c53 = -2 : (c53 = n63.lastIndex - l33[2].length, r64 = l33[1], n63 = void 0 === l33[3] ? O5 : '"' === l33[3] ? j5 : S25) : n63 === j5 || n63 === S25 ? n63 = O5 : n63 === E5 || n63 === k5 ? n63 = T5 : (n63 = O5, h53 = void 0);
    const u33 = n63 === O5 && t54[i53 + 1].startsWith("/>") ? " " : "";
    o64 += n63 === T5 ? s43 + _5 : c53 >= 0 ? (e73.push(r64), s43.slice(0, c53) + f25 + s43.slice(c53) + v5 + u33) : s43 + v5 + (-2 === c53 ? i53 : u33);
  }
  return [N5(t54, o64 + (t54[s33] || "<?>") + (2 === i43 ? "</svg>" : 3 === i43 ? "</math>" : "")), e73];
};
var B5 = class _B24 {
  constructor({ strings: t54, _$litType$: i43 }, s33) {
    let e73;
    this.parts = [];
    let h53 = 0, o64 = 0;
    const n63 = t54.length - 1, r64 = this.parts, [l33, a33] = U5(t54, i43);
    if (this.el = _B24.createElement(l33, s33), I5.currentNode = this.el.content, 2 === i43 || 3 === i43) {
      const t64 = this.el.content.firstChild;
      t64.replaceWith(...t64.childNodes);
    }
    for (; null !== (e73 = I5.nextNode()) && r64.length < n63; ) {
      if (1 === e73.nodeType) {
        if (e73.hasAttributes()) for (const t64 of e73.getAttributeNames()) if (t64.endsWith(f25)) {
          const i53 = a33[o64++], s43 = e73.getAttribute(t64).split(v5), n73 = /([.?@])?(.*)/.exec(i53);
          r64.push({ type: 1, index: h53, name: n73[2], strings: s43, ctor: "." === n73[1] ? Y5 : "?" === n73[1] ? Z5 : "@" === n73[1] ? q5 : G5 }), e73.removeAttribute(t64);
        } else t64.startsWith(v5) && (r64.push({ type: 6, index: h53 }), e73.removeAttribute(t64));
        if (M5.test(e73.tagName)) {
          const t64 = e73.textContent.split(v5), i53 = t64.length - 1;
          if (i53 > 0) {
            e73.textContent = c35 ? c35.emptyScript : "";
            for (let s43 = 0; s43 < i53; s43++) e73.append(t64[s43], lt5()), I5.nextNode(), r64.push({ type: 2, index: ++h53 });
            e73.append(t64[i53], lt5());
          }
        }
      } else if (8 === e73.nodeType) if (e73.data === m5) r64.push({ type: 2, index: h53 });
      else {
        let t64 = -1;
        for (; -1 !== (t64 = e73.data.indexOf(v5, t64 + 1)); ) r64.push({ type: 7, index: h53 }), t64 += v5.length - 1;
      }
      h53++;
    }
  }
  static createElement(t54, i43) {
    const s33 = w5.createElement("template");
    return s33.innerHTML = t54, s33;
  }
};
function z5(t54, i43, s33 = t54, e73) {
  if (i43 === R5) return i43;
  let h53 = void 0 !== e73 ? s33.o?.[e73] : s33.l;
  const o64 = st5(i43) ? void 0 : i43._$litDirective$;
  return h53?.constructor !== o64 && (h53?._$AO?.(false), void 0 === o64 ? h53 = void 0 : (h53 = new o64(t54), h53._$AT(t54, s33, e73)), void 0 !== e73 ? (s33.o ??= [])[e73] = h53 : s33.l = h53), void 0 !== h53 && (i43 = z5(t54, h53._$AS(t54, i43.values), h53, e73)), i43;
}
var F5 = class {
  constructor(t54, i43) {
    this._$AV = [], this._$AN = void 0, this._$AD = t54, this._$AM = i43;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t54) {
    const { el: { content: i43 }, parts: s33 } = this._$AD, e73 = (t54?.creationScope ?? w5).importNode(i43, true);
    I5.currentNode = e73;
    let h53 = I5.nextNode(), o64 = 0, n63 = 0, r64 = s33[0];
    for (; void 0 !== r64; ) {
      if (o64 === r64.index) {
        let i53;
        2 === r64.type ? i53 = new et6(h53, h53.nextSibling, this, t54) : 1 === r64.type ? i53 = new r64.ctor(h53, r64.name, r64.strings, this, t54) : 6 === r64.type && (i53 = new K5(h53, this, t54)), this._$AV.push(i53), r64 = s33[++n63];
      }
      o64 !== r64?.index && (h53 = I5.nextNode(), o64++);
    }
    return I5.currentNode = w5, e73;
  }
  p(t54) {
    let i43 = 0;
    for (const s33 of this._$AV) void 0 !== s33 && (void 0 !== s33.strings ? (s33._$AI(t54, s33, i43), i43 += s33.strings.length - 2) : s33._$AI(t54[i43])), i43++;
  }
};
var et6 = class _et24 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t54, i43, s33, e73) {
    this.type = 2, this._$AH = D5, this._$AN = void 0, this._$AA = t54, this._$AB = i43, this._$AM = s33, this.options = e73, this.v = e73?.isConnected ?? true;
  }
  get parentNode() {
    let t54 = this._$AA.parentNode;
    const i43 = this._$AM;
    return void 0 !== i43 && 11 === t54?.nodeType && (t54 = i43.parentNode), t54;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t54, i43 = this) {
    t54 = z5(this, t54, i43), st5(t54) ? t54 === D5 || null == t54 || "" === t54 ? (this._$AH !== D5 && this._$AR(), this._$AH = D5) : t54 !== this._$AH && t54 !== R5 && this._(t54) : void 0 !== t54._$litType$ ? this.$(t54) : void 0 !== t54.nodeType ? this.T(t54) : $5(t54) ? this.k(t54) : this._(t54);
  }
  O(t54) {
    return this._$AA.parentNode.insertBefore(t54, this._$AB);
  }
  T(t54) {
    this._$AH !== t54 && (this._$AR(), this._$AH = this.O(t54));
  }
  _(t54) {
    this._$AH !== D5 && st5(this._$AH) ? this._$AA.nextSibling.data = t54 : this.T(w5.createTextNode(t54)), this._$AH = t54;
  }
  $(t54) {
    const { values: i43, _$litType$: s33 } = t54, e73 = "number" == typeof s33 ? this._$AC(t54) : (void 0 === s33.el && (s33.el = B5.createElement(N5(s33.h, s33.h[0]), this.options)), s33);
    if (this._$AH?._$AD === e73) this._$AH.p(i43);
    else {
      const t64 = new F5(e73, this), s43 = t64.u(this.options);
      t64.p(i43), this.T(s43), this._$AH = t64;
    }
  }
  _$AC(t54) {
    let i43 = V5.get(t54.strings);
    return void 0 === i43 && V5.set(t54.strings, i43 = new B5(t54)), i43;
  }
  k(t54) {
    g5(this._$AH) || (this._$AH = [], this._$AR());
    const i43 = this._$AH;
    let s33, e73 = 0;
    for (const h53 of t54) e73 === i43.length ? i43.push(s33 = new _et24(this.O(lt5()), this.O(lt5()), this, this.options)) : s33 = i43[e73], s33._$AI(h53), e73++;
    e73 < i43.length && (this._$AR(s33 && s33._$AB.nextSibling, e73), i43.length = e73);
  }
  _$AR(t54 = this._$AA.nextSibling, i43) {
    for (this._$AP?.(false, true, i43); t54 && t54 !== this._$AB; ) {
      const i53 = t54.nextSibling;
      t54.remove(), t54 = i53;
    }
  }
  setConnected(t54) {
    void 0 === this._$AM && (this.v = t54, this._$AP?.(t54));
  }
};
var G5 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t54, i43, s33, e73, h53) {
    this.type = 1, this._$AH = D5, this._$AN = void 0, this.element = t54, this.name = i43, this._$AM = e73, this.options = h53, s33.length > 2 || "" !== s33[0] || "" !== s33[1] ? (this._$AH = Array(s33.length - 1).fill(new String()), this.strings = s33) : this._$AH = D5;
  }
  _$AI(t54, i43 = this, s33, e73) {
    const h53 = this.strings;
    let o64 = false;
    if (void 0 === h53) t54 = z5(this, t54, i43, 0), o64 = !st5(t54) || t54 !== this._$AH && t54 !== R5, o64 && (this._$AH = t54);
    else {
      const e83 = t54;
      let n63, r64;
      for (t54 = h53[0], n63 = 0; n63 < h53.length - 1; n63++) r64 = z5(this, e83[s33 + n63], i43, n63), r64 === R5 && (r64 = this._$AH[n63]), o64 ||= !st5(r64) || r64 !== this._$AH[n63], r64 === D5 ? t54 = D5 : t54 !== D5 && (t54 += (r64 ?? "") + h53[n63 + 1]), this._$AH[n63] = r64;
    }
    o64 && !e73 && this.j(t54);
  }
  j(t54) {
    t54 === D5 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t54 ?? "");
  }
};
var Y5 = class extends G5 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t54) {
    this.element[this.name] = t54 === D5 ? void 0 : t54;
  }
};
var Z5 = class extends G5 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t54) {
    this.element.toggleAttribute(this.name, !!t54 && t54 !== D5);
  }
};
var q5 = class extends G5 {
  constructor(t54, i43, s33, e73, h53) {
    super(t54, i43, s33, e73, h53), this.type = 5;
  }
  _$AI(t54, i43 = this) {
    if ((t54 = z5(this, t54, i43, 0) ?? D5) === R5) return;
    const s33 = this._$AH, e73 = t54 === D5 && s33 !== D5 || t54.capture !== s33.capture || t54.once !== s33.once || t54.passive !== s33.passive, h53 = t54 !== D5 && (s33 === D5 || e73);
    e73 && this.element.removeEventListener(this.name, this, s33), h53 && this.element.addEventListener(this.name, this, t54), this._$AH = t54;
  }
  handleEvent(t54) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t54) : this._$AH.handleEvent(t54);
  }
};
var K5 = class {
  constructor(t54, i43, s33) {
    this.element = t54, this.type = 6, this._$AN = void 0, this._$AM = i43, this.options = s33;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t54) {
    z5(this, t54);
  }
};
var si3 = { M: f25, P: v5, A: m5, C: 1, L: U5, R: F5, D: $5, V: z5, I: et6, H: G5, N: Z5, U: q5, B: Y5, F: K5 };
var Re5 = n35.litHtmlPolyfillSupport;
Re5?.(B5, et6), (n35.litHtmlVersions ??= []).push("3.2.0");
var Q5 = (t54, i43, s33) => {
  const e73 = s33?.renderBefore ?? i43;
  let h53 = e73._$litPart$;
  if (void 0 === h53) {
    const t64 = s33?.renderBefore ?? null;
    e73._$litPart$ = h53 = new et6(i43.insertBefore(lt5(), t64), t64, void 0, s33 ?? {});
  }
  return h53._$AI(t54), h53;
};
var h35 = class extends b5 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t54 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t54.firstChild, t54;
  }
  update(t54) {
    const e73 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t54), this.o = Q5(e73, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R5;
  }
};
h35._$litElement$ = true, h35["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h35 });
var f35 = globalThis.litElementPolyfillSupport;
f35?.({ LitElement: h35 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var __create24 = Object.create;
var __defProp24 = Object.defineProperty;
var __getOwnPropDesc24 = Object.getOwnPropertyDescriptor;
var __knownSymbol24 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError24 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp24 = (obj, key, value) => key in obj ? __defProp24(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name24 = (target, value) => __defProp24(target, "name", { value, configurable: true });
var __decoratorStart24 = (base) => [, , , __create24(base?.[__knownSymbol24("metadata")] ?? null)];
var __decoratorStrings24 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn24 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError24("Function expected") : fn;
var __decoratorContext24 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings24[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError24("Already initialized") : fns.push(__expectFn24(fn || null)) });
var __decoratorMetadata24 = (array, target) => __defNormalProp24(target, __knownSymbol24("metadata"), array[3]);
var __runInitializers24 = (array, flags, self2, value) => {
  for (var i322 = 0, fns = array[flags >> 1], n522 = fns && fns.length; i322 < n522; i322++) flags & 1 ? fns[i322].call(self2) : value = fns[i322].call(self2, value);
  return value;
};
var __decorateElement24 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k222 = flags & 7, s222 = !!(flags & 8), p222 = !!(flags & 16);
  var j222 = k222 > 3 ? array.length + 1 : k222 ? s222 ? 1 : 2 : 0, key = __decoratorStrings24[k222 + 5];
  var initializers = k222 > 3 && (array[j222 - 1] = []), extraInitializers = array[j222] || (array[j222] = []);
  var desc = k222 && (!p222 && !s222 && (target = target.prototype), k222 < 5 && (k222 > 3 || !p222) && __getOwnPropDesc24(k222 < 4 ? target : { get [name]() {
    return __privateGet24(this, extra);
  }, set [name](x222) {
    return __privateSet24(this, extra, x222);
  } }, name));
  k222 ? p222 && k222 < 4 && __name24(extra, (k222 > 2 ? "set " : k222 > 1 ? "get " : "") + name) : __name24(target, name);
  for (var i322 = decorators.length - 1; i322 >= 0; i322--) {
    ctx = __decoratorContext24(k222, name, done = {}, array[3], extraInitializers);
    if (k222) {
      ctx.static = s222, ctx.private = p222, access = ctx.access = { has: p222 ? (x222) => __privateIn24(target, x222) : (x222) => name in x222 };
      if (k222 ^ 3) access.get = p222 ? (x222) => (k222 ^ 1 ? __privateGet24 : __privateMethod24)(x222, target, k222 ^ 4 ? extra : desc.get) : (x222) => x222[name];
      if (k222 > 2) access.set = p222 ? (x222, y222) => __privateSet24(x222, target, y222, k222 ^ 4 ? extra : desc.set) : (x222, y222) => x222[name] = y222;
    }
    it = (0, decorators[i322])(k222 ? k222 < 4 ? p222 ? extra : desc[key] : k222 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k222 ^ 4 || it === void 0) __expectFn24(it) && (k222 > 4 ? initializers.unshift(it) : k222 ? p222 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError24("Object expected");
    else __expectFn24(fn = it.get) && (desc.get = fn), __expectFn24(fn = it.set) && (desc.set = fn), __expectFn24(fn = it.init) && initializers.unshift(fn);
  }
  return k222 || __decoratorMetadata24(array, target), desc && __defProp24(target, name, desc), p222 ? k222 ^ 4 ? extra : desc : target;
};
var __publicField23 = (obj, key, value) => __defNormalProp24(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck24 = (obj, member, msg) => member.has(obj) || __typeError24("Cannot " + msg);
var __privateIn24 = (member, obj) => Object(obj) !== obj ? __typeError24('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet24 = (obj, member, getter) => (__accessCheck24(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd23 = (obj, member, value) => member.has(obj) ? __typeError24("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet24 = (obj, member, value, setter) => (__accessCheck24(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod24 = (obj, member, method) => (__accessCheck24(obj, member, "access private method"), method);
var t24 = globalThis;
var e34 = t24.ShadowRoot && (void 0 === t24.ShadyCSS || t24.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s24 = Symbol();
var o35 = /* @__PURE__ */ new WeakMap();
var n45 = class {
  constructor(t222, e422, o422) {
    if (this._$cssResult$ = true, o422 !== s24) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t222, this.t = e422;
  }
  get styleSheet() {
    let t222 = this.o;
    const s222 = this.t;
    if (e34 && void 0 === t222) {
      const e422 = void 0 !== s222 && 1 === s222.length;
      e422 && (t222 = o35.get(s222)), void 0 === t222 && ((this.o = t222 = new CSSStyleSheet()).replaceSync(this.cssText), e422 && o35.set(s222, t222));
    }
    return t222;
  }
  toString() {
    return this.cssText;
  }
};
var r35 = (t222) => new n45("string" == typeof t222 ? t222 : t222 + "", void 0, s24);
var S34 = (s222, o422) => {
  if (e34) s222.adoptedStyleSheets = o422.map((t222) => t222 instanceof CSSStyleSheet ? t222 : t222.styleSheet);
  else for (const e422 of o422) {
    const o522 = document.createElement("style"), n522 = t24.litNonce;
    void 0 !== n522 && o522.setAttribute("nonce", n522), o522.textContent = e422.cssText, s222.appendChild(o522);
  }
};
var c44 = e34 ? (t222) => t222 : (t222) => t222 instanceof CSSStyleSheet ? ((t322) => {
  let e422 = "";
  for (const s222 of t322.cssRules) e422 += s222.cssText;
  return r35(e422);
})(t222) : t222;
var { is: i224, defineProperty: e224, getOwnPropertyDescriptor: r224, getOwnPropertyNames: h44, getOwnPropertySymbols: o224, getPrototypeOf: n224 } = Object;
var a24 = globalThis;
var c224 = a24.trustedTypes;
var l24 = c224 ? c224.emptyScript : "";
var p24 = a24.reactiveElementPolyfillSupport;
var d24 = (t222, s222) => t222;
var u24 = { toAttribute(t222, s222) {
  switch (s222) {
    case Boolean:
      t222 = t222 ? l24 : null;
      break;
    case Object:
    case Array:
      t222 = null == t222 ? t222 : JSON.stringify(t222);
  }
  return t222;
}, fromAttribute(t222, s222) {
  let i322 = t222;
  switch (s222) {
    case Boolean:
      i322 = null !== t222;
      break;
    case Number:
      i322 = null === t222 ? null : Number(t222);
      break;
    case Object:
    case Array:
      try {
        i322 = JSON.parse(t222);
      } catch (t322) {
        i322 = null;
      }
  }
  return i322;
} };
var f44 = (t222, s222) => !i224(t222, s222);
var y24 = { attribute: true, type: String, converter: u24, reflect: false, hasChanged: f44 };
Symbol.metadata ??= Symbol("metadata"), a24.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b24 = class extends HTMLElement {
  static addInitializer(t222) {
    this._$Ei(), (this.l ??= []).push(t222);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t222, s222 = y24) {
    if (s222.state && (s222.attribute = false), this._$Ei(), this.elementProperties.set(t222, s222), !s222.noAccessor) {
      const i322 = Symbol(), r422 = this.getPropertyDescriptor(t222, i322, s222);
      void 0 !== r422 && e224(this.prototype, t222, r422);
    }
  }
  static getPropertyDescriptor(t222, s222, i322) {
    const { get: e422, set: h422 } = r224(this.prototype, t222) ?? { get() {
      return this[s222];
    }, set(t322) {
      this[s222] = t322;
    } };
    return { get() {
      return e422?.call(this);
    }, set(s33) {
      const r422 = e422?.call(this);
      h422.call(this, s33), this.requestUpdate(t222, r422, i322);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t222) {
    return this.elementProperties.get(t222) ?? y24;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d24("elementProperties"))) return;
    const t222 = n224(this);
    t222.finalize(), void 0 !== t222.l && (this.l = [...t222.l]), this.elementProperties = new Map(t222.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d24("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d24("properties"))) {
      const t322 = this.properties, s222 = [...h44(t322), ...o224(t322)];
      for (const i322 of s222) this.createProperty(i322, t322[i322]);
    }
    const t222 = this[Symbol.metadata];
    if (null !== t222) {
      const s222 = litPropertyMetadata.get(t222);
      if (void 0 !== s222) for (const [t322, i322] of s222) this.elementProperties.set(t322, i322);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t322, s222] of this.elementProperties) {
      const i322 = this._$Eu(t322, s222);
      void 0 !== i322 && this._$Eh.set(i322, t322);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s222) {
    const i322 = [];
    if (Array.isArray(s222)) {
      const e422 = new Set(s222.flat(1 / 0).reverse());
      for (const s33 of e422) i322.unshift(c44(s33));
    } else void 0 !== s222 && i322.push(c44(s222));
    return i322;
  }
  static _$Eu(t222, s222) {
    const i322 = s222.attribute;
    return false === i322 ? void 0 : "string" == typeof i322 ? i322 : "string" == typeof t222 ? t222.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t222) => this.enableUpdating = t222), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t222) => t222(this));
  }
  addController(t222) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t222), void 0 !== this.renderRoot && this.isConnected && t222.hostConnected?.();
  }
  removeController(t222) {
    this._$EO?.delete(t222);
  }
  _$E_() {
    const t222 = /* @__PURE__ */ new Map(), s222 = this.constructor.elementProperties;
    for (const i322 of s222.keys()) this.hasOwnProperty(i322) && (t222.set(i322, this[i322]), delete this[i322]);
    t222.size > 0 && (this._$Ep = t222);
  }
  createRenderRoot() {
    const t222 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S34(t222, this.constructor.elementStyles), t222;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t222) => t222.hostConnected?.());
  }
  enableUpdating(t222) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t222) => t222.hostDisconnected?.());
  }
  attributeChangedCallback(t222, s222, i322) {
    this._$AK(t222, i322);
  }
  _$EC(t222, s222) {
    const i322 = this.constructor.elementProperties.get(t222), e422 = this.constructor._$Eu(t222, i322);
    if (void 0 !== e422 && true === i322.reflect) {
      const r422 = (void 0 !== i322.converter?.toAttribute ? i322.converter : u24).toAttribute(s222, i322.type);
      this._$Em = t222, null == r422 ? this.removeAttribute(e422) : this.setAttribute(e422, r422), this._$Em = null;
    }
  }
  _$AK(t222, s222) {
    const i322 = this.constructor, e422 = i322._$Eh.get(t222);
    if (void 0 !== e422 && this._$Em !== e422) {
      const t322 = i322.getPropertyOptions(e422), r422 = "function" == typeof t322.converter ? { fromAttribute: t322.converter } : void 0 !== t322.converter?.fromAttribute ? t322.converter : u24;
      this._$Em = e422, this[e422] = r422.fromAttribute(s222, t322.type), this._$Em = null;
    }
  }
  requestUpdate(t222, s222, i322) {
    if (void 0 !== t222) {
      if (i322 ??= this.constructor.getPropertyOptions(t222), !(i322.hasChanged ?? f44)(this[t222], s222)) return;
      this.P(t222, s222, i322);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t222, s222, i322) {
    this._$AL.has(t222) || this._$AL.set(t222, s222), true === i322.reflect && this._$Em !== t222 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t222);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t322) {
      Promise.reject(t322);
    }
    const t222 = this.scheduleUpdate();
    return null != t222 && await t222, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t422, s33] of this._$Ep) this[t422] = s33;
        this._$Ep = void 0;
      }
      const t322 = this.constructor.elementProperties;
      if (t322.size > 0) for (const [s33, i322] of t322) true !== i322.wrapped || this._$AL.has(s33) || void 0 === this[s33] || this.P(s33, this[s33], i322);
    }
    let t222 = false;
    const s222 = this._$AL;
    try {
      t222 = this.shouldUpdate(s222), t222 ? (this.willUpdate(s222), this._$EO?.forEach((t322) => t322.hostUpdate?.()), this.update(s222)) : this._$EU();
    } catch (s33) {
      throw t222 = false, this._$EU(), s33;
    }
    t222 && this._$AE(s222);
  }
  willUpdate(t222) {
  }
  _$AE(t222) {
    this._$EO?.forEach((t322) => t322.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t222)), this.updated(t222);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t222) {
    return true;
  }
  update(t222) {
    this._$Ej &&= this._$Ej.forEach((t322) => this._$EC(t322, this[t322])), this._$EU();
  }
  updated(t222) {
  }
  firstUpdated(t222) {
  }
};
b24.elementStyles = [], b24.shadowRootOptions = { mode: "open" }, b24[d24("elementProperties")] = /* @__PURE__ */ new Map(), b24[d24("finalized")] = /* @__PURE__ */ new Map(), p24?.({ ReactiveElement: b24 }), (a24.reactiveElementVersions ??= []).push("2.0.4");
var n324 = globalThis;
var c324 = n324.trustedTypes;
var h224 = c324 ? c324.createPolicy("lit-html", { createHTML: (t222) => t222 }) : void 0;
var f224 = "$lit$";
var v24 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m24 = "?" + v24;
var _24 = `<${m24}>`;
var w24 = document;
var lt24 = () => w24.createComment("");
var st24 = (t222) => null === t222 || "object" != typeof t222 && "function" != typeof t222;
var g24 = Array.isArray;
var $24 = (t222) => g24(t222) || "function" == typeof t222?.[Symbol.iterator];
var x24 = "[ 	\n\f\r]";
var T24 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E24 = /-->/g;
var k24 = />/g;
var O24 = RegExp(`>|${x24}(?:([^\\s"'>=/]+)(${x24}*=${x24}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S224 = /'/g;
var j24 = /"/g;
var M24 = /^(?:script|style|textarea|title)$/i;
var P24 = (t222) => (i322, ...s222) => ({ _$litType$: t222, strings: i322, values: s222 });
var ke24 = P24(1);
var Oe24 = P24(2);
var Se24 = P24(3);
var R24 = Symbol.for("lit-noChange");
var D24 = Symbol.for("lit-nothing");
var V24 = /* @__PURE__ */ new WeakMap();
var I24 = w24.createTreeWalker(w24, 129);
function N24(t222, i322) {
  if (!g24(t222) || !t222.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h224 ? h224.createHTML(i322) : i322;
}
var U24 = (t222, i322) => {
  const s222 = t222.length - 1, e422 = [];
  let h422, o422 = 2 === i322 ? "<svg>" : 3 === i322 ? "<math>" : "", n522 = T24;
  for (let i43 = 0; i43 < s222; i43++) {
    const s33 = t222[i43];
    let r422, l222, c422 = -1, a222 = 0;
    for (; a222 < s33.length && (n522.lastIndex = a222, l222 = n522.exec(s33), null !== l222); ) a222 = n522.lastIndex, n522 === T24 ? "!--" === l222[1] ? n522 = E24 : void 0 !== l222[1] ? n522 = k24 : void 0 !== l222[2] ? (M24.test(l222[2]) && (h422 = RegExp("</" + l222[2], "g")), n522 = O24) : void 0 !== l222[3] && (n522 = O24) : n522 === O24 ? ">" === l222[0] ? (n522 = h422 ?? T24, c422 = -1) : void 0 === l222[1] ? c422 = -2 : (c422 = n522.lastIndex - l222[2].length, r422 = l222[1], n522 = void 0 === l222[3] ? O24 : '"' === l222[3] ? j24 : S224) : n522 === j24 || n522 === S224 ? n522 = O24 : n522 === E24 || n522 === k24 ? n522 = T24 : (n522 = O24, h422 = void 0);
    const u222 = n522 === O24 && t222[i43 + 1].startsWith("/>") ? " " : "";
    o422 += n522 === T24 ? s33 + _24 : c422 >= 0 ? (e422.push(r422), s33.slice(0, c422) + f224 + s33.slice(c422) + v24 + u222) : s33 + v24 + (-2 === c422 ? i43 : u222);
  }
  return [N24(t222, o422 + (t222[s222] || "<?>") + (2 === i322 ? "</svg>" : 3 === i322 ? "</math>" : "")), e422];
};
var B24 = class _B5 {
  constructor({ strings: t222, _$litType$: i322 }, s222) {
    let e422;
    this.parts = [];
    let h422 = 0, o422 = 0;
    const n522 = t222.length - 1, r422 = this.parts, [l222, a222] = U24(t222, i322);
    if (this.el = _B5.createElement(l222, s222), I24.currentNode = this.el.content, 2 === i322 || 3 === i322) {
      const t322 = this.el.content.firstChild;
      t322.replaceWith(...t322.childNodes);
    }
    for (; null !== (e422 = I24.nextNode()) && r422.length < n522; ) {
      if (1 === e422.nodeType) {
        if (e422.hasAttributes()) for (const t322 of e422.getAttributeNames()) if (t322.endsWith(f224)) {
          const i43 = a222[o422++], s33 = e422.getAttribute(t322).split(v24), n63 = /([.?@])?(.*)/.exec(i43);
          r422.push({ type: 1, index: h422, name: n63[2], strings: s33, ctor: "." === n63[1] ? Y24 : "?" === n63[1] ? Z24 : "@" === n63[1] ? q24 : G24 }), e422.removeAttribute(t322);
        } else t322.startsWith(v24) && (r422.push({ type: 6, index: h422 }), e422.removeAttribute(t322));
        if (M24.test(e422.tagName)) {
          const t322 = e422.textContent.split(v24), i43 = t322.length - 1;
          if (i43 > 0) {
            e422.textContent = c324 ? c324.emptyScript : "";
            for (let s33 = 0; s33 < i43; s33++) e422.append(t322[s33], lt24()), I24.nextNode(), r422.push({ type: 2, index: ++h422 });
            e422.append(t322[i43], lt24());
          }
        }
      } else if (8 === e422.nodeType) if (e422.data === m24) r422.push({ type: 2, index: h422 });
      else {
        let t322 = -1;
        for (; -1 !== (t322 = e422.data.indexOf(v24, t322 + 1)); ) r422.push({ type: 7, index: h422 }), t322 += v24.length - 1;
      }
      h422++;
    }
  }
  static createElement(t222, i322) {
    const s222 = w24.createElement("template");
    return s222.innerHTML = t222, s222;
  }
};
function z24(t222, i322, s222 = t222, e422) {
  if (i322 === R24) return i322;
  let h422 = void 0 !== e422 ? s222.o?.[e422] : s222.l;
  const o422 = st24(i322) ? void 0 : i322._$litDirective$;
  return h422?.constructor !== o422 && (h422?._$AO?.(false), void 0 === o422 ? h422 = void 0 : (h422 = new o422(t222), h422._$AT(t222, s222, e422)), void 0 !== e422 ? (s222.o ??= [])[e422] = h422 : s222.l = h422), void 0 !== h422 && (i322 = z24(t222, h422._$AS(t222, i322.values), h422, e422)), i322;
}
var F24 = class {
  constructor(t222, i322) {
    this._$AV = [], this._$AN = void 0, this._$AD = t222, this._$AM = i322;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t222) {
    const { el: { content: i322 }, parts: s222 } = this._$AD, e422 = (t222?.creationScope ?? w24).importNode(i322, true);
    I24.currentNode = e422;
    let h422 = I24.nextNode(), o422 = 0, n522 = 0, r422 = s222[0];
    for (; void 0 !== r422; ) {
      if (o422 === r422.index) {
        let i43;
        2 === r422.type ? i43 = new et24(h422, h422.nextSibling, this, t222) : 1 === r422.type ? i43 = new r422.ctor(h422, r422.name, r422.strings, this, t222) : 6 === r422.type && (i43 = new K24(h422, this, t222)), this._$AV.push(i43), r422 = s222[++n522];
      }
      o422 !== r422?.index && (h422 = I24.nextNode(), o422++);
    }
    return I24.currentNode = w24, e422;
  }
  p(t222) {
    let i322 = 0;
    for (const s222 of this._$AV) void 0 !== s222 && (void 0 !== s222.strings ? (s222._$AI(t222, s222, i322), i322 += s222.strings.length - 2) : s222._$AI(t222[i322])), i322++;
  }
};
var et24 = class _et5 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t222, i322, s222, e422) {
    this.type = 2, this._$AH = D24, this._$AN = void 0, this._$AA = t222, this._$AB = i322, this._$AM = s222, this.options = e422, this.v = e422?.isConnected ?? true;
  }
  get parentNode() {
    let t222 = this._$AA.parentNode;
    const i322 = this._$AM;
    return void 0 !== i322 && 11 === t222?.nodeType && (t222 = i322.parentNode), t222;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t222, i322 = this) {
    t222 = z24(this, t222, i322), st24(t222) ? t222 === D24 || null == t222 || "" === t222 ? (this._$AH !== D24 && this._$AR(), this._$AH = D24) : t222 !== this._$AH && t222 !== R24 && this._(t222) : void 0 !== t222._$litType$ ? this.$(t222) : void 0 !== t222.nodeType ? this.T(t222) : $24(t222) ? this.k(t222) : this._(t222);
  }
  O(t222) {
    return this._$AA.parentNode.insertBefore(t222, this._$AB);
  }
  T(t222) {
    this._$AH !== t222 && (this._$AR(), this._$AH = this.O(t222));
  }
  _(t222) {
    this._$AH !== D24 && st24(this._$AH) ? this._$AA.nextSibling.data = t222 : this.T(w24.createTextNode(t222)), this._$AH = t222;
  }
  $(t222) {
    const { values: i322, _$litType$: s222 } = t222, e422 = "number" == typeof s222 ? this._$AC(t222) : (void 0 === s222.el && (s222.el = B24.createElement(N24(s222.h, s222.h[0]), this.options)), s222);
    if (this._$AH?._$AD === e422) this._$AH.p(i322);
    else {
      const t322 = new F24(e422, this), s33 = t322.u(this.options);
      t322.p(i322), this.T(s33), this._$AH = t322;
    }
  }
  _$AC(t222) {
    let i322 = V24.get(t222.strings);
    return void 0 === i322 && V24.set(t222.strings, i322 = new B24(t222)), i322;
  }
  k(t222) {
    g24(this._$AH) || (this._$AH = [], this._$AR());
    const i322 = this._$AH;
    let s222, e422 = 0;
    for (const h422 of t222) e422 === i322.length ? i322.push(s222 = new _et5(this.O(lt24()), this.O(lt24()), this, this.options)) : s222 = i322[e422], s222._$AI(h422), e422++;
    e422 < i322.length && (this._$AR(s222 && s222._$AB.nextSibling, e422), i322.length = e422);
  }
  _$AR(t222 = this._$AA.nextSibling, i322) {
    for (this._$AP?.(false, true, i322); t222 && t222 !== this._$AB; ) {
      const i43 = t222.nextSibling;
      t222.remove(), t222 = i43;
    }
  }
  setConnected(t222) {
    void 0 === this._$AM && (this.v = t222, this._$AP?.(t222));
  }
};
var G24 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t222, i322, s222, e422, h422) {
    this.type = 1, this._$AH = D24, this._$AN = void 0, this.element = t222, this.name = i322, this._$AM = e422, this.options = h422, s222.length > 2 || "" !== s222[0] || "" !== s222[1] ? (this._$AH = Array(s222.length - 1).fill(new String()), this.strings = s222) : this._$AH = D24;
  }
  _$AI(t222, i322 = this, s222, e422) {
    const h422 = this.strings;
    let o422 = false;
    if (void 0 === h422) t222 = z24(this, t222, i322, 0), o422 = !st24(t222) || t222 !== this._$AH && t222 !== R24, o422 && (this._$AH = t222);
    else {
      const e522 = t222;
      let n522, r422;
      for (t222 = h422[0], n522 = 0; n522 < h422.length - 1; n522++) r422 = z24(this, e522[s222 + n522], i322, n522), r422 === R24 && (r422 = this._$AH[n522]), o422 ||= !st24(r422) || r422 !== this._$AH[n522], r422 === D24 ? t222 = D24 : t222 !== D24 && (t222 += (r422 ?? "") + h422[n522 + 1]), this._$AH[n522] = r422;
    }
    o422 && !e422 && this.j(t222);
  }
  j(t222) {
    t222 === D24 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t222 ?? "");
  }
};
var Y24 = class extends G24 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t222) {
    this.element[this.name] = t222 === D24 ? void 0 : t222;
  }
};
var Z24 = class extends G24 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t222) {
    this.element.toggleAttribute(this.name, !!t222 && t222 !== D24);
  }
};
var q24 = class extends G24 {
  constructor(t222, i322, s222, e422, h422) {
    super(t222, i322, s222, e422, h422), this.type = 5;
  }
  _$AI(t222, i322 = this) {
    if ((t222 = z24(this, t222, i322, 0) ?? D24) === R24) return;
    const s222 = this._$AH, e422 = t222 === D24 && s222 !== D24 || t222.capture !== s222.capture || t222.once !== s222.once || t222.passive !== s222.passive, h422 = t222 !== D24 && (s222 === D24 || e422);
    e422 && this.element.removeEventListener(this.name, this, s222), h422 && this.element.addEventListener(this.name, this, t222), this._$AH = t222;
  }
  handleEvent(t222) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t222) : this._$AH.handleEvent(t222);
  }
};
var K24 = class {
  constructor(t222, i322, s222) {
    this.element = t222, this.type = 6, this._$AN = void 0, this._$AM = i322, this.options = s222;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t222) {
    z24(this, t222);
  }
};
var Re24 = n324.litHtmlPolyfillSupport;
Re24?.(B24, et24), (n324.litHtmlVersions ??= []).push("3.2.0");
var Q24 = (t222, i322, s222) => {
  const e422 = s222?.renderBefore ?? i322;
  let h422 = e422._$litPart$;
  if (void 0 === h422) {
    const t322 = s222?.renderBefore ?? null;
    e422._$litPart$ = h422 = new et24(i322.insertBefore(lt24(), t322), t322, void 0, s222 ?? {});
  }
  return h422._$AI(t222), h422;
};
var h324 = class extends b24 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t222 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t222.firstChild, t222;
  }
  update(t222) {
    const e422 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t222), this.o = Q24(e422, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R24;
  }
};
h324._$litElement$ = true, h324["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h324 });
var f324 = globalThis.litElementPolyfillSupport;
f324?.({ LitElement: h324 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o324 = { attribute: true, type: String, converter: u24, reflect: false, hasChanged: f44 };
var r324 = (t222 = o324, e422, r422) => {
  const { kind: n522, metadata: i322 } = r422;
  let s222 = globalThis.litPropertyMetadata.get(i322);
  if (void 0 === s222 && globalThis.litPropertyMetadata.set(i322, s222 = /* @__PURE__ */ new Map()), s222.set(r422.name, t222), "accessor" === n522) {
    const { name: o422 } = r422;
    return { set(r522) {
      const n63 = e422.get.call(this);
      e422.set.call(this, r522), this.requestUpdate(o422, n63, t222);
    }, init(e522) {
      return void 0 !== e522 && this.P(o422, void 0, t222), e522;
    } };
  }
  if ("setter" === n522) {
    const { name: o422 } = r422;
    return function(r522) {
      const n63 = this[o422];
      e422.call(this, r522), this.requestUpdate(o422, n63, t222);
    };
  }
  throw Error("Unsupported decorator location: " + n522);
};
function n424(t222) {
  return (e422, o422) => "object" == typeof o422 ? r324(t222, e422, o422) : ((t322, e522, o522) => {
    const r422 = e522.hasOwnProperty(o522);
    return e522.constructor.createProperty(o522, r422 ? { ...t322, wrapped: true } : t322), r422 ? Object.getOwnPropertyDescriptor(e522, o522) : void 0;
  })(t222, e422, o422);
}
var appliedClassMixins4 = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied4(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins4.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin4(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied4(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins4.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version4 = "3.0.0";
var versions4 = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions4.includes(version4)) {
  versions4.push(version4);
}
var ScopedElementsMixinImplementation5 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version4;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry22) {
      this.constructor.__registry = registry22;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin5 = dedupeMixin4(ScopedElementsMixinImplementation5);
var ScopedElementsMixinImplementation24 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin5(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S34(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin24 = dedupeMixin4(ScopedElementsMixinImplementation24);
function option2(decl = { type: "string" }) {
  return (target, context) => {
    function init() {
      this.constructor["options"] = { ...this.constructor["options"], [context.name]: decl };
    }
    context.addInitializer(init);
  };
}
function action(decl) {
  return (target, context) => {
    function init() {
      this.constructor["actions"] = { ...this.constructor["actions"], [context.name]: decl };
    }
    context.addInitializer(init);
    function func(...args) {
      this._inTransaction = true;
      try {
        return target.apply(this, args);
      } finally {
        this._inTransaction = false;
      }
    }
    if (context.kind === "method") {
      return func;
    } else {
      context.access.set(this, func);
    }
  };
}
var _lang_dec4;
var _contentEditable_dec4;
var _a5;
var _init5;
var _contentEditable4;
var _lang4;
var LitElementWw4 = class extends (_a5 = ScopedElementsMixin24(h324), _contentEditable_dec4 = [n424({ type: String, attribute: true, reflect: true })], _lang_dec4 = [n424({ type: String, attribute: true, reflect: true })], _a5) {
  constructor() {
    super(...arguments);
    __publicField23(this, "options");
    __publicField23(this, "actions", {});
    __privateAdd23(this, _contentEditable4, __runInitializers24(_init5, 8, this)), __runInitializers24(_init5, 11, this);
    __privateAdd23(this, _lang4, __runInitializers24(_init5, 12, this)), __runInitializers24(_init5, 15, this);
    __publicField23(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k222) => this.setAttribute(k222, this.getAttribute(k222)));
  }
};
_init5 = __decoratorStart24(_a5);
_contentEditable4 = /* @__PURE__ */ new WeakMap();
_lang4 = /* @__PURE__ */ new WeakMap();
__decorateElement24(_init5, 4, "contentEditable", _contentEditable_dec4, LitElementWw4, _contentEditable4);
__decorateElement24(_init5, 4, "lang", _lang_dec4, LitElementWw4, _lang4);
__decoratorMetadata24(_init5, LitElementWw4);
__publicField23(LitElementWw4, "shadowRootOptions", { ...h324.shadowRootOptions });
__publicField23(LitElementWw4, "options", {});
__publicField23(LitElementWw4, "actions", {});
var t34 = (t54) => (e73, o64) => {
  void 0 !== o64 ? o64.addInitializer(() => {
    customElements.define(t54, e73);
  }) : customElements.define(t54, e73);
};
var o43 = { attribute: true, type: String, converter: u5, reflect: false, hasChanged: f7 };
var r43 = (t54 = o43, e73, r64) => {
  const { kind: n63, metadata: i43 } = r64;
  let s33 = globalThis.litPropertyMetadata.get(i43);
  if (void 0 === s33 && globalThis.litPropertyMetadata.set(i43, s33 = /* @__PURE__ */ new Map()), s33.set(r64.name, t54), "accessor" === n63) {
    const { name: o64 } = r64;
    return { set(r73) {
      const n73 = e73.get.call(this);
      e73.set.call(this, r73), this.requestUpdate(o64, n73, t54);
    }, init(e83) {
      return void 0 !== e83 && this.P(o64, void 0, t54), e83;
    } };
  }
  if ("setter" === n63) {
    const { name: o64 } = r64;
    return function(r73) {
      const n73 = this[o64];
      e73.call(this, r73), this.requestUpdate(o64, n73, t54);
    };
  }
  throw Error("Unsupported decorator location: " + n63);
};
function n53(t54) {
  return (e73, o64) => "object" == typeof o64 ? r43(t54, e73, o64) : ((t64, e83, o73) => {
    const r64 = e83.hasOwnProperty(o73);
    return e83.constructor.createProperty(o73, r64 ? { ...t64, wrapped: true } : t64), r64 ? Object.getOwnPropertyDescriptor(e83, o73) : void 0;
  })(t54, e73, o64);
}
function r53(r64) {
  return n53({ ...r64, state: true, attribute: false });
}
var e43 = (e73, t54, c53) => (c53.configurable = true, c53.enumerable = true, Reflect.decorate && "object" != typeof t54 && Object.defineProperty(e73, t54, c53), c53);
function e54(e73, r64) {
  return (n63, s33, i43) => {
    const o64 = (t54) => t54.renderRoot?.querySelector(e73) ?? null;
    if (r64) {
      const { get: e83, set: r73 } = "object" == typeof s33 ? n63 : i43 ?? (() => {
        const t54 = Symbol();
        return { get() {
          return this[t54];
        }, set(e93) {
          this[t54] = e93;
        } };
      })();
      return e43(n63, s33, { get() {
        let t54 = e83.call(this);
        return void 0 === t54 && (t54 = o64(this), (null !== t54 || this.hasUpdated) && r73.call(this, t54)), t54;
      } });
    }
    return e43(n63, s33, { get() {
      return o64(this);
    } });
  };
}
function o53(o64) {
  return (e73, n63) => {
    const { slot: r64, selector: s33 } = o64 ?? {}, c53 = "slot" + (r64 ? `[name=${r64}]` : ":not([name])");
    return e43(e73, n63, { get() {
      const t54 = this.renderRoot?.querySelector(c53), e83 = t54?.assignedElements(o64) ?? [];
      return void 0 === s33 ? e83 : e83.filter((t64) => t64.matches(s33));
    } });
  };
}
var spinner_styles_default3 = i5`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;
var connectedElements3 = /* @__PURE__ */ new Set();
var documentElementObserver3 = new MutationObserver(update3);
var translations3 = /* @__PURE__ */ new Map();
var documentDirection3 = document.documentElement.dir || "ltr";
var documentLanguage3 = document.documentElement.lang || navigator.language;
var fallback3;
documentElementObserver3.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation3(...translation22) {
  translation22.map((t54) => {
    const code = t54.$code.toLowerCase();
    if (translations3.has(code)) {
      translations3.set(code, Object.assign(Object.assign({}, translations3.get(code)), t54));
    } else {
      translations3.set(code, t54);
    }
    if (!fallback3) {
      fallback3 = t54;
    }
  });
  update3();
}
function update3() {
  documentDirection3 = document.documentElement.dir || "ltr";
  documentLanguage3 = document.documentElement.lang || navigator.language;
  [...connectedElements3.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController4 = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements3.add(this.host);
  }
  hostDisconnected() {
    connectedElements3.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection3}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage3}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a33, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a33 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a33 === void 0 ? void 0 : _a33.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations3.get(`${language}-${region}`);
    const secondary = translations3.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a33;
    const { primary, secondary } = this.getTranslationData((_a33 = options.lang) !== null && _a33 !== void 0 ? _a33 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback3 && fallback3[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback3 && fallback3[key]) {
      term = fallback3[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};
var translation3 = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation3(translation3);
var en_default3 = translation3;
var LocalizeController23 = class extends LocalizeController4 {
};
registerTranslation3(en_default3);
var component_styles_default3 = i5`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
var __defProp33 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDesc33 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp33 = (obj, key, value) => key in obj ? __defProp33(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a33, b33) => {
  for (var prop in b33 || (b33 = {}))
    if (__hasOwnProp3.call(b33, prop))
      __defNormalProp33(a33, prop, b33[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b33)) {
      if (__propIsEnum3.call(b33, prop))
        __defNormalProp33(a33, prop, b33[prop]);
    }
  return a33;
};
var __spreadProps3 = (a33, b33) => __defProps3(a33, __getOwnPropDescs3(b33));
var __decorateClass3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc33(target, key) : target;
  for (var i43 = decorators.length - 1, decorator; i43 >= 0; i43--)
    if (decorator = decorators[i43])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp33(target, key, result);
  return result;
};
var __accessCheck33 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet33 = (obj, member, getter) => {
  __accessCheck33(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd33 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet33 = (obj, member, value, setter) => {
  __accessCheck33(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _hasRecordedInitialProperties3;
var ShoelaceElement3 = class extends h35 {
  constructor() {
    super();
    __privateAdd33(this, _hasRecordedInitialProperties3, false);
    this.initialReflectedProperties = /* @__PURE__ */ new Map();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues3({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      try {
        customElements.define(name, elementConstructor, options);
      } catch (_err) {
        customElements.define(name, class extends elementConstructor {
        }, options);
      }
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (!__privateGet33(this, _hasRecordedInitialProperties3)) {
      this.constructor.elementProperties.forEach(
        (obj, prop) => {
          if (obj.reflect && this[prop] != null) {
            this.initialReflectedProperties.set(prop, this[prop]);
          }
        }
      );
      __privateSet33(this, _hasRecordedInitialProperties3, true);
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    this.initialReflectedProperties.forEach((value, prop) => {
      if (changedProperties.has(prop) && this[prop] == null) {
        this[prop] = value;
      }
    });
  }
};
_hasRecordedInitialProperties3 = /* @__PURE__ */ new WeakMap();
ShoelaceElement3.version = "2.17.1";
ShoelaceElement3.dependencies = {};
__decorateClass3([
  n53()
], ShoelaceElement3.prototype, "dir", 2);
__decorateClass3([
  n53()
], ShoelaceElement3.prototype, "lang", 2);
var SlSpinner3 = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController23(this);
  }
  render() {
    return ke6`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner3.styles = [component_styles_default3, spinner_styles_default3];
var formCollections3 = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads3 = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads3 = /* @__PURE__ */ new WeakMap();
var userInteractedControls3 = /* @__PURE__ */ new WeakSet();
var interactions3 = /* @__PURE__ */ new WeakMap();
var FormControlController3 = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a33;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a33 = formCollections3.get(this.form)) == null ? void 0 : _a33.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions3.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions3.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues3({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a33;
        return (_a33 = input.disabled) != null ? _a33 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions3.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions3.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections3.has(this.form)) {
        formCollections3.get(this.form).add(this.host);
      } else {
        formCollections3.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads3.has(this.form)) {
        reportValidityOverloads3.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads3.has(this.form)) {
        checkValidityOverloads3.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections3.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads3.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads3.get(this.form);
        reportValidityOverloads3.delete(this.form);
      }
      if (checkValidityOverloads3.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads3.get(this.form);
        checkValidityOverloads3.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls3.add(el);
    } else {
      userInteractedControls3.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a33;
    return (_a33 = this.form) != null ? _a33 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls3.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState3 = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState3 = Object.freeze(__spreadProps3(__spreadValues3({}, validValidityState3), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState3 = Object.freeze(__spreadProps3(__spreadValues3({}, validValidityState3), {
  valid: false,
  customError: true
}));
var button_styles_default3 = i5`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`;
var HasSlotController3 = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
var basePath3 = "";
function setBasePath3(path) {
  basePath3 = path;
}
function getBasePath3(subpath = "") {
  if (!basePath3) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath3(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s33) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s33.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s33.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath3(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath3.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}
var library3 = {
  name: "default",
  resolver: (name) => getBasePath3(`assets/icons/${name}.svg`)
};
var library_default_default3 = library3;
var icons3 = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary3 = {
  name: "system",
  resolver: (name) => {
    if (name in icons3) {
      return `data:image/svg+xml,${encodeURIComponent(icons3[name])}`;
    }
    return "";
  }
};
var library_system_default3 = systemLibrary3;
var registry3 = [library_default_default3, library_system_default3];
var watchedIcons3 = [];
function watchIcon3(icon) {
  watchedIcons3.push(icon);
}
function unwatchIcon3(icon) {
  watchedIcons3 = watchedIcons3.filter((el) => el !== icon);
}
function getIconLibrary3(name) {
  return registry3.find((lib) => lib.name === name);
}
var icon_styles_default3 = i5`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
function watch3(propertyName, options) {
  const resolvedOptions = __spreadValues3({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update22 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update22.call(this, changedProps);
    };
  };
}
var { I: et33 } = si3;
var nt3 = (o64, t54) => void 0 === t54 ? void 0 !== o64?._$litType$ : o64?._$litType$ === t54;
var rt2 = (o64) => void 0 === o64.strings;
var ht = {};
var dt = (o64, t54 = ht) => o64._$AH = t54;
var CACHEABLE_ERROR3 = Symbol();
var RETRYABLE_ERROR3 = Symbol();
var parser3;
var iconCache3 = /* @__PURE__ */ new Map();
var SlIcon3 = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library22) {
    var _a33;
    let fileData;
    if (library22 == null ? void 0 : library22.spriteSheet) {
      this.svg = ke6`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR3 : RETRYABLE_ERROR3;
    } catch (e73) {
      return RETRYABLE_ERROR3;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a33 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a33.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR3;
      if (!parser3)
        parser3 = new DOMParser();
      const doc = parser3.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR3;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e73) {
      return CACHEABLE_ERROR3;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon3(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon3(this);
  }
  getIconSource() {
    const library22 = getIconLibrary3(this.library);
    if (this.name && library22) {
      return {
        url: library22.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a33;
    const { url, fromLibrary } = this.getIconSource();
    const library22 = fromLibrary ? getIconLibrary3(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache3.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library22);
      iconCache3.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR3) {
      iconCache3.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt3(svg)) {
      this.svg = svg;
      if (library22) {
        await this.updateComplete;
        const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library22.mutator === "function" && shadowSVG) {
          library22.mutator(shadowSVG);
        }
      }
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR3:
      case CACHEABLE_ERROR3:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a33 = library22 == null ? void 0 : library22.mutator) == null ? void 0 : _a33.call(library22, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon3.styles = [component_styles_default3, icon_styles_default3];
__decorateClass3([
  r53()
], SlIcon3.prototype, "svg", 2);
__decorateClass3([
  n53({ reflect: true })
], SlIcon3.prototype, "name", 2);
__decorateClass3([
  n53()
], SlIcon3.prototype, "src", 2);
__decorateClass3([
  n53()
], SlIcon3.prototype, "label", 2);
__decorateClass3([
  n53({ reflect: true })
], SlIcon3.prototype, "library", 2);
__decorateClass3([
  watch3("label")
], SlIcon3.prototype, "handleLabelChange", 1);
__decorateClass3([
  watch3(["name", "src", "library"])
], SlIcon3.prototype, "setIcon", 1);
var t44 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e63 = (t54) => (...e73) => ({ _$litDirective$: t54, values: e73 });
var i34 = class {
  constructor(t54) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t54, e73, i43) {
    this.t = t54, this._$AM = e73, this.i = i43;
  }
  _$AS(t54, e73) {
    return this.update(t54, e73);
  }
  update(t54, e73) {
    return this.render(...e73);
  }
};
var Rt3 = e63(class extends i34 {
  constructor(s33) {
    if (super(s33), s33.type !== t44.ATTRIBUTE || "class" !== s33.name || s33.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t54) {
    return " " + Object.keys(t54).filter((s33) => t54[s33]).join(" ") + " ";
  }
  update(t54, [s33]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t54.strings && (this.nt = new Set(t54.strings.join(" ").split(/\s/).filter((t64) => "" !== t64)));
      for (const t64 in s33) s33[t64] && !this.nt?.has(t64) && this.st.add(t64);
      return this.render(s33);
    }
    const i43 = t54.element.classList;
    for (const t64 of this.st) t64 in s33 || (i43.remove(t64), this.st.delete(t64));
    for (const t64 in s33) {
      const r64 = !!s33[t64];
      r64 === this.st.has(t64) || this.nt?.has(t64) || (r64 ? (i43.add(t64), this.st.add(t64)) : (i43.remove(t64), this.st.delete(t64)));
    }
    return R5;
  }
});
var $e3 = Symbol.for("");
var xe3 = (t54) => {
  if (t54?.r === $e3) return t54?._$litStatic$;
};
var er3 = (t54, ...r64) => ({ _$litStatic$: r64.reduce((r73, e73, a33) => r73 + ((t64) => {
  if (void 0 !== t64._$litStatic$) return t64._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t64}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e73) + t54[a33 + 1], t54[0]), r: $e3 });
var Te3 = /* @__PURE__ */ new Map();
var Ee3 = (t54) => (r64, ...e73) => {
  const a33 = e73.length;
  let o64, s33;
  const i43 = [], l33 = [];
  let n63, u33 = 0, c53 = false;
  for (; u33 < a33; ) {
    for (n63 = r64[u33]; u33 < a33 && void 0 !== (s33 = e73[u33], o64 = xe3(s33)); ) n63 += o64 + r64[++u33], c53 = true;
    u33 !== a33 && l33.push(s33), i43.push(n63), u33++;
  }
  if (u33 === a33 && i43.push(r64[a33]), c53) {
    const t64 = i43.join("$$lit$$");
    void 0 === (r64 = Te3.get(t64)) && (i43.raw = i43, Te3.set(t64, r64 = i43)), e73 = l33;
  }
  return t54(r64, ...e73);
};
var ke33 = Ee3(ke6);
var Oe33 = Ee3(Oe6);
var Se33 = Ee3(Se6);
var to3 = (t54) => t54 ?? D5;
var SlButton3 = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController3(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController3(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController23(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState3;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? er3`a` : er3`button`;
    return ke33`
      <${tag}
        part="base"
        class=${Rt3({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to3(isLink ? void 0 : this.disabled)}
        type=${to3(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to3(isLink ? void 0 : this.name)}
        value=${to3(isLink ? void 0 : this.value)}
        href=${to3(isLink && !this.disabled ? this.href : void 0)}
        target=${to3(isLink ? this.target : void 0)}
        download=${to3(isLink ? this.download : void 0)}
        rel=${to3(isLink ? this.rel : void 0)}
        role=${to3(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke33` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke33`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton3.styles = [component_styles_default3, button_styles_default3];
SlButton3.dependencies = {
  "sl-icon": SlIcon3,
  "sl-spinner": SlSpinner3
};
__decorateClass3([
  e54(".button")
], SlButton3.prototype, "button", 2);
__decorateClass3([
  r53()
], SlButton3.prototype, "hasFocus", 2);
__decorateClass3([
  r53()
], SlButton3.prototype, "invalid", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "title", 2);
__decorateClass3([
  n53({ reflect: true })
], SlButton3.prototype, "variant", 2);
__decorateClass3([
  n53({ reflect: true })
], SlButton3.prototype, "size", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlButton3.prototype, "caret", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlButton3.prototype, "disabled", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlButton3.prototype, "loading", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlButton3.prototype, "outline", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlButton3.prototype, "pill", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlButton3.prototype, "circle", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "type", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "name", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "value", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "href", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "target", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "rel", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "download", 2);
__decorateClass3([
  n53()
], SlButton3.prototype, "form", 2);
__decorateClass3([
  n53({ attribute: "formaction" })
], SlButton3.prototype, "formAction", 2);
__decorateClass3([
  n53({ attribute: "formenctype" })
], SlButton3.prototype, "formEnctype", 2);
__decorateClass3([
  n53({ attribute: "formmethod" })
], SlButton3.prototype, "formMethod", 2);
__decorateClass3([
  n53({ attribute: "formnovalidate", type: Boolean })
], SlButton3.prototype, "formNoValidate", 2);
__decorateClass3([
  n53({ attribute: "formtarget" })
], SlButton3.prototype, "formTarget", 2);
__decorateClass3([
  watch3("disabled", { waitUntilFirstUpdate: true })
], SlButton3.prototype, "handleDisabledChange", 1);
var radio_styles_default = i5`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`;
var SlRadio = class extends ShoelaceElement3 {
  constructor() {
    super();
    this.checked = false;
    this.hasFocus = false;
    this.size = "medium";
    this.disabled = false;
    this.handleBlur = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.handleClick = () => {
      if (!this.disabled) {
        this.checked = true;
      }
    };
    this.handleFocus = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.addEventListener("blur", this.handleBlur);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback();
    this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio");
    this.setAttribute("tabindex", "-1");
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return ke6`
      <span
        part="base"
        class=${Rt3({
      radio: true,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus,
      "radio--small": this.size === "small",
      "radio--medium": this.size === "medium",
      "radio--large": this.size === "large"
    })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? ke6` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio.styles = [component_styles_default3, radio_styles_default];
SlRadio.dependencies = { "sl-icon": SlIcon3 };
__decorateClass3([
  r53()
], SlRadio.prototype, "checked", 2);
__decorateClass3([
  r53()
], SlRadio.prototype, "hasFocus", 2);
__decorateClass3([
  n53()
], SlRadio.prototype, "value", 2);
__decorateClass3([
  n53({ reflect: true })
], SlRadio.prototype, "size", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlRadio.prototype, "disabled", 2);
__decorateClass3([
  watch3("checked")
], SlRadio.prototype, "handleCheckedChange", 1);
__decorateClass3([
  watch3("disabled", { waitUntilFirstUpdate: true })
], SlRadio.prototype, "handleDisabledChange", 1);
var checkbox_styles_default = i5`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a33;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u5;
      const fromAttribute = typeof converter === "function" ? converter : (_a33 = converter == null ? void 0 : converter.fromAttribute) != null ? _a33 : u5.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};
var form_control_styles_default = i5`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;
var Ft = e63(class extends i34 {
  constructor(r64) {
    if (super(r64), r64.type !== t44.PROPERTY && r64.type !== t44.ATTRIBUTE && r64.type !== t44.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt2(r64)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r64) {
    return r64;
  }
  update(r64, [e73]) {
    if (e73 === R5 || e73 === D5) return e73;
    const i43 = r64.element, n63 = r64.name;
    if (r64.type === t44.PROPERTY) {
      if (e73 === i43[n63]) return R5;
    } else if (r64.type === t44.BOOLEAN_ATTRIBUTE) {
      if (!!e73 === i43.hasAttribute(n63)) return R5;
    } else if (r64.type === t44.ATTRIBUTE && i43.getAttribute(n63) === e73 + "") return R5;
    return dt(r64), e73;
  }
});
var SlCheckbox = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController3(this, {
      value: (control) => control.checked ? control.value || "on" : void 0,
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController3(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke6`
      <div
        class=${Rt3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${Rt3({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to3(this.value)}
            .indeterminate=${Ft(this.indeterminate)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? ke6`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? ke6`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default3, form_control_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = { "sl-icon": SlIcon3 };
__decorateClass3([
  e54('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass3([
  r53()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass3([
  n53()
], SlCheckbox.prototype, "title", 2);
__decorateClass3([
  n53()
], SlCheckbox.prototype, "name", 2);
__decorateClass3([
  n53()
], SlCheckbox.prototype, "value", 2);
__decorateClass3([
  n53({ reflect: true })
], SlCheckbox.prototype, "size", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "checked", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass3([
  defaultValue("checked")
], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass3([
  n53({ reflect: true })
], SlCheckbox.prototype, "form", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "required", 2);
__decorateClass3([
  n53({ attribute: "help-text" })
], SlCheckbox.prototype, "helpText", 2);
__decorateClass3([
  watch3("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass3([
  watch3(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleStateChange", 1);
var radio_button_styles_default = i5`
  ${button_styles_default3}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`;
var SlRadioButton = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController3(this, "[default]", "prefix", "suffix");
    this.hasFocus = false;
    this.checked = false;
    this.disabled = false;
    this.size = "medium";
    this.pill = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "presentation");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleClick(e73) {
    if (this.disabled) {
      e73.preventDefault();
      e73.stopPropagation();
      return;
    }
    this.checked = true;
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus on the radio button. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the radio button. */
  blur() {
    this.input.blur();
  }
  render() {
    return ke33`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${Rt3({
      button: true,
      "button--default": true,
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--checked": this.checked,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--outline": true,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
          aria-disabled=${this.disabled}
          type="button"
          value=${to3(this.value)}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = [component_styles_default3, radio_button_styles_default];
__decorateClass3([
  e54(".button")
], SlRadioButton.prototype, "input", 2);
__decorateClass3([
  e54(".hidden-input")
], SlRadioButton.prototype, "hiddenInput", 2);
__decorateClass3([
  r53()
], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "checked", 2);
__decorateClass3([
  n53()
], SlRadioButton.prototype, "value", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "disabled", 2);
__decorateClass3([
  n53({ reflect: true })
], SlRadioButton.prototype, "size", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlRadioButton.prototype, "pill", 2);
__decorateClass3([
  watch3("disabled", { waitUntilFirstUpdate: true })
], SlRadioButton.prototype, "handleDisabledChange", 1);
var radio_group_styles_default = i5`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`;
var button_group_styles_default3 = i5`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;
var SlButtonGroup3 = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton3(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", true);
  }
  handleBlur(event) {
    const button = findButton3(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", false);
  }
  handleMouseOver(event) {
    const button = findButton3(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", true);
  }
  handleMouseOut(event) {
    const button = findButton3(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", false);
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton3(el);
      if (button) {
        button.toggleAttribute("data-sl-button-group__button", true);
        button.toggleAttribute("data-sl-button-group__button--first", index === 0);
        button.toggleAttribute("data-sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.toggleAttribute("data-sl-button-group__button--last", index === slottedElements.length - 1);
        button.toggleAttribute(
          "data-sl-button-group__button--radio",
          button.tagName.toLowerCase() === "sl-radio-button"
        );
      }
    });
  }
  render() {
    return ke6`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup3.styles = [component_styles_default3, button_group_styles_default3];
__decorateClass3([
  e54("slot")
], SlButtonGroup3.prototype, "defaultSlot", 2);
__decorateClass3([
  r53()
], SlButtonGroup3.prototype, "disableRole", 2);
__decorateClass3([
  n53()
], SlButtonGroup3.prototype, "label", 2);
function findButton3(el) {
  var _a33;
  const selector = "sl-button, sl-radio-button";
  return (_a33 = el.closest(selector)) != null ? _a33 : el.querySelector(selector);
}
var SlRadioGroup = class extends ShoelaceElement3 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController3(this);
    this.hasSlotController = new HasSlotController3(this, "help-text", "label");
    this.customValidityMessage = "";
    this.hasButtonGroup = false;
    this.errorMessage = "";
    this.defaultValue = "";
    this.label = "";
    this.helpText = "";
    this.name = "option";
    this.value = "";
    this.size = "medium";
    this.form = "";
    this.required = false;
  }
  /** Gets the validity state object */
  get validity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return customErrorValidityState3;
    } else if (isRequiredAndEmpty) {
      return valueMissingValidityState3;
    }
    return validValidityState3;
  }
  /** Gets the validation message */
  get validationMessage() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return this.customValidityMessage;
    } else if (isRequiredAndEmpty) {
      return this.validationInput.validationMessage;
    }
    return "";
  }
  connectedCallback() {
    super.connectedCallback();
    this.defaultValue = this.value;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  getAllRadios() {
    return [...this.querySelectorAll("sl-radio, sl-radio-button")];
  }
  handleRadioClick(event) {
    const target = event.target.closest("sl-radio, sl-radio-button");
    const radios = this.getAllRadios();
    const oldValue = this.value;
    if (!target || target.disabled) {
      return;
    }
    this.value = target.value;
    radios.forEach((radio) => radio.checked = radio === target);
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleKeyDown(event) {
    var _a33;
    if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(event.key)) {
      return;
    }
    const radios = this.getAllRadios().filter((radio) => !radio.disabled);
    const checkedRadio = (_a33 = radios.find((radio) => radio.checked)) != null ? _a33 : radios[0];
    const incr = event.key === " " ? 0 : ["ArrowUp", "ArrowLeft"].includes(event.key) ? -1 : 1;
    const oldValue = this.value;
    let index = radios.indexOf(checkedRadio) + incr;
    if (index < 0) {
      index = radios.length - 1;
    }
    if (index > radios.length - 1) {
      index = 0;
    }
    this.getAllRadios().forEach((radio) => {
      radio.checked = false;
      if (!this.hasButtonGroup) {
        radio.setAttribute("tabindex", "-1");
      }
    });
    this.value = radios[index].value;
    radios[index].checked = true;
    if (!this.hasButtonGroup) {
      radios[index].setAttribute("tabindex", "0");
      radios[index].focus();
    } else {
      radios[index].shadowRoot.querySelector("button").focus();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
    event.preventDefault();
  }
  handleLabelClick() {
    const radios = this.getAllRadios();
    const checked = radios.find((radio) => radio.checked);
    const radioToFocus = checked || radios[0];
    if (radioToFocus) {
      radioToFocus.focus();
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  async syncRadioElements() {
    var _a33, _b;
    const radios = this.getAllRadios();
    await Promise.all(
      // Sync the checked state and size
      radios.map(async (radio) => {
        await radio.updateComplete;
        radio.checked = radio.value === this.value;
        radio.size = this.size;
      })
    );
    this.hasButtonGroup = radios.some((radio) => radio.tagName.toLowerCase() === "sl-radio-button");
    if (radios.length > 0 && !radios.some((radio) => radio.checked)) {
      if (this.hasButtonGroup) {
        const buttonRadio = (_a33 = radios[0].shadowRoot) == null ? void 0 : _a33.querySelector("button");
        if (buttonRadio) {
          buttonRadio.setAttribute("tabindex", "0");
        }
      } else {
        radios[0].setAttribute("tabindex", "0");
      }
    }
    if (this.hasButtonGroup) {
      const buttonGroup = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector("sl-button-group");
      if (buttonGroup) {
        buttonGroup.disableRole = true;
      }
    }
  }
  syncRadios() {
    if (customElements.get("sl-radio") && customElements.get("sl-radio-button")) {
      this.syncRadioElements();
      return;
    }
    if (customElements.get("sl-radio")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio").then(() => this.syncRadios());
    }
    if (customElements.get("sl-radio-button")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio-button").then(() => this.syncRadios());
    }
  }
  updateCheckedRadio() {
    const radios = this.getAllRadios();
    radios.forEach((radio) => radio.checked = radio.value === this.value);
    this.formControlController.setValidity(this.validity.valid);
  }
  handleSizeChange() {
    this.syncRadios();
  }
  handleValueChange() {
    if (this.hasUpdated) {
      this.updateCheckedRadio();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (isRequiredAndEmpty || hasCustomValidityMessage) {
      this.formControlController.emitInvalidEvent();
      return false;
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    const isValid = this.validity.valid;
    this.errorMessage = this.customValidityMessage || isValid ? "" : this.validationInput.validationMessage;
    this.formControlController.setValidity(isValid);
    this.validationInput.hidden = true;
    clearTimeout(this.validationTimeout);
    if (!isValid) {
      this.validationInput.hidden = false;
      this.validationInput.reportValidity();
      this.validationTimeout = setTimeout(() => this.validationInput.hidden = true, 1e4);
    }
    return isValid;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message = "") {
    this.customValidityMessage = message;
    this.errorMessage = message;
    this.validationInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const defaultSlot = ke6`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
    return ke6`
      <fieldset
        part="form-control"
        class=${Rt3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--radio-group": true,
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${this.hasButtonGroup ? ke6`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${defaultSlot}
                </sl-button-group>
              ` : defaultSlot}
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = [component_styles_default3, form_control_styles_default, radio_group_styles_default];
SlRadioGroup.dependencies = { "sl-button-group": SlButtonGroup3 };
__decorateClass3([
  e54("slot:not([name])")
], SlRadioGroup.prototype, "defaultSlot", 2);
__decorateClass3([
  e54(".radio-group__validation-input")
], SlRadioGroup.prototype, "validationInput", 2);
__decorateClass3([
  r53()
], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass3([
  r53()
], SlRadioGroup.prototype, "errorMessage", 2);
__decorateClass3([
  r53()
], SlRadioGroup.prototype, "defaultValue", 2);
__decorateClass3([
  n53()
], SlRadioGroup.prototype, "label", 2);
__decorateClass3([
  n53({ attribute: "help-text" })
], SlRadioGroup.prototype, "helpText", 2);
__decorateClass3([
  n53()
], SlRadioGroup.prototype, "name", 2);
__decorateClass3([
  n53({ reflect: true })
], SlRadioGroup.prototype, "value", 2);
__decorateClass3([
  n53({ reflect: true })
], SlRadioGroup.prototype, "size", 2);
__decorateClass3([
  n53({ reflect: true })
], SlRadioGroup.prototype, "form", 2);
__decorateClass3([
  n53({ type: Boolean, reflect: true })
], SlRadioGroup.prototype, "required", 2);
__decorateClass3([
  watch3("size", { waitUntilFirstUpdate: true })
], SlRadioGroup.prototype, "handleSizeChange", 1);
__decorateClass3([
  watch3("value")
], SlRadioGroup.prototype, "handleValueChange", 1);
var plus_square_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-square" viewBox="0 0 16 16">%0A  <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2z"/>%0A  <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4"/>%0A</svg>';
var plus_circle_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-circle" viewBox="0 0 16 16">%0A  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>%0A  <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4"/>%0A</svg>';
function shuffle2(a33) {
  for (let i43 = a33.length - 1; i43 > 0; i43--) {
    const j33 = Math.floor(Math.random() * (i43 + 1));
    [a33[i43], a33[j33]] = [a33[j33], a33[i43]];
  }
  return a33;
}
var _itemsSlotEl_dec;
var _value_dec;
var _items_dec;
var _addItem_dec;
var _slotEl_dec3;
var _randomOrder_dec2;
var _layout_dec;
var _mode_dec;
var _a24;
var _WebwriterChoice_decorators;
var _init24;
var _mode;
var _randomOrder2;
var _slotEl3;
var _items;
var _value;
var _itemsSlotEl;
_WebwriterChoice_decorators = [t34("webwriter-choice")];
var WebwriterChoice = class extends (_a24 = LitElementWw4, _mode_dec = [n53({ type: String, attribute: true, reflect: true }), option2({
  type: "select",
  options: [
    { value: "truefalse", label: { "en": "True/False" } },
    { value: "single", label: { "en": "Single Choice" } },
    { value: "multiple", label: { "en": "Multiple Choice" } }
  ]
})], _layout_dec = [n53({ type: String, attribute: true, reflect: true }), option2({
  type: "select",
  options: [
    { value: "list", label: { "en": "List" } },
    { value: "tiles", label: { "en": "Tiles" } }
  ]
})], _randomOrder_dec2 = [n53({ type: Boolean, attribute: true, reflect: true }), option2({
  type: Boolean,
  label: { "en": "Random Choice Order" }
})], _slotEl_dec3 = [e54("slot")], _addItem_dec = [action()], _items_dec = [o53()], _value_dec = [n53({ type: Array, attribute: false })], _itemsSlotEl_dec = [e54("#items-slot")], _a24) {
  constructor() {
    super(...arguments);
    __runInitializers5(_init24, 5, this);
    __privateAdd6(this, _mode, __runInitializers5(_init24, 8, this, "single")), __runInitializers5(_init24, 11, this);
    __privateAdd6(this, _randomOrder2, __runInitializers5(_init24, 12, this, false)), __runInitializers5(_init24, 15, this);
    __privateAdd6(this, _slotEl3, __runInitializers5(_init24, 16, this)), __runInitializers5(_init24, 19, this);
    __privateAdd6(this, _items, __runInitializers5(_init24, 20, this)), __runInitializers5(_init24, 23, this);
    __privateAdd6(this, _value, []);
    __publicField5(this, "handleControlChange", (e73) => {
      if (this.mode === "single") {
        const item = e73.target;
        const otherItems = this.items.filter((el) => el !== item);
        otherItems.forEach((el) => this.isContentEditable ? el.valid = false : el.active = false);
      }
      this.applyValue();
      this.dispatchEvent(new CustomEvent("ww-answer-change", {
        detail: { value: this.value },
        bubbles: true,
        composed: true
      }));
    });
    __privateAdd6(this, _itemsSlotEl, __runInitializers5(_init24, 24, this)), __runInitializers5(_init24, 27, this);
  }
  get layout() {
    return this.children?.item(0)?.getAttribute("layout") ?? "list";
  }
  set layout(value) {
    this.querySelectorAll("webwriter-choice-item").forEach((el) => el.setAttribute("layout", value));
    this.requestUpdate("layout");
  }
  get solution() {
    const validIDs = this.items.filter((item) => item.valid).map((item) => item.id);
    return validIDs.length ? validIDs : void 0;
  }
  set solution(value) {
    this.items.forEach((item) => value.includes(item.id) ? item.valid = true : null);
  }
  reportSolution() {
    if (!this.solution) {
      this.items.forEach((item) => item.valid = true);
      return;
    }
    this.items.forEach((item) => item.valid = (this.solution ?? []).includes(item.id));
  }
  reset() {
    this.items.forEach((item) => {
      item.valid = void 0;
      item.active = false;
    });
    this.shuffleItems();
  }
  addItem() {
    const choiceItem = this.ownerDocument.createElement("webwriter-choice-item");
    const p33 = this.ownerDocument.createElement("p");
    choiceItem.appendChild(p33);
    choiceItem.setAttribute("layout", this.layout);
    this.appendChild(choiceItem);
    this.ownerDocument.getSelection().setBaseAndExtent(p33, 0, p33, 0);
  }
  shuffleItems() {
    const items = this.slotEl.assignedElements();
    const n63 = items.length;
    const nums = shuffle2([...new Array(n63).keys()]);
    items.forEach((el, i43) => el.style.order = String(nums[i43]));
  }
  connectedCallback() {
    super.connectedCallback();
    const observer = new MutationObserver(() => {
      if (!this.contentEditable && this.randomOrder) {
        this.shuffleItems();
      }
    });
    observer.observe(this, { childList: true });
  }
  firstUpdated(_changedProperties) {
    if (!this.contentEditable && this.randomOrder) {
      this.shuffleItems();
    }
  }
  get value() {
    return __privateGet6(this, _value);
  }
  set value(value) {
    __privateSet6(this, _value, value);
    this.items.forEach((item, i43) => {
      this.isContentEditable ? item.valid = __privateGet6(this, _value).includes(i43) : item.active = __privateGet6(this, _value).includes(i43);
    });
  }
  applyValue() {
    __privateSet6(this, _value, this.items.map((item, i43) => [item.valid, i43]).filter(([valid]) => valid).map(([_33, i43]) => i43));
  }
  handleSlotChange(e73) {
    this.requestUpdate();
  }
  willUpdate(changed) {
    if (changed.has("mode") && this.mode === "single") {
      this.items.filter((el) => this.isContentEditable ? el.valid : el.active).slice(1).forEach((el) => this.isContentEditable ? el.valid = false : el.active = false);
    }
    if (changed.has("mode") && this.mode === "truefalse") {
      this.items.forEach((el) => el.remove());
    }
  }
  render() {
    return ke6`
      ${this.mode === "truefalse" ? ke6`
          <sl-radio-group>
            <sl-radio-button value="true">True</sl-radio-button>
            <sl-radio-button value="false">False</sl-radio-button>
          </sl-radio-group>
        ` : ke6`
          <slot id="items-slot" @sl-change=${this.handleControlChange} @slotchange=${this.handleSlotChange}></slot>
        `}
      <sl-button size="small" id="add-option" class="author-only" @click=${() => this.addItem()}>
        <sl-icon src=${this.mode === "multiple" ? plus_square_default : plus_circle_default}></sl-icon><span>Add Option</span>
      </sl-button>
    `;
  }
};
_init24 = __decoratorStart5(_a24);
_mode = /* @__PURE__ */ new WeakMap();
_randomOrder2 = /* @__PURE__ */ new WeakMap();
_slotEl3 = /* @__PURE__ */ new WeakMap();
_items = /* @__PURE__ */ new WeakMap();
_value = /* @__PURE__ */ new WeakMap();
_itemsSlotEl = /* @__PURE__ */ new WeakMap();
__decorateElement5(_init24, 4, "mode", _mode_dec, WebwriterChoice, _mode);
__decorateElement5(_init24, 3, "layout", _layout_dec, WebwriterChoice);
__decorateElement5(_init24, 4, "randomOrder", _randomOrder_dec2, WebwriterChoice, _randomOrder2);
__decorateElement5(_init24, 4, "slotEl", _slotEl_dec3, WebwriterChoice, _slotEl3);
__decorateElement5(_init24, 1, "addItem", _addItem_dec, WebwriterChoice);
__decorateElement5(_init24, 4, "items", _items_dec, WebwriterChoice, _items);
__decorateElement5(_init24, 3, "value", _value_dec, WebwriterChoice);
__decorateElement5(_init24, 4, "itemsSlotEl", _itemsSlotEl_dec, WebwriterChoice, _itemsSlotEl);
WebwriterChoice = __decorateElement5(_init24, 0, "WebwriterChoice", _WebwriterChoice_decorators, WebwriterChoice);
__publicField5(WebwriterChoice, "scopedElements", {
  "sl-button": SlButton3,
  "sl-icon": SlIcon3,
  "sl-radio": SlRadio,
  "sl-checkbox": SlCheckbox,
  "sl-radio-button": SlRadioButton,
  "sl-radio-group": SlRadioGroup
});
__publicField5(WebwriterChoice, "styles", i5`
    :host {
      display: flex !important;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }

    :host([layout=tiles]) {

      flex-direction: row;
      flex-wrap: wrap;
      gap: 15px;

      & ::slotted(*) {
        aspect-ratio: 1;
        min-width: 125px;
        width: 125px;
        max-width: 350px;
        min-height: 125px;
        height: 125px;
        max-height: 350px;
        overflow: hidden;
        resize: both;
        border: 2px solid var(--sl-color-gray-500);
        border-radius: 5px;
      }
    }

    sl-button::part(label) {
      padding: 0;
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    sl-button::part(base) {
      border: none;
      background: transparent;
    }

    sl-icon {
      width: 19px;
      height: 19px;
    }

    sl-icon::part(svg) {
      overflow: visible;
    }

    :host(:not([contenteditable=true]):not([contenteditable=""])) .author-only {
      display: none !important;
    }

    #add-option span {
      margin-inline-start: 0.5em;
    }

    :host(:is([contenteditable=true], [contenteditable=""])) ::slotted(*) {
      order: unset !important;
    }

    :host(:not([mode=multiple])) {
      --webwriter-choice-radius: 100%;
    }

    #add-option:not(:hover)::part(base) {
      color: darkgray;
    }

    :host([layout=tiles]) #add-option {
      width: 125px;
      height: 125px;
      overflow: hidden;
      border: 2px solid var(--sl-color-gray-300);
      border-radius: 5px;
      padding: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([mode=truefalse]) #add-option {
      display: none;
    }    
  `);
__runInitializers5(_init24, 1, WebwriterChoice);

// https:/cdn.jsdelivr.net/npm/@webwriter/quiz@1.0.5/dist/widgets/webwriter-choice-item.js
var __create6 = Object.create;
var __defProp7 = Object.defineProperty;
var __getOwnPropDesc7 = Object.getOwnPropertyDescriptor;
var __knownSymbol6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name6 = (target, value) => __defProp7(target, "name", { value, configurable: true });
var __decoratorStart6 = (base) => [, , , __create6(base?.[__knownSymbol6("metadata")] ?? null)];
var __decoratorStrings6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn6 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError6("Function expected") : fn;
var __decoratorContext6 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings6[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError6("Already initialized") : fns.push(__expectFn6(fn || null)) });
var __decoratorMetadata6 = (array, target) => __defNormalProp7(target, __knownSymbol6("metadata"), array[3]);
var __runInitializers6 = (array, flags, self2, value) => {
  for (var i43 = 0, fns = array[flags >> 1], n63 = fns && fns.length; i43 < n63; i43++) flags & 1 ? fns[i43].call(self2) : value = fns[i43].call(self2, value);
  return value;
};
var __decorateElement6 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k33 = flags & 7, s33 = !!(flags & 8), p33 = !!(flags & 16);
  var j33 = k33 > 3 ? array.length + 1 : k33 ? s33 ? 1 : 2 : 0, key = __decoratorStrings6[k33 + 5];
  var initializers = k33 > 3 && (array[j33 - 1] = []), extraInitializers = array[j33] || (array[j33] = []);
  var desc = k33 && (!p33 && !s33 && (target = target.prototype), k33 < 5 && (k33 > 3 || !p33) && __getOwnPropDesc7(k33 < 4 ? target : { get [name]() {
    return __privateGet7(this, extra);
  }, set [name](x32) {
    return __privateSet7(this, extra, x32);
  } }, name));
  k33 ? p33 && k33 < 4 && __name6(extra, (k33 > 2 ? "set " : k33 > 1 ? "get " : "") + name) : __name6(target, name);
  for (var i43 = decorators.length - 1; i43 >= 0; i43--) {
    ctx = __decoratorContext6(k33, name, done = {}, array[3], extraInitializers);
    if (k33) {
      ctx.static = s33, ctx.private = p33, access = ctx.access = { has: p33 ? (x32) => __privateIn6(target, x32) : (x32) => name in x32 };
      if (k33 ^ 3) access.get = p33 ? (x32) => (k33 ^ 1 ? __privateGet7 : __privateMethod6)(x32, target, k33 ^ 4 ? extra : desc.get) : (x32) => x32[name];
      if (k33 > 2) access.set = p33 ? (x32, y33) => __privateSet7(x32, target, y33, k33 ^ 4 ? extra : desc.set) : (x32, y33) => x32[name] = y33;
    }
    it = (0, decorators[i43])(k33 ? k33 < 4 ? p33 ? extra : desc[key] : k33 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k33 ^ 4 || it === void 0) __expectFn6(it) && (k33 > 4 ? initializers.unshift(it) : k33 ? p33 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError6("Object expected");
    else __expectFn6(fn = it.get) && (desc.get = fn), __expectFn6(fn = it.set) && (desc.set = fn), __expectFn6(fn = it.init) && initializers.unshift(fn);
  }
  return k33 || __decoratorMetadata6(array, target), desc && __defProp7(target, name, desc), p33 ? k33 ^ 4 ? extra : desc : target;
};
var __publicField6 = (obj, key, value) => __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateIn6 = (member, obj) => Object(obj) !== obj ? __typeError6('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet7 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod6 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var t9 = globalThis;
var e10 = t9.ShadowRoot && (void 0 === t9.ShadyCSS || t9.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s6 = Symbol();
var o10 = /* @__PURE__ */ new WeakMap();
var n9 = class {
  constructor(t54, e73, o55) {
    if (this._$cssResult$ = true, o55 !== s6) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t54, this.t = e73;
  }
  get styleSheet() {
    let t54 = this.o;
    const s33 = this.t;
    if (e10 && void 0 === t54) {
      const e73 = void 0 !== s33 && 1 === s33.length;
      e73 && (t54 = o10.get(s33)), void 0 === t54 && ((this.o = t54 = new CSSStyleSheet()).replaceSync(this.cssText), e73 && o10.set(s33, t54));
    }
    return t54;
  }
  toString() {
    return this.cssText;
  }
};
var r10 = (t54) => new n9("string" == typeof t54 ? t54 : t54 + "", void 0, s6);
var i6 = (t54, ...e73) => {
  const o55 = 1 === t54.length ? t54[0] : e73.reduce((e83, s33, o64) => e83 + ((t64) => {
    if (true === t64._$cssResult$) return t64.cssText;
    if ("number" == typeof t64) return t64;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t64 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s33) + t54[o64 + 1], t54[0]);
  return new n9(o55, t54, s6);
};
var S7 = (s33, o55) => {
  if (e10) s33.adoptedStyleSheets = o55.map((t54) => t54 instanceof CSSStyleSheet ? t54 : t54.styleSheet);
  else for (const e73 of o55) {
    const o64 = document.createElement("style"), n63 = t9.litNonce;
    void 0 !== n63 && o64.setAttribute("nonce", n63), o64.textContent = e73.cssText, s33.appendChild(o64);
  }
};
var c8 = e10 ? (t54) => t54 : (t54) => t54 instanceof CSSStyleSheet ? ((t64) => {
  let e73 = "";
  for (const s33 of t64.cssRules) e73 += s33.cssText;
  return r10(e73);
})(t54) : t54;
var { is: i26, defineProperty: e26, getOwnPropertyDescriptor: r26, getOwnPropertyNames: h8, getOwnPropertySymbols: o26, getPrototypeOf: n26 } = Object;
var a6 = globalThis;
var c26 = a6.trustedTypes;
var l6 = c26 ? c26.emptyScript : "";
var p6 = a6.reactiveElementPolyfillSupport;
var d6 = (t54, s33) => t54;
var u6 = { toAttribute(t54, s33) {
  switch (s33) {
    case Boolean:
      t54 = t54 ? l6 : null;
      break;
    case Object:
    case Array:
      t54 = null == t54 ? t54 : JSON.stringify(t54);
  }
  return t54;
}, fromAttribute(t54, s33) {
  let i43 = t54;
  switch (s33) {
    case Boolean:
      i43 = null !== t54;
      break;
    case Number:
      i43 = null === t54 ? null : Number(t54);
      break;
    case Object:
    case Array:
      try {
        i43 = JSON.parse(t54);
      } catch (t64) {
        i43 = null;
      }
  }
  return i43;
} };
var f8 = (t54, s33) => !i26(t54, s33);
var y6 = { attribute: true, type: String, converter: u6, reflect: false, hasChanged: f8 };
Symbol.metadata ??= Symbol("metadata"), a6.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b6 = class extends HTMLElement {
  static addInitializer(t54) {
    this._$Ei(), (this.l ??= []).push(t54);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t54, s33 = y6) {
    if (s33.state && (s33.attribute = false), this._$Ei(), this.elementProperties.set(t54, s33), !s33.noAccessor) {
      const i43 = Symbol(), r64 = this.getPropertyDescriptor(t54, i43, s33);
      void 0 !== r64 && e26(this.prototype, t54, r64);
    }
  }
  static getPropertyDescriptor(t54, s33, i43) {
    const { get: e73, set: h53 } = r26(this.prototype, t54) ?? { get() {
      return this[s33];
    }, set(t64) {
      this[s33] = t64;
    } };
    return { get() {
      return e73?.call(this);
    }, set(s43) {
      const r64 = e73?.call(this);
      h53.call(this, s43), this.requestUpdate(t54, r64, i43);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t54) {
    return this.elementProperties.get(t54) ?? y6;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d6("elementProperties"))) return;
    const t54 = n26(this);
    t54.finalize(), void 0 !== t54.l && (this.l = [...t54.l]), this.elementProperties = new Map(t54.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d6("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d6("properties"))) {
      const t64 = this.properties, s33 = [...h8(t64), ...o26(t64)];
      for (const i43 of s33) this.createProperty(i43, t64[i43]);
    }
    const t54 = this[Symbol.metadata];
    if (null !== t54) {
      const s33 = litPropertyMetadata.get(t54);
      if (void 0 !== s33) for (const [t64, i43] of s33) this.elementProperties.set(t64, i43);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t64, s33] of this.elementProperties) {
      const i43 = this._$Eu(t64, s33);
      void 0 !== i43 && this._$Eh.set(i43, t64);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s33) {
    const i43 = [];
    if (Array.isArray(s33)) {
      const e73 = new Set(s33.flat(1 / 0).reverse());
      for (const s43 of e73) i43.unshift(c8(s43));
    } else void 0 !== s33 && i43.push(c8(s33));
    return i43;
  }
  static _$Eu(t54, s33) {
    const i43 = s33.attribute;
    return false === i43 ? void 0 : "string" == typeof i43 ? i43 : "string" == typeof t54 ? t54.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t54) => this.enableUpdating = t54), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t54) => t54(this));
  }
  addController(t54) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t54), void 0 !== this.renderRoot && this.isConnected && t54.hostConnected?.();
  }
  removeController(t54) {
    this._$EO?.delete(t54);
  }
  _$E_() {
    const t54 = /* @__PURE__ */ new Map(), s33 = this.constructor.elementProperties;
    for (const i43 of s33.keys()) this.hasOwnProperty(i43) && (t54.set(i43, this[i43]), delete this[i43]);
    t54.size > 0 && (this._$Ep = t54);
  }
  createRenderRoot() {
    const t54 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S7(t54, this.constructor.elementStyles), t54;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t54) => t54.hostConnected?.());
  }
  enableUpdating(t54) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t54) => t54.hostDisconnected?.());
  }
  attributeChangedCallback(t54, s33, i43) {
    this._$AK(t54, i43);
  }
  _$EC(t54, s33) {
    const i43 = this.constructor.elementProperties.get(t54), e73 = this.constructor._$Eu(t54, i43);
    if (void 0 !== e73 && true === i43.reflect) {
      const r64 = (void 0 !== i43.converter?.toAttribute ? i43.converter : u6).toAttribute(s33, i43.type);
      this._$Em = t54, null == r64 ? this.removeAttribute(e73) : this.setAttribute(e73, r64), this._$Em = null;
    }
  }
  _$AK(t54, s33) {
    const i43 = this.constructor, e73 = i43._$Eh.get(t54);
    if (void 0 !== e73 && this._$Em !== e73) {
      const t64 = i43.getPropertyOptions(e73), r64 = "function" == typeof t64.converter ? { fromAttribute: t64.converter } : void 0 !== t64.converter?.fromAttribute ? t64.converter : u6;
      this._$Em = e73, this[e73] = r64.fromAttribute(s33, t64.type), this._$Em = null;
    }
  }
  requestUpdate(t54, s33, i43) {
    if (void 0 !== t54) {
      if (i43 ??= this.constructor.getPropertyOptions(t54), !(i43.hasChanged ?? f8)(this[t54], s33)) return;
      this.P(t54, s33, i43);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t54, s33, i43) {
    this._$AL.has(t54) || this._$AL.set(t54, s33), true === i43.reflect && this._$Em !== t54 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t54);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t64) {
      Promise.reject(t64);
    }
    const t54 = this.scheduleUpdate();
    return null != t54 && await t54, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t73, s43] of this._$Ep) this[t73] = s43;
        this._$Ep = void 0;
      }
      const t64 = this.constructor.elementProperties;
      if (t64.size > 0) for (const [s43, i43] of t64) true !== i43.wrapped || this._$AL.has(s43) || void 0 === this[s43] || this.P(s43, this[s43], i43);
    }
    let t54 = false;
    const s33 = this._$AL;
    try {
      t54 = this.shouldUpdate(s33), t54 ? (this.willUpdate(s33), this._$EO?.forEach((t64) => t64.hostUpdate?.()), this.update(s33)) : this._$EU();
    } catch (s43) {
      throw t54 = false, this._$EU(), s43;
    }
    t54 && this._$AE(s33);
  }
  willUpdate(t54) {
  }
  _$AE(t54) {
    this._$EO?.forEach((t64) => t64.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t54)), this.updated(t54);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t54) {
    return true;
  }
  update(t54) {
    this._$Ej &&= this._$Ej.forEach((t64) => this._$EC(t64, this[t64])), this._$EU();
  }
  updated(t54) {
  }
  firstUpdated(t54) {
  }
};
b6.elementStyles = [], b6.shadowRootOptions = { mode: "open" }, b6[d6("elementProperties")] = /* @__PURE__ */ new Map(), b6[d6("finalized")] = /* @__PURE__ */ new Map(), p6?.({ ReactiveElement: b6 }), (a6.reactiveElementVersions ??= []).push("2.0.4");
var n36 = globalThis;
var c36 = n36.trustedTypes;
var h26 = c36 ? c36.createPolicy("lit-html", { createHTML: (t54) => t54 }) : void 0;
var f26 = "$lit$";
var v6 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m6 = "?" + v6;
var _6 = `<${m6}>`;
var w6 = document;
var lt6 = () => w6.createComment("");
var st6 = (t54) => null === t54 || "object" != typeof t54 && "function" != typeof t54;
var g6 = Array.isArray;
var $6 = (t54) => g6(t54) || "function" == typeof t54?.[Symbol.iterator];
var x6 = "[ 	\n\f\r]";
var T6 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E6 = /-->/g;
var k6 = />/g;
var O6 = RegExp(`>|${x6}(?:([^\\s"'>=/]+)(${x6}*=${x6}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S26 = /'/g;
var j6 = /"/g;
var M6 = /^(?:script|style|textarea|title)$/i;
var P6 = (t54) => (i43, ...s33) => ({ _$litType$: t54, strings: i43, values: s33 });
var ke7 = P6(1);
var Oe7 = P6(2);
var Se7 = P6(3);
var R6 = Symbol.for("lit-noChange");
var D6 = Symbol.for("lit-nothing");
var V6 = /* @__PURE__ */ new WeakMap();
var I6 = w6.createTreeWalker(w6, 129);
function N6(t54, i43) {
  if (!g6(t54) || !t54.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h26 ? h26.createHTML(i43) : i43;
}
var U6 = (t54, i43) => {
  const s33 = t54.length - 1, e73 = [];
  let h53, o55 = 2 === i43 ? "<svg>" : 3 === i43 ? "<math>" : "", n63 = T6;
  for (let i53 = 0; i53 < s33; i53++) {
    const s43 = t54[i53];
    let r64, l33, c53 = -1, a33 = 0;
    for (; a33 < s43.length && (n63.lastIndex = a33, l33 = n63.exec(s43), null !== l33); ) a33 = n63.lastIndex, n63 === T6 ? "!--" === l33[1] ? n63 = E6 : void 0 !== l33[1] ? n63 = k6 : void 0 !== l33[2] ? (M6.test(l33[2]) && (h53 = RegExp("</" + l33[2], "g")), n63 = O6) : void 0 !== l33[3] && (n63 = O6) : n63 === O6 ? ">" === l33[0] ? (n63 = h53 ?? T6, c53 = -1) : void 0 === l33[1] ? c53 = -2 : (c53 = n63.lastIndex - l33[2].length, r64 = l33[1], n63 = void 0 === l33[3] ? O6 : '"' === l33[3] ? j6 : S26) : n63 === j6 || n63 === S26 ? n63 = O6 : n63 === E6 || n63 === k6 ? n63 = T6 : (n63 = O6, h53 = void 0);
    const u33 = n63 === O6 && t54[i53 + 1].startsWith("/>") ? " " : "";
    o55 += n63 === T6 ? s43 + _6 : c53 >= 0 ? (e73.push(r64), s43.slice(0, c53) + f26 + s43.slice(c53) + v6 + u33) : s43 + v6 + (-2 === c53 ? i53 : u33);
  }
  return [N6(t54, o55 + (t54[s33] || "<?>") + (2 === i43 ? "</svg>" : 3 === i43 ? "</math>" : "")), e73];
};
var B6 = class _B25 {
  constructor({ strings: t54, _$litType$: i43 }, s33) {
    let e73;
    this.parts = [];
    let h53 = 0, o55 = 0;
    const n63 = t54.length - 1, r64 = this.parts, [l33, a33] = U6(t54, i43);
    if (this.el = _B25.createElement(l33, s33), I6.currentNode = this.el.content, 2 === i43 || 3 === i43) {
      const t64 = this.el.content.firstChild;
      t64.replaceWith(...t64.childNodes);
    }
    for (; null !== (e73 = I6.nextNode()) && r64.length < n63; ) {
      if (1 === e73.nodeType) {
        if (e73.hasAttributes()) for (const t64 of e73.getAttributeNames()) if (t64.endsWith(f26)) {
          const i53 = a33[o55++], s43 = e73.getAttribute(t64).split(v6), n73 = /([.?@])?(.*)/.exec(i53);
          r64.push({ type: 1, index: h53, name: n73[2], strings: s43, ctor: "." === n73[1] ? Y6 : "?" === n73[1] ? Z6 : "@" === n73[1] ? q6 : G6 }), e73.removeAttribute(t64);
        } else t64.startsWith(v6) && (r64.push({ type: 6, index: h53 }), e73.removeAttribute(t64));
        if (M6.test(e73.tagName)) {
          const t64 = e73.textContent.split(v6), i53 = t64.length - 1;
          if (i53 > 0) {
            e73.textContent = c36 ? c36.emptyScript : "";
            for (let s43 = 0; s43 < i53; s43++) e73.append(t64[s43], lt6()), I6.nextNode(), r64.push({ type: 2, index: ++h53 });
            e73.append(t64[i53], lt6());
          }
        }
      } else if (8 === e73.nodeType) if (e73.data === m6) r64.push({ type: 2, index: h53 });
      else {
        let t64 = -1;
        for (; -1 !== (t64 = e73.data.indexOf(v6, t64 + 1)); ) r64.push({ type: 7, index: h53 }), t64 += v6.length - 1;
      }
      h53++;
    }
  }
  static createElement(t54, i43) {
    const s33 = w6.createElement("template");
    return s33.innerHTML = t54, s33;
  }
};
function z6(t54, i43, s33 = t54, e73) {
  if (i43 === R6) return i43;
  let h53 = void 0 !== e73 ? s33.o?.[e73] : s33.l;
  const o55 = st6(i43) ? void 0 : i43._$litDirective$;
  return h53?.constructor !== o55 && (h53?._$AO?.(false), void 0 === o55 ? h53 = void 0 : (h53 = new o55(t54), h53._$AT(t54, s33, e73)), void 0 !== e73 ? (s33.o ??= [])[e73] = h53 : s33.l = h53), void 0 !== h53 && (i43 = z6(t54, h53._$AS(t54, i43.values), h53, e73)), i43;
}
var F6 = class {
  constructor(t54, i43) {
    this._$AV = [], this._$AN = void 0, this._$AD = t54, this._$AM = i43;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t54) {
    const { el: { content: i43 }, parts: s33 } = this._$AD, e73 = (t54?.creationScope ?? w6).importNode(i43, true);
    I6.currentNode = e73;
    let h53 = I6.nextNode(), o55 = 0, n63 = 0, r64 = s33[0];
    for (; void 0 !== r64; ) {
      if (o55 === r64.index) {
        let i53;
        2 === r64.type ? i53 = new et7(h53, h53.nextSibling, this, t54) : 1 === r64.type ? i53 = new r64.ctor(h53, r64.name, r64.strings, this, t54) : 6 === r64.type && (i53 = new K6(h53, this, t54)), this._$AV.push(i53), r64 = s33[++n63];
      }
      o55 !== r64?.index && (h53 = I6.nextNode(), o55++);
    }
    return I6.currentNode = w6, e73;
  }
  p(t54) {
    let i43 = 0;
    for (const s33 of this._$AV) void 0 !== s33 && (void 0 !== s33.strings ? (s33._$AI(t54, s33, i43), i43 += s33.strings.length - 2) : s33._$AI(t54[i43])), i43++;
  }
};
var et7 = class _et25 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t54, i43, s33, e73) {
    this.type = 2, this._$AH = D6, this._$AN = void 0, this._$AA = t54, this._$AB = i43, this._$AM = s33, this.options = e73, this.v = e73?.isConnected ?? true;
  }
  get parentNode() {
    let t54 = this._$AA.parentNode;
    const i43 = this._$AM;
    return void 0 !== i43 && 11 === t54?.nodeType && (t54 = i43.parentNode), t54;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t54, i43 = this) {
    t54 = z6(this, t54, i43), st6(t54) ? t54 === D6 || null == t54 || "" === t54 ? (this._$AH !== D6 && this._$AR(), this._$AH = D6) : t54 !== this._$AH && t54 !== R6 && this._(t54) : void 0 !== t54._$litType$ ? this.$(t54) : void 0 !== t54.nodeType ? this.T(t54) : $6(t54) ? this.k(t54) : this._(t54);
  }
  O(t54) {
    return this._$AA.parentNode.insertBefore(t54, this._$AB);
  }
  T(t54) {
    this._$AH !== t54 && (this._$AR(), this._$AH = this.O(t54));
  }
  _(t54) {
    this._$AH !== D6 && st6(this._$AH) ? this._$AA.nextSibling.data = t54 : this.T(w6.createTextNode(t54)), this._$AH = t54;
  }
  $(t54) {
    const { values: i43, _$litType$: s33 } = t54, e73 = "number" == typeof s33 ? this._$AC(t54) : (void 0 === s33.el && (s33.el = B6.createElement(N6(s33.h, s33.h[0]), this.options)), s33);
    if (this._$AH?._$AD === e73) this._$AH.p(i43);
    else {
      const t64 = new F6(e73, this), s43 = t64.u(this.options);
      t64.p(i43), this.T(s43), this._$AH = t64;
    }
  }
  _$AC(t54) {
    let i43 = V6.get(t54.strings);
    return void 0 === i43 && V6.set(t54.strings, i43 = new B6(t54)), i43;
  }
  k(t54) {
    g6(this._$AH) || (this._$AH = [], this._$AR());
    const i43 = this._$AH;
    let s33, e73 = 0;
    for (const h53 of t54) e73 === i43.length ? i43.push(s33 = new _et25(this.O(lt6()), this.O(lt6()), this, this.options)) : s33 = i43[e73], s33._$AI(h53), e73++;
    e73 < i43.length && (this._$AR(s33 && s33._$AB.nextSibling, e73), i43.length = e73);
  }
  _$AR(t54 = this._$AA.nextSibling, i43) {
    for (this._$AP?.(false, true, i43); t54 && t54 !== this._$AB; ) {
      const i53 = t54.nextSibling;
      t54.remove(), t54 = i53;
    }
  }
  setConnected(t54) {
    void 0 === this._$AM && (this.v = t54, this._$AP?.(t54));
  }
};
var G6 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t54, i43, s33, e73, h53) {
    this.type = 1, this._$AH = D6, this._$AN = void 0, this.element = t54, this.name = i43, this._$AM = e73, this.options = h53, s33.length > 2 || "" !== s33[0] || "" !== s33[1] ? (this._$AH = Array(s33.length - 1).fill(new String()), this.strings = s33) : this._$AH = D6;
  }
  _$AI(t54, i43 = this, s33, e73) {
    const h53 = this.strings;
    let o55 = false;
    if (void 0 === h53) t54 = z6(this, t54, i43, 0), o55 = !st6(t54) || t54 !== this._$AH && t54 !== R6, o55 && (this._$AH = t54);
    else {
      const e83 = t54;
      let n63, r64;
      for (t54 = h53[0], n63 = 0; n63 < h53.length - 1; n63++) r64 = z6(this, e83[s33 + n63], i43, n63), r64 === R6 && (r64 = this._$AH[n63]), o55 ||= !st6(r64) || r64 !== this._$AH[n63], r64 === D6 ? t54 = D6 : t54 !== D6 && (t54 += (r64 ?? "") + h53[n63 + 1]), this._$AH[n63] = r64;
    }
    o55 && !e73 && this.j(t54);
  }
  j(t54) {
    t54 === D6 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t54 ?? "");
  }
};
var Y6 = class extends G6 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t54) {
    this.element[this.name] = t54 === D6 ? void 0 : t54;
  }
};
var Z6 = class extends G6 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t54) {
    this.element.toggleAttribute(this.name, !!t54 && t54 !== D6);
  }
};
var q6 = class extends G6 {
  constructor(t54, i43, s33, e73, h53) {
    super(t54, i43, s33, e73, h53), this.type = 5;
  }
  _$AI(t54, i43 = this) {
    if ((t54 = z6(this, t54, i43, 0) ?? D6) === R6) return;
    const s33 = this._$AH, e73 = t54 === D6 && s33 !== D6 || t54.capture !== s33.capture || t54.once !== s33.once || t54.passive !== s33.passive, h53 = t54 !== D6 && (s33 === D6 || e73);
    e73 && this.element.removeEventListener(this.name, this, s33), h53 && this.element.addEventListener(this.name, this, t54), this._$AH = t54;
  }
  handleEvent(t54) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t54) : this._$AH.handleEvent(t54);
  }
};
var K6 = class {
  constructor(t54, i43, s33) {
    this.element = t54, this.type = 6, this._$AN = void 0, this._$AM = i43, this.options = s33;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t54) {
    z6(this, t54);
  }
};
var si4 = { M: f26, P: v6, A: m6, C: 1, L: U6, R: F6, D: $6, V: z6, I: et7, H: G6, N: Z6, U: q6, B: Y6, F: K6 };
var Re6 = n36.litHtmlPolyfillSupport;
Re6?.(B6, et7), (n36.litHtmlVersions ??= []).push("3.2.0");
var Q6 = (t54, i43, s33) => {
  const e73 = s33?.renderBefore ?? i43;
  let h53 = e73._$litPart$;
  if (void 0 === h53) {
    const t64 = s33?.renderBefore ?? null;
    e73._$litPart$ = h53 = new et7(i43.insertBefore(lt6(), t64), t64, void 0, s33 ?? {});
  }
  return h53._$AI(t54), h53;
};
var h36 = class extends b6 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t54 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t54.firstChild, t54;
  }
  update(t54) {
    const e73 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t54), this.o = Q6(e73, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R6;
  }
};
h36._$litElement$ = true, h36["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h36 });
var f36 = globalThis.litElementPolyfillSupport;
f36?.({ LitElement: h36 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var t25 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e35 = (t54) => (...e73) => ({ _$litDirective$: t54, values: e73 });
var i35 = class {
  constructor(t54) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t54, e73, i43) {
    this.t = t54, this._$AM = e73, this.i = i43;
  }
  _$AS(t54, e73) {
    return this.update(t54, e73);
  }
  update(t54, e73) {
    return this.render(...e73);
  }
};
var ee3 = "important";
var ie3 = " !" + ee3;
var se3 = e35(class extends i35 {
  constructor(e73) {
    if (super(e73), e73.type !== t25.ATTRIBUTE || "style" !== e73.name || e73.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t54) {
    return Object.keys(t54).reduce((e73, r64) => {
      const s33 = t54[r64];
      return null == s33 ? e73 : e73 + `${r64 = r64.includes("-") ? r64 : r64.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s33};`;
    }, "");
  }
  update(t54, [e73]) {
    const { style: r64 } = t54.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(e73)), this.render(e73);
    for (const t64 of this.ft) null == e73[t64] && (this.ft.delete(t64), t64.includes("-") ? r64.removeProperty(t64) : r64[t64] = null);
    for (const t64 in e73) {
      const s33 = e73[t64];
      if (null != s33) {
        this.ft.add(t64);
        const e83 = "string" == typeof s33 && s33.endsWith(ie3);
        t64.includes("-") || e83 ? r64.setProperty(t64, e83 ? s33.slice(0, -11) : s33, e83 ? ee3 : "") : r64[t64] = s33;
      }
    }
    return R6;
  }
});
var Rt4 = e35(class extends i35 {
  constructor(s33) {
    if (super(s33), s33.type !== t25.ATTRIBUTE || "class" !== s33.name || s33.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t54) {
    return " " + Object.keys(t54).filter((s33) => t54[s33]).join(" ") + " ";
  }
  update(t54, [s33]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t54.strings && (this.nt = new Set(t54.strings.join(" ").split(/\s/).filter((t64) => "" !== t64)));
      for (const t64 in s33) s33[t64] && !this.nt?.has(t64) && this.st.add(t64);
      return this.render(s33);
    }
    const i43 = t54.element.classList;
    for (const t64 of this.st) t64 in s33 || (i43.remove(t64), this.st.delete(t64));
    for (const t64 in s33) {
      const r64 = !!s33[t64];
      r64 === this.st.has(t64) || this.nt?.has(t64) || (r64 ? (i43.add(t64), this.st.add(t64)) : (i43.remove(t64), this.st.delete(t64)));
    }
    return R6;
  }
});
var __create25 = Object.create;
var __defProp25 = Object.defineProperty;
var __getOwnPropDesc25 = Object.getOwnPropertyDescriptor;
var __knownSymbol25 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError25 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp25 = (obj, key, value) => key in obj ? __defProp25(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name25 = (target, value) => __defProp25(target, "name", { value, configurable: true });
var __decoratorStart25 = (base) => [, , , __create25(base?.[__knownSymbol25("metadata")] ?? null)];
var __decoratorStrings25 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn25 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError25("Function expected") : fn;
var __decoratorContext25 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings25[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError25("Already initialized") : fns.push(__expectFn25(fn || null)) });
var __decoratorMetadata25 = (array, target) => __defNormalProp25(target, __knownSymbol25("metadata"), array[3]);
var __runInitializers25 = (array, flags, self2, value) => {
  for (var i322 = 0, fns = array[flags >> 1], n522 = fns && fns.length; i322 < n522; i322++) flags & 1 ? fns[i322].call(self2) : value = fns[i322].call(self2, value);
  return value;
};
var __decorateElement25 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k222 = flags & 7, s222 = !!(flags & 8), p222 = !!(flags & 16);
  var j222 = k222 > 3 ? array.length + 1 : k222 ? s222 ? 1 : 2 : 0, key = __decoratorStrings25[k222 + 5];
  var initializers = k222 > 3 && (array[j222 - 1] = []), extraInitializers = array[j222] || (array[j222] = []);
  var desc = k222 && (!p222 && !s222 && (target = target.prototype), k222 < 5 && (k222 > 3 || !p222) && __getOwnPropDesc25(k222 < 4 ? target : { get [name]() {
    return __privateGet25(this, extra);
  }, set [name](x222) {
    return __privateSet25(this, extra, x222);
  } }, name));
  k222 ? p222 && k222 < 4 && __name25(extra, (k222 > 2 ? "set " : k222 > 1 ? "get " : "") + name) : __name25(target, name);
  for (var i322 = decorators.length - 1; i322 >= 0; i322--) {
    ctx = __decoratorContext25(k222, name, done = {}, array[3], extraInitializers);
    if (k222) {
      ctx.static = s222, ctx.private = p222, access = ctx.access = { has: p222 ? (x222) => __privateIn25(target, x222) : (x222) => name in x222 };
      if (k222 ^ 3) access.get = p222 ? (x222) => (k222 ^ 1 ? __privateGet25 : __privateMethod25)(x222, target, k222 ^ 4 ? extra : desc.get) : (x222) => x222[name];
      if (k222 > 2) access.set = p222 ? (x222, y222) => __privateSet25(x222, target, y222, k222 ^ 4 ? extra : desc.set) : (x222, y222) => x222[name] = y222;
    }
    it = (0, decorators[i322])(k222 ? k222 < 4 ? p222 ? extra : desc[key] : k222 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k222 ^ 4 || it === void 0) __expectFn25(it) && (k222 > 4 ? initializers.unshift(it) : k222 ? p222 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError25("Object expected");
    else __expectFn25(fn = it.get) && (desc.get = fn), __expectFn25(fn = it.set) && (desc.set = fn), __expectFn25(fn = it.init) && initializers.unshift(fn);
  }
  return k222 || __decoratorMetadata25(array, target), desc && __defProp25(target, name, desc), p222 ? k222 ^ 4 ? extra : desc : target;
};
var __publicField24 = (obj, key, value) => __defNormalProp25(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck25 = (obj, member, msg) => member.has(obj) || __typeError25("Cannot " + msg);
var __privateIn25 = (member, obj) => Object(obj) !== obj ? __typeError25('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet25 = (obj, member, getter) => (__accessCheck25(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd24 = (obj, member, value) => member.has(obj) ? __typeError25("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet25 = (obj, member, value, setter) => (__accessCheck25(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod25 = (obj, member, method) => (__accessCheck25(obj, member, "access private method"), method);
var t35 = globalThis;
var e44 = t35.ShadowRoot && (void 0 === t35.ShadyCSS || t35.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s25 = Symbol();
var o36 = /* @__PURE__ */ new WeakMap();
var n46 = class {
  constructor(t222, e422, o422) {
    if (this._$cssResult$ = true, o422 !== s25) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t222, this.t = e422;
  }
  get styleSheet() {
    let t222 = this.o;
    const s222 = this.t;
    if (e44 && void 0 === t222) {
      const e422 = void 0 !== s222 && 1 === s222.length;
      e422 && (t222 = o36.get(s222)), void 0 === t222 && ((this.o = t222 = new CSSStyleSheet()).replaceSync(this.cssText), e422 && o36.set(s222, t222));
    }
    return t222;
  }
  toString() {
    return this.cssText;
  }
};
var r36 = (t222) => new n46("string" == typeof t222 ? t222 : t222 + "", void 0, s25);
var S35 = (s222, o422) => {
  if (e44) s222.adoptedStyleSheets = o422.map((t222) => t222 instanceof CSSStyleSheet ? t222 : t222.styleSheet);
  else for (const e422 of o422) {
    const o55 = document.createElement("style"), n522 = t35.litNonce;
    void 0 !== n522 && o55.setAttribute("nonce", n522), o55.textContent = e422.cssText, s222.appendChild(o55);
  }
};
var c45 = e44 ? (t222) => t222 : (t222) => t222 instanceof CSSStyleSheet ? ((t322) => {
  let e422 = "";
  for (const s222 of t322.cssRules) e422 += s222.cssText;
  return r36(e422);
})(t222) : t222;
var { is: i225, defineProperty: e225, getOwnPropertyDescriptor: r225, getOwnPropertyNames: h45, getOwnPropertySymbols: o225, getPrototypeOf: n225 } = Object;
var a25 = globalThis;
var c225 = a25.trustedTypes;
var l25 = c225 ? c225.emptyScript : "";
var p25 = a25.reactiveElementPolyfillSupport;
var d25 = (t222, s222) => t222;
var u25 = { toAttribute(t222, s222) {
  switch (s222) {
    case Boolean:
      t222 = t222 ? l25 : null;
      break;
    case Object:
    case Array:
      t222 = null == t222 ? t222 : JSON.stringify(t222);
  }
  return t222;
}, fromAttribute(t222, s222) {
  let i322 = t222;
  switch (s222) {
    case Boolean:
      i322 = null !== t222;
      break;
    case Number:
      i322 = null === t222 ? null : Number(t222);
      break;
    case Object:
    case Array:
      try {
        i322 = JSON.parse(t222);
      } catch (t322) {
        i322 = null;
      }
  }
  return i322;
} };
var f45 = (t222, s222) => !i225(t222, s222);
var y25 = { attribute: true, type: String, converter: u25, reflect: false, hasChanged: f45 };
Symbol.metadata ??= Symbol("metadata"), a25.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b25 = class extends HTMLElement {
  static addInitializer(t222) {
    this._$Ei(), (this.l ??= []).push(t222);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t222, s222 = y25) {
    if (s222.state && (s222.attribute = false), this._$Ei(), this.elementProperties.set(t222, s222), !s222.noAccessor) {
      const i322 = Symbol(), r422 = this.getPropertyDescriptor(t222, i322, s222);
      void 0 !== r422 && e225(this.prototype, t222, r422);
    }
  }
  static getPropertyDescriptor(t222, s222, i322) {
    const { get: e422, set: h422 } = r225(this.prototype, t222) ?? { get() {
      return this[s222];
    }, set(t322) {
      this[s222] = t322;
    } };
    return { get() {
      return e422?.call(this);
    }, set(s33) {
      const r422 = e422?.call(this);
      h422.call(this, s33), this.requestUpdate(t222, r422, i322);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t222) {
    return this.elementProperties.get(t222) ?? y25;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d25("elementProperties"))) return;
    const t222 = n225(this);
    t222.finalize(), void 0 !== t222.l && (this.l = [...t222.l]), this.elementProperties = new Map(t222.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d25("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d25("properties"))) {
      const t322 = this.properties, s222 = [...h45(t322), ...o225(t322)];
      for (const i322 of s222) this.createProperty(i322, t322[i322]);
    }
    const t222 = this[Symbol.metadata];
    if (null !== t222) {
      const s222 = litPropertyMetadata.get(t222);
      if (void 0 !== s222) for (const [t322, i322] of s222) this.elementProperties.set(t322, i322);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t322, s222] of this.elementProperties) {
      const i322 = this._$Eu(t322, s222);
      void 0 !== i322 && this._$Eh.set(i322, t322);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s222) {
    const i322 = [];
    if (Array.isArray(s222)) {
      const e422 = new Set(s222.flat(1 / 0).reverse());
      for (const s33 of e422) i322.unshift(c45(s33));
    } else void 0 !== s222 && i322.push(c45(s222));
    return i322;
  }
  static _$Eu(t222, s222) {
    const i322 = s222.attribute;
    return false === i322 ? void 0 : "string" == typeof i322 ? i322 : "string" == typeof t222 ? t222.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t222) => this.enableUpdating = t222), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t222) => t222(this));
  }
  addController(t222) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t222), void 0 !== this.renderRoot && this.isConnected && t222.hostConnected?.();
  }
  removeController(t222) {
    this._$EO?.delete(t222);
  }
  _$E_() {
    const t222 = /* @__PURE__ */ new Map(), s222 = this.constructor.elementProperties;
    for (const i322 of s222.keys()) this.hasOwnProperty(i322) && (t222.set(i322, this[i322]), delete this[i322]);
    t222.size > 0 && (this._$Ep = t222);
  }
  createRenderRoot() {
    const t222 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S35(t222, this.constructor.elementStyles), t222;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t222) => t222.hostConnected?.());
  }
  enableUpdating(t222) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t222) => t222.hostDisconnected?.());
  }
  attributeChangedCallback(t222, s222, i322) {
    this._$AK(t222, i322);
  }
  _$EC(t222, s222) {
    const i322 = this.constructor.elementProperties.get(t222), e422 = this.constructor._$Eu(t222, i322);
    if (void 0 !== e422 && true === i322.reflect) {
      const r422 = (void 0 !== i322.converter?.toAttribute ? i322.converter : u25).toAttribute(s222, i322.type);
      this._$Em = t222, null == r422 ? this.removeAttribute(e422) : this.setAttribute(e422, r422), this._$Em = null;
    }
  }
  _$AK(t222, s222) {
    const i322 = this.constructor, e422 = i322._$Eh.get(t222);
    if (void 0 !== e422 && this._$Em !== e422) {
      const t322 = i322.getPropertyOptions(e422), r422 = "function" == typeof t322.converter ? { fromAttribute: t322.converter } : void 0 !== t322.converter?.fromAttribute ? t322.converter : u25;
      this._$Em = e422, this[e422] = r422.fromAttribute(s222, t322.type), this._$Em = null;
    }
  }
  requestUpdate(t222, s222, i322) {
    if (void 0 !== t222) {
      if (i322 ??= this.constructor.getPropertyOptions(t222), !(i322.hasChanged ?? f45)(this[t222], s222)) return;
      this.P(t222, s222, i322);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t222, s222, i322) {
    this._$AL.has(t222) || this._$AL.set(t222, s222), true === i322.reflect && this._$Em !== t222 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t222);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t322) {
      Promise.reject(t322);
    }
    const t222 = this.scheduleUpdate();
    return null != t222 && await t222, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t422, s33] of this._$Ep) this[t422] = s33;
        this._$Ep = void 0;
      }
      const t322 = this.constructor.elementProperties;
      if (t322.size > 0) for (const [s33, i322] of t322) true !== i322.wrapped || this._$AL.has(s33) || void 0 === this[s33] || this.P(s33, this[s33], i322);
    }
    let t222 = false;
    const s222 = this._$AL;
    try {
      t222 = this.shouldUpdate(s222), t222 ? (this.willUpdate(s222), this._$EO?.forEach((t322) => t322.hostUpdate?.()), this.update(s222)) : this._$EU();
    } catch (s33) {
      throw t222 = false, this._$EU(), s33;
    }
    t222 && this._$AE(s222);
  }
  willUpdate(t222) {
  }
  _$AE(t222) {
    this._$EO?.forEach((t322) => t322.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t222)), this.updated(t222);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t222) {
    return true;
  }
  update(t222) {
    this._$Ej &&= this._$Ej.forEach((t322) => this._$EC(t322, this[t322])), this._$EU();
  }
  updated(t222) {
  }
  firstUpdated(t222) {
  }
};
b25.elementStyles = [], b25.shadowRootOptions = { mode: "open" }, b25[d25("elementProperties")] = /* @__PURE__ */ new Map(), b25[d25("finalized")] = /* @__PURE__ */ new Map(), p25?.({ ReactiveElement: b25 }), (a25.reactiveElementVersions ??= []).push("2.0.4");
var n325 = globalThis;
var c325 = n325.trustedTypes;
var h225 = c325 ? c325.createPolicy("lit-html", { createHTML: (t222) => t222 }) : void 0;
var f225 = "$lit$";
var v25 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m25 = "?" + v25;
var _25 = `<${m25}>`;
var w25 = document;
var lt25 = () => w25.createComment("");
var st25 = (t222) => null === t222 || "object" != typeof t222 && "function" != typeof t222;
var g25 = Array.isArray;
var $25 = (t222) => g25(t222) || "function" == typeof t222?.[Symbol.iterator];
var x25 = "[ 	\n\f\r]";
var T25 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E25 = /-->/g;
var k25 = />/g;
var O25 = RegExp(`>|${x25}(?:([^\\s"'>=/]+)(${x25}*=${x25}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S225 = /'/g;
var j25 = /"/g;
var M25 = /^(?:script|style|textarea|title)$/i;
var P25 = (t222) => (i322, ...s222) => ({ _$litType$: t222, strings: i322, values: s222 });
var ke25 = P25(1);
var Oe25 = P25(2);
var Se25 = P25(3);
var R25 = Symbol.for("lit-noChange");
var D25 = Symbol.for("lit-nothing");
var V25 = /* @__PURE__ */ new WeakMap();
var I25 = w25.createTreeWalker(w25, 129);
function N25(t222, i322) {
  if (!g25(t222) || !t222.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h225 ? h225.createHTML(i322) : i322;
}
var U25 = (t222, i322) => {
  const s222 = t222.length - 1, e422 = [];
  let h422, o422 = 2 === i322 ? "<svg>" : 3 === i322 ? "<math>" : "", n522 = T25;
  for (let i43 = 0; i43 < s222; i43++) {
    const s33 = t222[i43];
    let r422, l222, c422 = -1, a222 = 0;
    for (; a222 < s33.length && (n522.lastIndex = a222, l222 = n522.exec(s33), null !== l222); ) a222 = n522.lastIndex, n522 === T25 ? "!--" === l222[1] ? n522 = E25 : void 0 !== l222[1] ? n522 = k25 : void 0 !== l222[2] ? (M25.test(l222[2]) && (h422 = RegExp("</" + l222[2], "g")), n522 = O25) : void 0 !== l222[3] && (n522 = O25) : n522 === O25 ? ">" === l222[0] ? (n522 = h422 ?? T25, c422 = -1) : void 0 === l222[1] ? c422 = -2 : (c422 = n522.lastIndex - l222[2].length, r422 = l222[1], n522 = void 0 === l222[3] ? O25 : '"' === l222[3] ? j25 : S225) : n522 === j25 || n522 === S225 ? n522 = O25 : n522 === E25 || n522 === k25 ? n522 = T25 : (n522 = O25, h422 = void 0);
    const u222 = n522 === O25 && t222[i43 + 1].startsWith("/>") ? " " : "";
    o422 += n522 === T25 ? s33 + _25 : c422 >= 0 ? (e422.push(r422), s33.slice(0, c422) + f225 + s33.slice(c422) + v25 + u222) : s33 + v25 + (-2 === c422 ? i43 : u222);
  }
  return [N25(t222, o422 + (t222[s222] || "<?>") + (2 === i322 ? "</svg>" : 3 === i322 ? "</math>" : "")), e422];
};
var B25 = class _B6 {
  constructor({ strings: t222, _$litType$: i322 }, s222) {
    let e422;
    this.parts = [];
    let h422 = 0, o422 = 0;
    const n522 = t222.length - 1, r422 = this.parts, [l222, a222] = U25(t222, i322);
    if (this.el = _B6.createElement(l222, s222), I25.currentNode = this.el.content, 2 === i322 || 3 === i322) {
      const t322 = this.el.content.firstChild;
      t322.replaceWith(...t322.childNodes);
    }
    for (; null !== (e422 = I25.nextNode()) && r422.length < n522; ) {
      if (1 === e422.nodeType) {
        if (e422.hasAttributes()) for (const t322 of e422.getAttributeNames()) if (t322.endsWith(f225)) {
          const i43 = a222[o422++], s33 = e422.getAttribute(t322).split(v25), n63 = /([.?@])?(.*)/.exec(i43);
          r422.push({ type: 1, index: h422, name: n63[2], strings: s33, ctor: "." === n63[1] ? Y25 : "?" === n63[1] ? Z25 : "@" === n63[1] ? q25 : G25 }), e422.removeAttribute(t322);
        } else t322.startsWith(v25) && (r422.push({ type: 6, index: h422 }), e422.removeAttribute(t322));
        if (M25.test(e422.tagName)) {
          const t322 = e422.textContent.split(v25), i43 = t322.length - 1;
          if (i43 > 0) {
            e422.textContent = c325 ? c325.emptyScript : "";
            for (let s33 = 0; s33 < i43; s33++) e422.append(t322[s33], lt25()), I25.nextNode(), r422.push({ type: 2, index: ++h422 });
            e422.append(t322[i43], lt25());
          }
        }
      } else if (8 === e422.nodeType) if (e422.data === m25) r422.push({ type: 2, index: h422 });
      else {
        let t322 = -1;
        for (; -1 !== (t322 = e422.data.indexOf(v25, t322 + 1)); ) r422.push({ type: 7, index: h422 }), t322 += v25.length - 1;
      }
      h422++;
    }
  }
  static createElement(t222, i322) {
    const s222 = w25.createElement("template");
    return s222.innerHTML = t222, s222;
  }
};
function z25(t222, i322, s222 = t222, e422) {
  if (i322 === R25) return i322;
  let h422 = void 0 !== e422 ? s222.o?.[e422] : s222.l;
  const o422 = st25(i322) ? void 0 : i322._$litDirective$;
  return h422?.constructor !== o422 && (h422?._$AO?.(false), void 0 === o422 ? h422 = void 0 : (h422 = new o422(t222), h422._$AT(t222, s222, e422)), void 0 !== e422 ? (s222.o ??= [])[e422] = h422 : s222.l = h422), void 0 !== h422 && (i322 = z25(t222, h422._$AS(t222, i322.values), h422, e422)), i322;
}
var F25 = class {
  constructor(t222, i322) {
    this._$AV = [], this._$AN = void 0, this._$AD = t222, this._$AM = i322;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t222) {
    const { el: { content: i322 }, parts: s222 } = this._$AD, e422 = (t222?.creationScope ?? w25).importNode(i322, true);
    I25.currentNode = e422;
    let h422 = I25.nextNode(), o422 = 0, n522 = 0, r422 = s222[0];
    for (; void 0 !== r422; ) {
      if (o422 === r422.index) {
        let i43;
        2 === r422.type ? i43 = new et25(h422, h422.nextSibling, this, t222) : 1 === r422.type ? i43 = new r422.ctor(h422, r422.name, r422.strings, this, t222) : 6 === r422.type && (i43 = new K25(h422, this, t222)), this._$AV.push(i43), r422 = s222[++n522];
      }
      o422 !== r422?.index && (h422 = I25.nextNode(), o422++);
    }
    return I25.currentNode = w25, e422;
  }
  p(t222) {
    let i322 = 0;
    for (const s222 of this._$AV) void 0 !== s222 && (void 0 !== s222.strings ? (s222._$AI(t222, s222, i322), i322 += s222.strings.length - 2) : s222._$AI(t222[i322])), i322++;
  }
};
var et25 = class _et6 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t222, i322, s222, e422) {
    this.type = 2, this._$AH = D25, this._$AN = void 0, this._$AA = t222, this._$AB = i322, this._$AM = s222, this.options = e422, this.v = e422?.isConnected ?? true;
  }
  get parentNode() {
    let t222 = this._$AA.parentNode;
    const i322 = this._$AM;
    return void 0 !== i322 && 11 === t222?.nodeType && (t222 = i322.parentNode), t222;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t222, i322 = this) {
    t222 = z25(this, t222, i322), st25(t222) ? t222 === D25 || null == t222 || "" === t222 ? (this._$AH !== D25 && this._$AR(), this._$AH = D25) : t222 !== this._$AH && t222 !== R25 && this._(t222) : void 0 !== t222._$litType$ ? this.$(t222) : void 0 !== t222.nodeType ? this.T(t222) : $25(t222) ? this.k(t222) : this._(t222);
  }
  O(t222) {
    return this._$AA.parentNode.insertBefore(t222, this._$AB);
  }
  T(t222) {
    this._$AH !== t222 && (this._$AR(), this._$AH = this.O(t222));
  }
  _(t222) {
    this._$AH !== D25 && st25(this._$AH) ? this._$AA.nextSibling.data = t222 : this.T(w25.createTextNode(t222)), this._$AH = t222;
  }
  $(t222) {
    const { values: i322, _$litType$: s222 } = t222, e422 = "number" == typeof s222 ? this._$AC(t222) : (void 0 === s222.el && (s222.el = B25.createElement(N25(s222.h, s222.h[0]), this.options)), s222);
    if (this._$AH?._$AD === e422) this._$AH.p(i322);
    else {
      const t322 = new F25(e422, this), s33 = t322.u(this.options);
      t322.p(i322), this.T(s33), this._$AH = t322;
    }
  }
  _$AC(t222) {
    let i322 = V25.get(t222.strings);
    return void 0 === i322 && V25.set(t222.strings, i322 = new B25(t222)), i322;
  }
  k(t222) {
    g25(this._$AH) || (this._$AH = [], this._$AR());
    const i322 = this._$AH;
    let s222, e422 = 0;
    for (const h422 of t222) e422 === i322.length ? i322.push(s222 = new _et6(this.O(lt25()), this.O(lt25()), this, this.options)) : s222 = i322[e422], s222._$AI(h422), e422++;
    e422 < i322.length && (this._$AR(s222 && s222._$AB.nextSibling, e422), i322.length = e422);
  }
  _$AR(t222 = this._$AA.nextSibling, i322) {
    for (this._$AP?.(false, true, i322); t222 && t222 !== this._$AB; ) {
      const i43 = t222.nextSibling;
      t222.remove(), t222 = i43;
    }
  }
  setConnected(t222) {
    void 0 === this._$AM && (this.v = t222, this._$AP?.(t222));
  }
};
var G25 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t222, i322, s222, e422, h422) {
    this.type = 1, this._$AH = D25, this._$AN = void 0, this.element = t222, this.name = i322, this._$AM = e422, this.options = h422, s222.length > 2 || "" !== s222[0] || "" !== s222[1] ? (this._$AH = Array(s222.length - 1).fill(new String()), this.strings = s222) : this._$AH = D25;
  }
  _$AI(t222, i322 = this, s222, e422) {
    const h422 = this.strings;
    let o422 = false;
    if (void 0 === h422) t222 = z25(this, t222, i322, 0), o422 = !st25(t222) || t222 !== this._$AH && t222 !== R25, o422 && (this._$AH = t222);
    else {
      const e522 = t222;
      let n522, r422;
      for (t222 = h422[0], n522 = 0; n522 < h422.length - 1; n522++) r422 = z25(this, e522[s222 + n522], i322, n522), r422 === R25 && (r422 = this._$AH[n522]), o422 ||= !st25(r422) || r422 !== this._$AH[n522], r422 === D25 ? t222 = D25 : t222 !== D25 && (t222 += (r422 ?? "") + h422[n522 + 1]), this._$AH[n522] = r422;
    }
    o422 && !e422 && this.j(t222);
  }
  j(t222) {
    t222 === D25 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t222 ?? "");
  }
};
var Y25 = class extends G25 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t222) {
    this.element[this.name] = t222 === D25 ? void 0 : t222;
  }
};
var Z25 = class extends G25 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t222) {
    this.element.toggleAttribute(this.name, !!t222 && t222 !== D25);
  }
};
var q25 = class extends G25 {
  constructor(t222, i322, s222, e422, h422) {
    super(t222, i322, s222, e422, h422), this.type = 5;
  }
  _$AI(t222, i322 = this) {
    if ((t222 = z25(this, t222, i322, 0) ?? D25) === R25) return;
    const s222 = this._$AH, e422 = t222 === D25 && s222 !== D25 || t222.capture !== s222.capture || t222.once !== s222.once || t222.passive !== s222.passive, h422 = t222 !== D25 && (s222 === D25 || e422);
    e422 && this.element.removeEventListener(this.name, this, s222), h422 && this.element.addEventListener(this.name, this, t222), this._$AH = t222;
  }
  handleEvent(t222) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t222) : this._$AH.handleEvent(t222);
  }
};
var K25 = class {
  constructor(t222, i322, s222) {
    this.element = t222, this.type = 6, this._$AN = void 0, this._$AM = i322, this.options = s222;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t222) {
    z25(this, t222);
  }
};
var Re25 = n325.litHtmlPolyfillSupport;
Re25?.(B25, et25), (n325.litHtmlVersions ??= []).push("3.2.0");
var Q25 = (t222, i322, s222) => {
  const e422 = s222?.renderBefore ?? i322;
  let h422 = e422._$litPart$;
  if (void 0 === h422) {
    const t322 = s222?.renderBefore ?? null;
    e422._$litPart$ = h422 = new et25(i322.insertBefore(lt25(), t322), t322, void 0, s222 ?? {});
  }
  return h422._$AI(t222), h422;
};
var h325 = class extends b25 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t222 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t222.firstChild, t222;
  }
  update(t222) {
    const e422 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t222), this.o = Q25(e422, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R25;
  }
};
h325._$litElement$ = true, h325["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h325 });
var f325 = globalThis.litElementPolyfillSupport;
f325?.({ LitElement: h325 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o325 = { attribute: true, type: String, converter: u25, reflect: false, hasChanged: f45 };
var r325 = (t222 = o325, e422, r422) => {
  const { kind: n522, metadata: i322 } = r422;
  let s222 = globalThis.litPropertyMetadata.get(i322);
  if (void 0 === s222 && globalThis.litPropertyMetadata.set(i322, s222 = /* @__PURE__ */ new Map()), s222.set(r422.name, t222), "accessor" === n522) {
    const { name: o422 } = r422;
    return { set(r522) {
      const n63 = e422.get.call(this);
      e422.set.call(this, r522), this.requestUpdate(o422, n63, t222);
    }, init(e522) {
      return void 0 !== e522 && this.P(o422, void 0, t222), e522;
    } };
  }
  if ("setter" === n522) {
    const { name: o422 } = r422;
    return function(r522) {
      const n63 = this[o422];
      e422.call(this, r522), this.requestUpdate(o422, n63, t222);
    };
  }
  throw Error("Unsupported decorator location: " + n522);
};
function n425(t222) {
  return (e422, o422) => "object" == typeof o422 ? r325(t222, e422, o422) : ((t322, e522, o55) => {
    const r422 = e522.hasOwnProperty(o55);
    return e522.constructor.createProperty(o55, r422 ? { ...t322, wrapped: true } : t322), r422 ? Object.getOwnPropertyDescriptor(e522, o55) : void 0;
  })(t222, e422, o422);
}
var appliedClassMixins5 = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied5(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins5.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin5(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied5(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins5.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version5 = "3.0.0";
var versions5 = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions5.includes(version5)) {
  versions5.push(version5);
}
var ScopedElementsMixinImplementation6 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version5;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry22) {
      this.constructor.__registry = registry22;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin6 = dedupeMixin5(ScopedElementsMixinImplementation6);
var ScopedElementsMixinImplementation25 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin6(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S35(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin25 = dedupeMixin5(ScopedElementsMixinImplementation25);
var _lang_dec5;
var _contentEditable_dec5;
var _a6;
var _init6;
var _contentEditable5;
var _lang5;
var LitElementWw5 = class extends (_a6 = ScopedElementsMixin25(h325), _contentEditable_dec5 = [n425({ type: String, attribute: true, reflect: true })], _lang_dec5 = [n425({ type: String, attribute: true, reflect: true })], _a6) {
  constructor() {
    super(...arguments);
    __publicField24(this, "options");
    __publicField24(this, "actions", {});
    __privateAdd24(this, _contentEditable5, __runInitializers25(_init6, 8, this)), __runInitializers25(_init6, 11, this);
    __privateAdd24(this, _lang5, __runInitializers25(_init6, 12, this)), __runInitializers25(_init6, 15, this);
    __publicField24(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k222) => this.setAttribute(k222, this.getAttribute(k222)));
  }
};
_init6 = __decoratorStart25(_a6);
_contentEditable5 = /* @__PURE__ */ new WeakMap();
_lang5 = /* @__PURE__ */ new WeakMap();
__decorateElement25(_init6, 4, "contentEditable", _contentEditable_dec5, LitElementWw5, _contentEditable5);
__decorateElement25(_init6, 4, "lang", _lang_dec5, LitElementWw5, _lang5);
__decoratorMetadata25(_init6, LitElementWw5);
__publicField24(LitElementWw5, "shadowRootOptions", { ...h325.shadowRootOptions });
__publicField24(LitElementWw5, "options", {});
__publicField24(LitElementWw5, "actions", {});
var t45 = (t54) => (e73, o55) => {
  void 0 !== o55 ? o55.addInitializer(() => {
    customElements.define(t54, e73);
  }) : customElements.define(t54, e73);
};
var o44 = { attribute: true, type: String, converter: u6, reflect: false, hasChanged: f8 };
var r44 = (t54 = o44, e73, r64) => {
  const { kind: n63, metadata: i43 } = r64;
  let s33 = globalThis.litPropertyMetadata.get(i43);
  if (void 0 === s33 && globalThis.litPropertyMetadata.set(i43, s33 = /* @__PURE__ */ new Map()), s33.set(r64.name, t54), "accessor" === n63) {
    const { name: o55 } = r64;
    return { set(r73) {
      const n73 = e73.get.call(this);
      e73.set.call(this, r73), this.requestUpdate(o55, n73, t54);
    }, init(e83) {
      return void 0 !== e83 && this.P(o55, void 0, t54), e83;
    } };
  }
  if ("setter" === n63) {
    const { name: o55 } = r64;
    return function(r73) {
      const n73 = this[o55];
      e73.call(this, r73), this.requestUpdate(o55, n73, t54);
    };
  }
  throw Error("Unsupported decorator location: " + n63);
};
function n54(t54) {
  return (e73, o55) => "object" == typeof o55 ? r44(t54, e73, o55) : ((t64, e83, o64) => {
    const r64 = e83.hasOwnProperty(o64);
    return e83.constructor.createProperty(o64, r64 ? { ...t64, wrapped: true } : t64), r64 ? Object.getOwnPropertyDescriptor(e83, o64) : void 0;
  })(t54, e73, o55);
}
function r54(r64) {
  return n54({ ...r64, state: true, attribute: false });
}
var e55 = (e73, t54, c53) => (c53.configurable = true, c53.enumerable = true, Reflect.decorate && "object" != typeof t54 && Object.defineProperty(e73, t54, c53), c53);
function e64(e73, r64) {
  return (n63, s33, i43) => {
    const o55 = (t54) => t54.renderRoot?.querySelector(e73) ?? null;
    if (r64) {
      const { get: e83, set: r73 } = "object" == typeof s33 ? n63 : i43 ?? (() => {
        const t54 = Symbol();
        return { get() {
          return this[t54];
        }, set(e93) {
          this[t54] = e93;
        } };
      })();
      return e55(n63, s33, { get() {
        let t54 = e83.call(this);
        return void 0 === t54 && (t54 = o55(this), (null !== t54 || this.hasUpdated) && r73.call(this, t54)), t54;
      } });
    }
    return e55(n63, s33, { get() {
      return o55(this);
    } });
  };
}
var radio_styles_default2 = i6`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`;
var basePath4 = "";
function setBasePath4(path) {
  basePath4 = path;
}
function getBasePath4(subpath = "") {
  if (!basePath4) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath4(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s33) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s33.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s33.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath4(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath4.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}
var library4 = {
  name: "default",
  resolver: (name) => getBasePath4(`assets/icons/${name}.svg`)
};
var library_default_default4 = library4;
var icons4 = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary4 = {
  name: "system",
  resolver: (name) => {
    if (name in icons4) {
      return `data:image/svg+xml,${encodeURIComponent(icons4[name])}`;
    }
    return "";
  }
};
var library_system_default4 = systemLibrary4;
var registry4 = [library_default_default4, library_system_default4];
var watchedIcons4 = [];
function watchIcon4(icon) {
  watchedIcons4.push(icon);
}
function unwatchIcon4(icon) {
  watchedIcons4 = watchedIcons4.filter((el) => el !== icon);
}
function getIconLibrary4(name) {
  return registry4.find((lib) => lib.name === name);
}
var icon_styles_default4 = i6`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
var __defProp34 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDesc34 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp34 = (obj, key, value) => key in obj ? __defProp34(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a33, b33) => {
  for (var prop in b33 || (b33 = {}))
    if (__hasOwnProp4.call(b33, prop))
      __defNormalProp34(a33, prop, b33[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b33)) {
      if (__propIsEnum4.call(b33, prop))
        __defNormalProp34(a33, prop, b33[prop]);
    }
  return a33;
};
var __spreadProps4 = (a33, b33) => __defProps4(a33, __getOwnPropDescs4(b33));
var __decorateClass4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc34(target, key) : target;
  for (var i43 = decorators.length - 1, decorator; i43 >= 0; i43--)
    if (decorator = decorators[i43])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp34(target, key, result);
  return result;
};
var __accessCheck34 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet34 = (obj, member, getter) => {
  __accessCheck34(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd34 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet34 = (obj, member, value, setter) => {
  __accessCheck34(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
function watch4(propertyName, options) {
  const resolvedOptions = __spreadValues4({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update5 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update5.call(this, changedProps);
    };
  };
}
var component_styles_default4 = i6`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
var _hasRecordedInitialProperties4;
var ShoelaceElement4 = class extends h36 {
  constructor() {
    super();
    __privateAdd34(this, _hasRecordedInitialProperties4, false);
    this.initialReflectedProperties = /* @__PURE__ */ new Map();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues4({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      try {
        customElements.define(name, elementConstructor, options);
      } catch (_err) {
        customElements.define(name, class extends elementConstructor {
        }, options);
      }
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (!__privateGet34(this, _hasRecordedInitialProperties4)) {
      this.constructor.elementProperties.forEach(
        (obj, prop) => {
          if (obj.reflect && this[prop] != null) {
            this.initialReflectedProperties.set(prop, this[prop]);
          }
        }
      );
      __privateSet34(this, _hasRecordedInitialProperties4, true);
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    this.initialReflectedProperties.forEach((value, prop) => {
      if (changedProperties.has(prop) && this[prop] == null) {
        this[prop] = value;
      }
    });
  }
};
_hasRecordedInitialProperties4 = /* @__PURE__ */ new WeakMap();
ShoelaceElement4.version = "2.17.1";
ShoelaceElement4.dependencies = {};
__decorateClass4([
  n54()
], ShoelaceElement4.prototype, "dir", 2);
__decorateClass4([
  n54()
], ShoelaceElement4.prototype, "lang", 2);
var { I: et34 } = si4;
var nt4 = (o55, t54) => void 0 === t54 ? void 0 !== o55?._$litType$ : o55?._$litType$ === t54;
var rt3 = (o55) => void 0 === o55.strings;
var ht2 = {};
var dt2 = (o55, t54 = ht2) => o55._$AH = t54;
var CACHEABLE_ERROR4 = Symbol();
var RETRYABLE_ERROR4 = Symbol();
var parser4;
var iconCache4 = /* @__PURE__ */ new Map();
var SlIcon4 = class extends ShoelaceElement4 {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library22) {
    var _a33;
    let fileData;
    if (library22 == null ? void 0 : library22.spriteSheet) {
      this.svg = ke7`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR4 : RETRYABLE_ERROR4;
    } catch (e73) {
      return RETRYABLE_ERROR4;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a33 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a33.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR4;
      if (!parser4)
        parser4 = new DOMParser();
      const doc = parser4.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR4;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e73) {
      return CACHEABLE_ERROR4;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon4(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon4(this);
  }
  getIconSource() {
    const library22 = getIconLibrary4(this.library);
    if (this.name && library22) {
      return {
        url: library22.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a33;
    const { url, fromLibrary } = this.getIconSource();
    const library22 = fromLibrary ? getIconLibrary4(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache4.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library22);
      iconCache4.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR4) {
      iconCache4.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt4(svg)) {
      this.svg = svg;
      if (library22) {
        await this.updateComplete;
        const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library22.mutator === "function" && shadowSVG) {
          library22.mutator(shadowSVG);
        }
      }
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR4:
      case CACHEABLE_ERROR4:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a33 = library22 == null ? void 0 : library22.mutator) == null ? void 0 : _a33.call(library22, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon4.styles = [component_styles_default4, icon_styles_default4];
__decorateClass4([
  r54()
], SlIcon4.prototype, "svg", 2);
__decorateClass4([
  n54({ reflect: true })
], SlIcon4.prototype, "name", 2);
__decorateClass4([
  n54()
], SlIcon4.prototype, "src", 2);
__decorateClass4([
  n54()
], SlIcon4.prototype, "label", 2);
__decorateClass4([
  n54({ reflect: true })
], SlIcon4.prototype, "library", 2);
__decorateClass4([
  watch4("label")
], SlIcon4.prototype, "handleLabelChange", 1);
__decorateClass4([
  watch4(["name", "src", "library"])
], SlIcon4.prototype, "setIcon", 1);
var SlRadio2 = class extends ShoelaceElement4 {
  constructor() {
    super();
    this.checked = false;
    this.hasFocus = false;
    this.size = "medium";
    this.disabled = false;
    this.handleBlur = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.handleClick = () => {
      if (!this.disabled) {
        this.checked = true;
      }
    };
    this.handleFocus = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.addEventListener("blur", this.handleBlur);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback();
    this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio");
    this.setAttribute("tabindex", "-1");
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return ke7`
      <span
        part="base"
        class=${Rt4({
      radio: true,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus,
      "radio--small": this.size === "small",
      "radio--medium": this.size === "medium",
      "radio--large": this.size === "large"
    })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? ke7` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio2.styles = [component_styles_default4, radio_styles_default2];
SlRadio2.dependencies = { "sl-icon": SlIcon4 };
__decorateClass4([
  r54()
], SlRadio2.prototype, "checked", 2);
__decorateClass4([
  r54()
], SlRadio2.prototype, "hasFocus", 2);
__decorateClass4([
  n54()
], SlRadio2.prototype, "value", 2);
__decorateClass4([
  n54({ reflect: true })
], SlRadio2.prototype, "size", 2);
__decorateClass4([
  n54({ type: Boolean, reflect: true })
], SlRadio2.prototype, "disabled", 2);
__decorateClass4([
  watch4("checked")
], SlRadio2.prototype, "handleCheckedChange", 1);
__decorateClass4([
  watch4("disabled", { waitUntilFirstUpdate: true })
], SlRadio2.prototype, "handleDisabledChange", 1);
var checkbox_styles_default2 = i6`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;
var defaultValue2 = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a33;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u6;
      const fromAttribute = typeof converter === "function" ? converter : (_a33 = converter == null ? void 0 : converter.fromAttribute) != null ? _a33 : u6.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};
var form_control_styles_default2 = i6`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;
var formCollections4 = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads4 = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads4 = /* @__PURE__ */ new WeakMap();
var userInteractedControls4 = /* @__PURE__ */ new WeakSet();
var interactions4 = /* @__PURE__ */ new WeakMap();
var FormControlController4 = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a33;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a33 = formCollections4.get(this.form)) == null ? void 0 : _a33.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions4.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions4.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues4({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a33;
        return (_a33 = input.disabled) != null ? _a33 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions4.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions4.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections4.has(this.form)) {
        formCollections4.get(this.form).add(this.host);
      } else {
        formCollections4.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads4.has(this.form)) {
        reportValidityOverloads4.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads4.has(this.form)) {
        checkValidityOverloads4.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections4.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads4.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads4.get(this.form);
        reportValidityOverloads4.delete(this.form);
      }
      if (checkValidityOverloads4.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads4.get(this.form);
        checkValidityOverloads4.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls4.add(el);
    } else {
      userInteractedControls4.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a33;
    return (_a33 = this.form) != null ? _a33 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls4.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState4 = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState4 = Object.freeze(__spreadProps4(__spreadValues4({}, validValidityState4), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState4 = Object.freeze(__spreadProps4(__spreadValues4({}, validValidityState4), {
  valid: false,
  customError: true
}));
var HasSlotController4 = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
var to4 = (t54) => t54 ?? D6;
var Ft2 = e35(class extends i35 {
  constructor(r64) {
    if (super(r64), r64.type !== t25.PROPERTY && r64.type !== t25.ATTRIBUTE && r64.type !== t25.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt3(r64)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r64) {
    return r64;
  }
  update(r64, [e73]) {
    if (e73 === R6 || e73 === D6) return e73;
    const i43 = r64.element, n63 = r64.name;
    if (r64.type === t25.PROPERTY) {
      if (e73 === i43[n63]) return R6;
    } else if (r64.type === t25.BOOLEAN_ATTRIBUTE) {
      if (!!e73 === i43.hasAttribute(n63)) return R6;
    } else if (r64.type === t25.ATTRIBUTE && i43.getAttribute(n63) === e73 + "") return R6;
    return dt2(r64), e73;
  }
});
var SlCheckbox2 = class extends ShoelaceElement4 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController4(this, {
      value: (control) => control.checked ? control.value || "on" : void 0,
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController4(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke7`
      <div
        class=${Rt4({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${Rt4({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to4(this.value)}
            .indeterminate=${Ft2(this.indeterminate)}
            .checked=${Ft2(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? ke7`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? ke7`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox2.styles = [component_styles_default4, form_control_styles_default2, checkbox_styles_default2];
SlCheckbox2.dependencies = { "sl-icon": SlIcon4 };
__decorateClass4([
  e64('input[type="checkbox"]')
], SlCheckbox2.prototype, "input", 2);
__decorateClass4([
  r54()
], SlCheckbox2.prototype, "hasFocus", 2);
__decorateClass4([
  n54()
], SlCheckbox2.prototype, "title", 2);
__decorateClass4([
  n54()
], SlCheckbox2.prototype, "name", 2);
__decorateClass4([
  n54()
], SlCheckbox2.prototype, "value", 2);
__decorateClass4([
  n54({ reflect: true })
], SlCheckbox2.prototype, "size", 2);
__decorateClass4([
  n54({ type: Boolean, reflect: true })
], SlCheckbox2.prototype, "disabled", 2);
__decorateClass4([
  n54({ type: Boolean, reflect: true })
], SlCheckbox2.prototype, "checked", 2);
__decorateClass4([
  n54({ type: Boolean, reflect: true })
], SlCheckbox2.prototype, "indeterminate", 2);
__decorateClass4([
  defaultValue2("checked")
], SlCheckbox2.prototype, "defaultChecked", 2);
__decorateClass4([
  n54({ reflect: true })
], SlCheckbox2.prototype, "form", 2);
__decorateClass4([
  n54({ type: Boolean, reflect: true })
], SlCheckbox2.prototype, "required", 2);
__decorateClass4([
  n54({ attribute: "help-text" })
], SlCheckbox2.prototype, "helpText", 2);
__decorateClass4([
  watch4("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox2.prototype, "handleDisabledChange", 1);
__decorateClass4([
  watch4(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
], SlCheckbox2.prototype, "handleStateChange", 1);
var Bt = e35(class extends i35 {
  constructor() {
    super(...arguments), this.key = D6;
  }
  render(r64, t54) {
    return this.key = r64, t54;
  }
  update(r64, [t54, e73]) {
    return t54 !== this.key && (dt2(r64), this.key = t54), e73;
  }
});
var x_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">%0A  <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>%0A</svg>';
var check_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">%0A  <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>%0A</svg>';
var _checkbox_dec;
var _layout_dec2;
var _valid_dec;
var _active_dec;
var _a25;
var _WebwriterChoiceItem_decorators;
var _init25;
var _active;
var _valid;
var _layout;
var _checkbox;
_WebwriterChoiceItem_decorators = [t45("webwriter-choice-item")];
var _WebwriterChoiceItem = class _WebwriterChoiceItem2 extends (_a25 = LitElementWw5, _active_dec = [n54({ type: Boolean, attribute: false })], _valid_dec = [n54({ type: Boolean, attribute: false })], _layout_dec2 = [n54({ type: String, attribute: true, reflect: true })], _checkbox_dec = [e64("sl-checkbox")], _a25) {
  constructor() {
    super(...arguments);
    __publicField6(this, "msg", (str) => this.lang in _WebwriterChoiceItem2.localization ? _WebwriterChoiceItem2.localization[this.lang][str] ?? str : str);
    __privateAdd7(this, _active, __runInitializers6(_init25, 8, this, false)), __runInitializers6(_init25, 11, this);
    __privateAdd7(this, _valid, __runInitializers6(_init25, 12, this)), __runInitializers6(_init25, 15, this);
    __privateAdd7(this, _layout, __runInitializers6(_init25, 16, this, "list")), __runInitializers6(_init25, 19, this);
    __publicField6(this, "handleClick", (e73) => {
      const checkboxClicked = e73.composedPath().some((v33) => v33?.classList?.contains("checkbox__control"));
      const editable = this.isContentEditable;
      if (editable && !checkboxClicked) {
        e73.preventDefault();
      } else {
        e73.stopImmediatePropagation();
      }
    });
    __publicField6(this, "handleChange", (e73) => {
      if (this.isContentEditable) {
        this.valid = !this.valid;
      } else {
        this.active = !this.active;
      }
    });
    __privateAdd7(this, _checkbox, __runInitializers6(_init25, 20, this)), __runInitializers6(_init25, 23, this);
    __publicField6(this, "observer");
  }
  async updated(_changedProperties) {
    await this.checkbox.updateComplete;
    const labelEl = this.checkbox.shadowRoot.querySelector(".checkbox__label");
    if (_changedProperties.has("layout") && this.layout === "list") {
      this.syncSize(true);
      this.observer?.disconnect();
    } else if (_changedProperties.has("layout") && this.layout === "tiles") {
      this.syncSize();
      this.observer = new MutationObserver(() => this.syncSize());
      this.observer.observe(labelEl, { attributeFilter: ["style"], attributes: true });
    }
  }
  syncSize(clear = false) {
    const labelEl = this.checkbox?.shadowRoot.querySelector(".checkbox__label");
    if (labelEl && !clear) {
      this.style.width = labelEl.style.width;
      this.style.height = labelEl.style.height;
    } else if (labelEl && clear) {
      this.style.width = labelEl.style.width = null;
      this.style.height = labelEl.style.height = null;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.observer?.disconnect();
  }
  render() {
    return Bt(this.layout, ke7`
      ${this.valid !== void 0 && (this.active || !this.active && this.valid) ? ke7`<sl-icon class="solution user-only" ?data-valid=${this.valid} src=${this.valid ? check_default : x_default}></sl-icon>` : null}
      <sl-checkbox class=${Rt4({ valid: this.valid, active: this.active })} exportparts="base, control, label" @click=${this.handleClick} @sl-change=${this.handleChange} ?checked=${this.isContentEditable ? this.valid : this.active}>
        <slot part="slot" style=${se3({ "--ww-placeholder": `"${this.msg("Option")}"` })}></slot>
      </sl-checkbox>
    `);
  }
};
_init25 = __decoratorStart6(_a25);
_active = /* @__PURE__ */ new WeakMap();
_valid = /* @__PURE__ */ new WeakMap();
_layout = /* @__PURE__ */ new WeakMap();
_checkbox = /* @__PURE__ */ new WeakMap();
__decorateElement6(_init25, 4, "active", _active_dec, _WebwriterChoiceItem, _active);
__decorateElement6(_init25, 4, "valid", _valid_dec, _WebwriterChoiceItem, _valid);
__decorateElement6(_init25, 4, "layout", _layout_dec2, _WebwriterChoiceItem, _layout);
__decorateElement6(_init25, 4, "checkbox", _checkbox_dec, _WebwriterChoiceItem, _checkbox);
_WebwriterChoiceItem = __decorateElement6(_init25, 0, "WebwriterChoiceItem", _WebwriterChoiceItem_decorators, _WebwriterChoiceItem);
__publicField6(_WebwriterChoiceItem, "localization", {});
__publicField6(_WebwriterChoiceItem, "scopedElements", {
  "sl-radio": SlRadio2,
  "sl-checkbox": SlCheckbox2,
  "sl-icon": SlIcon4
});
__publicField6(_WebwriterChoiceItem, "styles", i6`

    :host {
      width: 100%;
      position: relative;
    }

    :host(:not([contenteditable=true]):not([contenteditable=""])) .author-only {
      display: none;
    }

    :host(:is([contenteditable=true], [contenteditable=""])) .user-only {
      display: none;
    }

    :host(:is([contenteditable=true], [contenteditable=""])) sl-checkbox.valid {
      --webwriter-control-color-600: var(--sl-color-success-600);
      --webwriter-control-color-400: var(--sl-color-success-400);
    }

    sl-checkbox {
      display: block;
      width: 100%;
      &::part(base) {
        width: 100%;
        display: flex;
        flex-direction: row;
        align-items: center;
        cursor: unset;
      }

      &::part(control) {
        cursor: pointer;
        border-radius: var(--webwriter-choice-radius, 2px);
        border-width: 2px;
      }

      &::part(control):not(:hover){
        border-color: var(--sl-color-gray-500);
      }

      &::part(control):hover {
        border-color: var(--sl-color-gray-700);
      }

      &::part(control--checked):not(:hover) {
        background-color: var(--webwriter-control-color-600, var(--sl-color-primary-600));
        border-color: var(--sl-color-gray-500);
      }
      &::part(control--checked):hover {
        background-color: var(--webwriter-control-color-400, var(--sl-color-primary-400));
        border-color: var(--webwriter-control-color-600, var(--sl-color-primary-600));
      }

      &::part(label) {
        width: 100%;
      }
    }

    .solution {
      position: absolute;
      top: -6px;
      left: -6px;
      border: 2px solid var(--sl-color-gray-500);
      border-radius: var(--webwriter-choice-radius, 2px);
      width: 12px;
      height: 12px;
      z-index: 1;
      color: white;

      &[data-valid] {
        background: var(--sl-color-success-600);
      }

      &:not([data-valid]) {
        background: var(--sl-color-danger-600);
      }
    }

    :host([layout=tiles]) {
      position: relative;
      overflow: visible !important;

      & ::slotted(:is(picture, audio, video, img, iframe)) {
        height: 100%;
        width: 100%;
      }

      & ::slotted(:not(:is(picture, audio, video, img, iframe))) {
        margin: 5px !important;
      }

      sl-checkbox {
      display: block;
      &::part(base) {
        display: flex;
        flex-direction: row;
        align-items: center;
        cursor: unset;
        position: static;
      }

      &::part(control) {
        position: absolute;
        bottom: -10px;
        left: -10px;
        cursor: pointer;
        border-radius: var(--webwriter-choice-radius, 2px);
        z-index: 100;
        border-color: var(--sl-color-gray-500);
      }

      &::part(control--checked):not(:hover) {
        background-color: var(--webwriter-control-color-600, var(--sl-color-primary-600));
        border-color: var(--sl-color-gray-500);
      }
      &::part(control--checked):hover {
        background-color: var(--webwriter-control-color-400, var(--sl-color-primary-400));
        border-color: var(--webwriter-control-color-600, var(--sl-color-primary-600));
      }

      &::part(label) {
        aspect-ratio: 1;
        min-width: 125px;
        max-width: 350px;
        min-height: 125px;
        max-height: 350px;
        overflow: hidden;
        resize: both;
        margin-inline-start: 0;
        overflow-y: auto;
        scrollbar-width: thin;
      }
    }    
    }
  `);
__runInitializers6(_init25, 1, _WebwriterChoiceItem);

// https:/cdn.jsdelivr.net/npm/@webwriter/map@2.0.3/dist/widgets/webwriter-map.js
var __create7 = Object.create;
var __defProp8 = Object.defineProperty;
var __getOwnPropDesc8 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __knownSymbol7 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name7 = (target, value) => __defProp8(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to5, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp5.call(to5, key) && key !== except)
        __defProp8(to5, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc8(from, key)) || desc.enumerable });
  }
  return to5;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create7(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp8(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decoratorStart7 = (base) => [, , , __create7(base?.[__knownSymbol7("metadata")] ?? null)];
var __decoratorStrings7 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn7 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError7("Function expected") : fn;
var __decoratorContext7 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings7[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError7("Already initialized") : fns.push(__expectFn7(fn || null)) });
var __decoratorMetadata7 = (array, target) => __defNormalProp8(target, __knownSymbol7("metadata"), array[3]);
var __runInitializers7 = (array, flags, self2, value) => {
  for (var i12 = 0, fns = array[flags >> 1], n17 = fns && fns.length; i12 < n17; i12++) flags & 1 ? fns[i12].call(self2) : value = fns[i12].call(self2, value);
  return value;
};
var __decorateElement7 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k42 = flags & 7, s9 = !!(flags & 8), p42 = !!(flags & 16);
  var j42 = k42 > 3 ? array.length + 1 : k42 ? s9 ? 1 : 2 : 0, key = __decoratorStrings7[k42 + 5];
  var initializers = k42 > 3 && (array[j42 - 1] = []), extraInitializers = array[j42] || (array[j42] = []);
  var desc = k42 && (!p42 && !s9 && (target = target.prototype), k42 < 5 && (k42 > 3 || !p42) && __getOwnPropDesc8(k42 < 4 ? target : { get [name]() {
    return __privateGet8(this, extra);
  }, set [name](x52) {
    return __privateSet8(this, extra, x52);
  } }, name));
  k42 ? p42 && k42 < 4 && __name7(extra, (k42 > 2 ? "set " : k42 > 1 ? "get " : "") + name) : __name7(target, name);
  for (var i12 = decorators.length - 1; i12 >= 0; i12--) {
    ctx = __decoratorContext7(k42, name, done = {}, array[3], extraInitializers);
    if (k42) {
      ctx.static = s9, ctx.private = p42, access = ctx.access = { has: p42 ? (x52) => __privateIn7(target, x52) : (x52) => name in x52 };
      if (k42 ^ 3) access.get = p42 ? (x52) => (k42 ^ 1 ? __privateGet8 : __privateMethod7)(x52, target, k42 ^ 4 ? extra : desc.get) : (x52) => x52[name];
      if (k42 > 2) access.set = p42 ? (x52, y42) => __privateSet8(x52, target, y42, k42 ^ 4 ? extra : desc.set) : (x52, y42) => x52[name] = y42;
    }
    it = (0, decorators[i12])(k42 ? k42 < 4 ? p42 ? extra : desc[key] : k42 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k42 ^ 4 || it === void 0) __expectFn7(it) && (k42 > 4 ? initializers.unshift(it) : k42 ? p42 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError7("Object expected");
    else __expectFn7(fn = it.get) && (desc.get = fn), __expectFn7(fn = it.set) && (desc.set = fn), __expectFn7(fn = it.init) && initializers.unshift(fn);
  }
  return k42 || __decoratorMetadata7(array, target), desc && __defProp8(target, name, desc), p42 ? k42 ^ 4 ? extra : desc : target;
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateIn7 = (member, obj) => Object(obj) !== obj ? __typeError7('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet8 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd8 = (obj, member, value) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet8 = (obj, member, value, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod7 = (obj, member, method) => (__accessCheck8(obj, member, "access private method"), method);
var require_leaflet_src = __commonJS({
  "node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.leaflet = {}));
    })(exports, function(exports2) {
      "use strict";
      var version22 = "1.9.4";
      function extend(dest) {
        var i12, j42, len, src;
        for (j42 = 1, len = arguments.length; j42 < len; j42++) {
          src = arguments[j42];
          for (i12 in src) {
            dest[i12] = src[i12];
          }
        }
        return dest;
      }
      var create$2 = Object.create || /* @__PURE__ */ function() {
        function F32() {
        }
        return function(proto) {
          F32.prototype = proto;
          return new F32();
        };
      }();
      function bind(fn, obj) {
        var slice = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj) {
        if (!("_leaflet_id" in obj)) {
          obj["_leaflet_id"] = ++lastId;
        }
        return obj._leaflet_id;
      }
      function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x52, range, includeMax) {
        var max22 = range[1], min22 = range[0], d52 = max22 - min22;
        return x52 === max22 && includeMax ? x52 : ((x52 - min22) % d52 + d52) % d52 + min22;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow) / pow;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim(str).split(/\s+/);
      }
      function setOptions(obj, options) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
          obj.options = obj.options ? create$2(obj.options) : {};
        }
        for (var i12 in options) {
          obj.options[i12] = options[i12];
        }
        return obj.options;
      }
      function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for (var i12 in obj) {
          params.push(encodeURIComponent(uppercase ? i12.toUpperCase() : i12) + "=" + encodeURIComponent(obj[i12]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      function indexOf(array, el) {
        for (var i12 = 0; i12 < array.length; i12++) {
          if (array[i12] === el) {
            return i12;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id3) {
        window.clearTimeout(id3);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind(fn, context));
        }
      }
      function cancelAnimFrame(id3) {
        if (id3) {
          cancelFn.call(window, id3);
        }
      }
      var Util = {
        __proto__: null,
        extend,
        create: create$2,
        bind,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle,
        wrapNum,
        falseFn,
        formatNum,
        trim,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i12 in this) {
          if (Object.prototype.hasOwnProperty.call(this, i12) && i12 !== "prototype" && i12 !== "__super__") {
            NewClass[i12] = this[i12];
          }
        }
        if (props.statics) {
          extend(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend.apply(null, [proto].concat(props.includes));
        }
        extend(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i13 = 0, len = proto._initHooks.length; i13 < len; i13++) {
            proto._initHooks[i13].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options) {
        extend(this.prototype.options, options);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray(includes) ? includes : [includes];
        for (var i12 = 0; i12 < includes.length; i12++) {
          if (includes[i12] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i12 = 0, len = types.length; i12 < len; i12++) {
              this._on(types[i12], fn, context);
            }
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(types, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types === "object") {
            for (var type in types) {
              this._off(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            var removeAll = arguments.length === 1;
            for (var i12 = 0, len = types.length; i12 < len; i12++) {
              if (removeAll) {
                this._off(types[i12]);
              } else {
                this._off(types[i12], fn, context);
              }
            }
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i12, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i12 = 0, len = listeners.length; i12 < len; i12++) {
                listeners[i12].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index2 = this._listens(type, fn, context);
          if (index2 !== false) {
            var listener = listeners[index2];
            if (this._firingCount) {
              listener.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index2, 1);
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i12 = 0, len = listeners.length; i12 < len; i12++) {
                var l11 = listeners[i12];
                var fn = l11.fn;
                if (l11.once) {
                  this.off(type, fn, l11.ctx);
                }
                fn.call(l11.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id3 in this._eventParents) {
              if (this._eventParents[id3].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        // returns the index (number) or false
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i12 = 0, len = listeners.length; i12 < len; i12++) {
            if (listeners[i12].fn === fn && listeners[i12].ctx === context) {
              return i12;
            }
          }
          return false;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn, true);
            }
          } else {
            types = splitWords(types);
            for (var i12 = 0, len = types.length; i12 < len; i12++) {
              this._on(types[i12], fn, context, true);
            }
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(obj) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj)] = obj;
          return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(obj) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj)];
          }
          return this;
        },
        _propagateEvent: function(e17) {
          for (var id3 in this._eventParents) {
            this._eventParents[id3].fire(e17.type, extend({
              layer: e17.target,
              propagatedFrom: e17.target
            }, e17), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point(x52, y42, round22) {
        this.x = round22 ? Math.round(x52) : x52;
        this.y = round22 ? Math.round(y42) : y42;
      }
      var trunc = Math.trunc || function(v42) {
        return v42 > 0 ? Math.floor(v42) : Math.ceil(v42);
      };
      Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(point) {
          return this.clone()._add(toPoint(point));
        },
        _add: function(point) {
          this.x += point.x;
          this.y += point.y;
          return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(point) {
          return this.clone()._subtract(toPoint(point));
        },
        _subtract: function(point) {
          this.x -= point.x;
          this.y -= point.y;
          return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(point) {
          return new Point(this.x * point.x, this.y * point.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(point) {
          return new Point(this.x / point.x, this.y / point.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(point) {
          point = toPoint(point);
          var x52 = point.x - this.x, y42 = point.y - this.y;
          return Math.sqrt(x52 * x52 + y42 * y42);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(point) {
          point = toPoint(point);
          return point.x === this.x && point.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(point) {
          point = toPoint(point);
          return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint(x52, y42, round22) {
        if (x52 instanceof Point) {
          return x52;
        }
        if (isArray(x52)) {
          return new Point(x52[0], x52[1]);
        }
        if (x52 === void 0 || x52 === null) {
          return x52;
        }
        if (typeof x52 === "object" && "x" in x52 && "y" in x52) {
          return new Point(x52.x, x52.y);
        }
        return new Point(x52, y42, round22);
      }
      function Bounds(a72, b42) {
        if (!a72) {
          return;
        }
        var points = b42 ? [a72, b42] : a72;
        for (var i12 = 0, len = points.length; i12 < len; i12++) {
          this.extend(points[i12]);
        }
      }
      Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var min22, max22;
          if (!obj) {
            return this;
          }
          if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
            min22 = max22 = toPoint(obj);
          } else {
            obj = toBounds(obj);
            min22 = obj.min;
            max22 = obj.max;
            if (!min22 || !max22) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min22.clone();
            this.max = max22.clone();
          } else {
            this.min.x = Math.min(min22.x, this.min.x);
            this.max.x = Math.max(max22.x, this.max.x);
            this.min.y = Math.min(min22.y, this.min.y);
            this.max.y = Math.max(max22.y, this.max.y);
          }
          return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(round22) {
          return toPoint(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round22
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          var min22, max22;
          if (typeof obj[0] === "number" || obj instanceof Point) {
            obj = toPoint(obj);
          } else {
            obj = toBounds(obj);
          }
          if (obj instanceof Bounds) {
            min22 = obj.min;
            max22 = obj.max;
          } else {
            min22 = max22 = obj;
          }
          return min22.x >= this.min.x && max22.x <= this.max.x && min22.y >= this.min.y && max22.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min22 = this.min, max22 = this.max, min222 = bounds.min, max222 = bounds.max, xIntersects = max222.x >= min22.x && min222.x <= max22.x, yIntersects = max222.y >= min22.y && min222.y <= max22.y;
          return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min22 = this.min, max22 = this.max, min222 = bounds.min, max222 = bounds.max, xOverlaps = max222.x > min22.x && min222.x < max22.x, yOverlaps = max222.y > min22.y && min222.y < max22.y;
          return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var min22 = this.min, max22 = this.max, heightBuffer = Math.abs(min22.x - max22.x) * bufferRatio, widthBuffer = Math.abs(min22.y - max22.y) * bufferRatio;
          return toBounds(
            toPoint(min22.x - heightBuffer, min22.y - widthBuffer),
            toPoint(max22.x + heightBuffer, max22.y + widthBuffer)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a72, b42) {
        if (!a72 || a72 instanceof Bounds) {
          return a72;
        }
        return new Bounds(a72, b42);
      }
      function LatLngBounds(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i12 = 0, len = latlngs.length; i12 < len; i12++) {
          this.extend(latlngs[i12]);
        }
      }
      LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLng) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof LatLngBounds) {
            sw2 = obj._southWest;
            ne2 = obj._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng(sw2.lat, sw2.lng);
            this._northEast = new LatLng(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds(
            new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new LatLng(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new LatLng(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new LatLng(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
            obj = toLatLng(obj);
          } else {
            obj = toLatLngBounds(obj);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
          } else {
            sw2 = ne2 = obj;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a72, b42) {
        if (a72 instanceof LatLngBounds) {
          return a72;
        }
        return new LatLngBounds(a72, b42);
      }
      function LatLng(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(obj, maxMargin) {
          if (!obj) {
            return false;
          }
          obj = toLatLng(obj);
          var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a72, b42, c92) {
        if (a72 instanceof LatLng) {
          return a72;
        }
        if (isArray(a72) && typeof a72[0] !== "object") {
          if (a72.length === 3) {
            return new LatLng(a72[0], a72[1], a72[2]);
          }
          if (a72.length === 2) {
            return new LatLng(a72[0], a72[1]);
          }
          return null;
        }
        if (a72 === void 0 || a72 === null) {
          return a72;
        }
        if (typeof a72 === "object" && "lat" in a72) {
          return new LatLng(a72.lat, "lng" in a72 ? a72.lng : a72.lon, a72.alt);
        }
        if (b42 === void 0) {
          return null;
        }
        return new LatLng(a72, b42, c92);
      }
      var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale2);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(point, zoom2) {
          var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
          return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(point) {
          return this.projection.unproject(point);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(scale2) {
          return Math.log(scale2 / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b42 = this.projection.bounds, s9 = this.scale(zoom2), min22 = this.transformation.transform(b42.min, s9), max22 = this.transformation.transform(b42.max, s9);
          return new Bounds(min22, max22);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds(newSw, newNe);
        }
      };
      var Earth = extend({}, CRS, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a72 = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c92 = 2 * Math.atan2(Math.sqrt(a72), Math.sqrt(1 - a72));
          return this.R * c92;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d52 = Math.PI / 180, max22 = this.MAX_LATITUDE, lat = Math.max(Math.min(max22, latlng.lat), -max22), sin = Math.sin(lat * d52);
          return new Point(
            this.R * latlng.lng * d52,
            this.R * Math.log((1 + sin) / (1 - sin)) / 2
          );
        },
        unproject: function(point) {
          var d52 = 180 / Math.PI;
          return new LatLng(
            (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d52,
            point.x * d52 / this.R
          );
        },
        bounds: function() {
          var d52 = earthRadius * Math.PI;
          return new Bounds([-d52, -d52], [d52, d52]);
        }()
      };
      function Transformation(a72, b42, c92, d52) {
        if (isArray(a72)) {
          this._a = a72[0];
          this._b = a72[1];
          this._c = a72[2];
          this._d = a72[3];
          return;
        }
        this._a = a72;
        this._b = b42;
        this._c = c92;
        this._d = d52;
      }
      Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(point, scale2) {
          return this._transform(point.clone(), scale2);
        },
        // destructive transform (faster)
        _transform: function(point, scale2) {
          scale2 = scale2 || 1;
          point.x = scale2 * (this._a * point.x + this._b);
          point.y = scale2 * (this._c * point.y + this._d);
          return point;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(point, scale2) {
          scale2 = scale2 || 1;
          return new Point(
            (point.x / scale2 - this._b) / this._a,
            (point.y / scale2 - this._d) / this._c
          );
        }
      };
      function toTransformation(a72, b42, c92, d52) {
        return new Transformation(a72, b42, c92, d52);
      }
      var EPSG3857 = extend({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG900913 = extend({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function pointsToPath(rings, closed) {
        var str = "", i12, j42, len, len2, points, p42;
        for (i12 = 0, len = rings.length; i12 < len; i12++) {
          points = rings[i12];
          for (j42 = 0, len2 = points.length; j42 < len2; j42++) {
            p42 = points[j42];
            str += (j42 ? "L" : "M") + p42.x + " " + p42.y;
          }
          str += closed ? Browser.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style2 = document.documentElement.style;
      var ie22 = "ActiveXObject" in window;
      var ielt9 = ie22 && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains("webkit");
      var android = userAgentContains("android");
      var android23 = userAgentContains("android 2") || userAgentContains("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome = !edge && userAgentContains("chrome");
      var gecko = userAgentContains("gecko") && !webkit && !opera && !ie22;
      var safari = !chrome && userAgentContains("safari");
      var phantom = userAgentContains("phantom");
      var opera12 = "OTransition" in style2;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie22 && "transition" in style2;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style2;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e17) {
        }
        return supportsPassiveOption;
      }();
      var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
      }();
      var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$1 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }();
      var vml = !svg$1 && function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e17) {
          return false;
        }
      }();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser = {
        ie: ie22,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e17) {
        _pointers[e17.pointerId] = e17;
      }
      function _globalPointerMove(e17) {
        if (_pointers[e17.pointerId]) {
          _pointers[e17.pointerId] = e17;
        }
      }
      function _globalPointerUp(e17) {
        delete _pointers[e17.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e17) {
        if (e17.pointerType === (e17.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e17.touches = [];
        for (var i12 in _pointers) {
          e17.touches.push(_pointers[i12]);
        }
        e17.changedTouches = [e17];
        handler(e17);
      }
      function _onPointerStart(handler, e17) {
        if (e17.MSPOINTER_TYPE_TOUCH && e17.pointerType === e17.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e17);
        }
        _handlePointer(handler, e17);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i12;
        for (i12 in event) {
          prop = event[i12];
          newEvent[i12] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay = 200;
      function addDoubleTapListener(obj, handler) {
        obj.addEventListener("dblclick", handler);
        var last = 0, detail;
        function simDblclick(e17) {
          if (e17.detail !== 1) {
            detail = e17.detail;
            return;
          }
          if (e17.pointerType === "mouse" || e17.sourceCapabilities && !e17.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path = getPropagationPath(e17);
          if (path.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now = Date.now();
          if (now - last <= delay) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e17));
            }
          } else {
            detail = 1;
          }
          last = now;
        }
        obj.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj, handlers) {
        obj.removeEventListener("dblclick", handlers.dblclick);
        obj.removeEventListener("click", handlers.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get(id3) {
        return typeof id3 === "string" ? document.getElementById(id3) : id3;
      }
      function getStyle(el, style3) {
        var value = el.style[style3] || el.currentStyle && el.currentStyle[style3];
        if ((!value || value === "auto") && document.defaultView) {
          var css2 = document.defaultView.getComputedStyle(el, null);
          value = css2 ? css2[style3] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name) {
        if (el.classList !== void 0) {
          return el.classList.contains(name);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
      }
      function addClass(el, name) {
        if (el.classList !== void 0) {
          var classes = splitWords(name);
          for (var i12 = 0, len = classes.length; i12 < len; i12++) {
            el.classList.add(classes[i12]);
          }
        } else if (!hasClass(el, name)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name);
        }
      }
      function removeClass(el, name) {
        if (el.classList !== void 0) {
          el.classList.remove(name);
        } else {
          setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
        }
      }
      function setClass(el, name) {
        if (el.className.baseVal === void 0) {
          el.className = name;
        } else {
          el.className.baseVal = name;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter = el.filters.item(filterName);
        } catch (e17) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = value !== 100;
          filter.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style3 = document.documentElement.style;
        for (var i12 = 0; i12 < props.length; i12++) {
          if (props[i12] in style3) {
            return props[i12];
          }
        }
        return false;
      }
      function setTransform(el, offset22, scale2) {
        var pos = offset22 || new Point(0, 0);
        el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
      }
      function setPosition(el, point) {
        el._leaflet_pos = point;
        if (Browser.any3d) {
          setTransform(el, point);
        } else {
          el.style.left = point.x + "px";
          el.style.top = point.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style3 = document.documentElement.style;
            _userSelect = style3[userSelectProperty];
            style3[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element) {
        while (element.tabIndex === -1) {
          element = element.parentNode;
        }
        if (!element.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element) {
        do {
          element = element.parentNode;
        } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
      }
      function getScale22(element) {
        var rect = element.getBoundingClientRect();
        return {
          x: rect.width / element.offsetWidth || 1,
          y: rect.height / element.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get,
        getStyle,
        create: create$1,
        remove,
        empty,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale: getScale22
      };
      function on(obj, types, fn, context) {
        if (types && typeof types === "object") {
          for (var type in types) {
            addOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i12 = 0, len = types.length; i12 < len; i12++) {
            addOne(obj, types[i12], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj, types, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj);
          delete obj[eventsKey];
        } else if (types && typeof types === "object") {
          for (var type in types) {
            removeOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          if (arguments.length === 2) {
            batchRemove(obj, function(type2) {
              return indexOf(types, type2) !== -1;
            });
          } else {
            for (var i12 = 0, len = types.length; i12 < len; i12++) {
              removeOne(obj, types[i12], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj, filterFn) {
        for (var id3 in obj[eventsKey]) {
          var type = id3.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj, type, null, null, id3);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj, type, fn, context) {
        var id3 = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id3]) {
          return this;
        }
        var handler = function(e17) {
          return fn.call(context || obj, e17 || window.event);
        };
        var originalHandler = handler;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj, handler);
        } else if ("addEventListener" in obj) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e17) {
              e17 = e17 || window.event;
              if (isExternalTarget(obj, e17)) {
                originalHandler(e17);
              }
            };
            obj.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj.addEventListener(type, originalHandler, false);
          }
        } else {
          obj.attachEvent("on" + type, handler);
        }
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id3] = handler;
      }
      function removeOne(obj, type, fn, context, id3) {
        id3 = id3 || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id3];
        if (!handler) {
          return this;
        }
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          removeDoubleTapListener(obj, handler);
        } else if ("removeEventListener" in obj) {
          obj.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj.detachEvent("on" + type, handler);
        }
        obj[eventsKey][id3] = null;
      }
      function stopPropagation(e17) {
        if (e17.stopPropagation) {
          e17.stopPropagation();
        } else if (e17.originalEvent) {
          e17.originalEvent._stopped = true;
        } else {
          e17.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e17) {
        if (e17.preventDefault) {
          e17.preventDefault();
        } else {
          e17.returnValue = false;
        }
        return this;
      }
      function stop(e17) {
        preventDefault(e17);
        stopPropagation(e17);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path = [];
        var el = ev.target;
        while (el) {
          path.push(el);
          el = el.parentNode;
        }
        return path;
      }
      function getMousePosition(e17, container) {
        if (!container) {
          return new Point(e17.clientX, e17.clientY);
        }
        var scale2 = getScale22(container), offset22 = scale2.boundingClientRect;
        return new Point(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (e17.clientX - offset22.left) / scale2.x - container.clientLeft,
          (e17.clientY - offset22.top) / scale2.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e17) {
        return Browser.edge ? e17.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          e17.deltaY && e17.deltaMode === 0 ? -e17.deltaY / wheelPxFactor : (
            // Pixels
            e17.deltaY && e17.deltaMode === 1 ? -e17.deltaY * 20 : (
              // Lines
              e17.deltaY && e17.deltaMode === 2 ? -e17.deltaY * 60 : (
                // Pages
                e17.deltaX || e17.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  e17.wheelDelta ? (e17.wheelDeltaY || e17.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    e17.detail && Math.abs(e17.detail) < 32765 ? -e17.detail * 20 : (
                      // Legacy Moz lines
                      e17.detail ? e17.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function isExternalTarget(el, e17) {
        var related = e17.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +/* @__PURE__ */ new Date();
          this.fire("start");
          this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round22) {
          var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round22);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress, round22) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress));
          if (round22) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t11) {
          return 1 - Math.pow(1 - t11, this._easeOutPower);
        }
      });
      var Map2 = Evented.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: EPSG3857,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: true,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: true,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: true,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: true
        },
        initialize: function(id3, options) {
          options = setOptions(this, options);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id3);
          this._initLayout();
          this._onResize = bind(this._onResize, this);
          this._initEvents();
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          if (options.zoom !== void 0) {
            this._zoom = this._limitZoom(options.zoom);
          }
          if (options.center && options.zoom !== void 0) {
            this.setView(toLatLng(options.center), options.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(center, zoom2, options) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options = options || {};
          this._stop();
          if (this._loaded && !options.reset && options !== true) {
            if (options.animate !== void 0) {
              options.zoom = extend({ animate: options.animate }, options.zoom);
              options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
          return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(zoom2, options) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(latlng, zoom2, options) {
          var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options });
        },
        _getBoundsCenterZoom: function(bounds, options) {
          options = options || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(bounds, options) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.setView(target.center, target.zoom, options);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(options) {
          return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(center, options) {
          return this.setView(center, this._zoom, { pan: options });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(offset22, options) {
          offset22 = toPoint(offset22).round();
          options = options || {};
          if (!offset22.x && !offset22.y) {
            return this.fire("moveend");
          }
          if (options.animate !== true && !this.getSize().contains(offset22)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset22)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options.noMoveStart) {
            this.fire("movestart");
          }
          if (options.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset22).round();
            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
          } else {
            this._rawPanBy(offset22);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(targetCenter, targetZoom, options) {
          options = options || {};
          if (options.animate === false || !Browser.any3d) {
            return this.setView(targetCenter, targetZoom, options);
          }
          this._stop();
          var from = this.project(this.getCenter()), to5 = this.project(targetCenter), size22 = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size22.x, size22.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to5.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
          function r112(i12) {
            var s1 = i12 ? -1 : 1, s222 = i12 ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s222 * rho2 * u1, b42 = t1 / b1, sq = Math.sqrt(b42 * b42 + 1) - b42;
            var log = sq < 1e-9 ? -18 : Math.log(sq);
            return log;
          }
          function sinh(n17) {
            return (Math.exp(n17) - Math.exp(-n17)) / 2;
          }
          function cosh(n17) {
            return (Math.exp(n17) + Math.exp(-n17)) / 2;
          }
          function tanh(n17) {
            return sinh(n17) / cosh(n17);
          }
          var r0 = r112(0);
          function w42(s9) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s9));
          }
          function u62(s9) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s9) - sinh(r0)) / rho2;
          }
          function easeOut(t11) {
            return 1 - Math.pow(1 - t11, 1.5);
          }
          var start = Date.now(), S72 = (r112(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S72 * 0.8;
          function frame() {
            var t11 = (Date.now() - start) / duration, s9 = easeOut(t11) * S72;
            if (t11 <= 1) {
              this._flyToFrame = requestAnimFrame(frame, this);
              this._move(
                this.unproject(from.add(to5.subtract(from).multiplyBy(u62(s9) / u1)), startZoom),
                this.getScaleZoom(w0 / w42(s9), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options.noMoveStart);
          frame.call(this);
          return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(bounds, options) {
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.flyTo(target.center, target.zoom, options);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(bounds, options) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options);
          }
          this._enforcingBounds = false;
          return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(latlng, options) {
          options = options || {};
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset22 = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset22.x : offset22.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset22.y : offset22.y;
            this.panTo(this.unproject(pixelCenter), options);
            this._enforcingBounds = false;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(options) {
          if (!this._loaded) {
            return this;
          }
          options = extend({
            animate: false,
            pan: true
          }, options === true ? { animate: true } : options);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset22 = oldCenter.subtract(newCenter);
          if (!offset22.x && !offset22.y) {
            return this;
          }
          if (options.animate && options.pan) {
            this.panBy(offset22);
          } else {
            if (options.pan) {
              this._rawPanBy(offset22);
            }
            this.fire("move");
            if (options.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(options) {
          options = this._locateOptions = extend({
            timeout: 1e4,
            watch: false
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, options);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
          if (options.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options);
          }
          return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c92 = error.code, message = error.message || (c92 === 1 ? "permission denied" : c92 === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c92,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
          if (options.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i12 in pos.coords) {
            if (typeof pos.coords[i12] === "number") {
              data[i12] = pos.coords[i12];
            }
          }
          this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(name, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name]) {
            handler.enable();
          }
          return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e17) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i12;
          for (i12 in this._layers) {
            this._layers[i12].remove();
          }
          for (i12 in this._panes) {
            remove(this._panes[i12]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(name, container) {
          var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name) {
            this._panes[name] = pane;
          }
          return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min22 = this.getMinZoom(), max22 = this.getMaxZoom(), nw = bounds.getNorthWest(), se22 = bounds.getSouthEast(), size22 = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se22, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size22.x / boundsSize.x, scaley = size22.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale2, zoom2);
          if (snap) {
            zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
          }
          return Math.max(min22, Math.min(max22, zoom2));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(scale2, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(point, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint(point), zoom2);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(point) {
          var projectedPoint = toPoint(point).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(point) {
          return toPoint(point).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(point) {
          return toPoint(point).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(point) {
          var layerPoint = this.containerPointToLayerPoint(toPoint(point));
          return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(e17) {
          return getMousePosition(e17, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(e17) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e17));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(e17) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e17));
        },
        // map initialization methods
        _initContainer: function(id3) {
          var container = this._container = get(id3);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
          addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position = getStyle(container, "position");
          if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset22) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset22));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e17, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e17.target || e17.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e17)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e17) {
          var el = e17.target || e17.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e17.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e17.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e17, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e17, type, canvasTargets) {
          if (e17.type === "click") {
            var synth = extend({}, e17);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e17, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i12 = 0; i12 < canvasTargets.length; i12++) {
              if (canvasTargets[i12].listens(type, true)) {
                filtered.push(canvasTargets[i12]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e17);
          }
          var target = targets[0];
          var data = {
            originalEvent: e17
          };
          if (e17.type !== "keypress" && e17.type !== "keydown" && e17.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e17);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i12 = 0; i12 < targets.length; i12++) {
            targets[i12].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i12].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj) {
          obj = obj.dragging && obj.dragging.enabled() ? obj : this;
          return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i12 = 0, len = this._handlers.length; i12 < len; i12++) {
            this._handlers[i12].disable();
          }
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds2, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds2.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds2.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds2.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds2.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset22 = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset22.x) <= 1 && Math.abs(offset22.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset22), zoom2);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset22, bounds) {
          if (!bounds) {
            return offset22;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset22), viewBounds.max.add(offset22));
          return offset22.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min22 = this.getMinZoom(), max22 = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
          if (snap) {
            zoom2 = Math.round(zoom2 / snap) * snap;
          }
          return Math.max(min22, Math.min(max22, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
          var offset22 = this._getCenterOffset(center)._trunc();
          if ((options && options.animate) !== true && !this.getSize().contains(offset22)) {
            return false;
          }
          this.panBy(offset22, options);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e17) {
            var prop = TRANSFORM, transform = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e17.center, e17.zoom), this.getZoomScale(e17.zoom, 1));
            if (transform === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c92 = this.getCenter(), z42 = this.getZoom();
          setTransform(this._proxy, this.project(c92, z42), this.getZoomScale(z42, 1));
        },
        _catchTransitionEnd: function(e17) {
          if (this._animatingZoom && e17.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options) {
          if (this._animatingZoom) {
            return true;
          }
          options = options || {};
          if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale2 = this.getZoomScale(zoom2), offset22 = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
          if (options.animate !== true && !this.getSize().contains(offset22)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id3, options) {
        return new Map2(id3, options);
      }
      var Control = Class.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(position) {
          var map2 = this._map;
          if (map2) {
            map2.removeControl(this);
          }
          this.options.position = position;
          if (map2) {
            map2.addControl(this);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(map2) {
          this.remove();
          this._map = map2;
          var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e17) {
          if (this._map && e17 && e17.screenX > 0 && e17.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control2 = function(options) {
        return new Control(options);
      };
      Map2.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(control3) {
          control3.addTo(this);
          return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(control3) {
          control3.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l11 = "leaflet-", container = this._controlContainer = create$1("div", l11 + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l11 + vSide + " " + l11 + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i12 in this._controlCorners) {
            remove(this._controlCorners[i12]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: true,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: true,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: false,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: false,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options) {
          setOptions(this, options);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i12 in baseLayers) {
            this._addLayer(baseLayers[i12], i12);
          }
          for (i12 in overlays) {
            this._addLayer(overlays[i12], i12, true);
          }
        },
        onAdd: function(map2) {
          this._initLayout();
          this._update();
          this._map = map2;
          map2.on("zoomend", this._checkDisabledLayers, this);
          for (var i12 = 0; i12 < this._layers.length; i12++) {
            this._layers[i12].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map2) {
          Control.prototype.addTo.call(this, map2);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i12 = 0; i12 < this._layers.length; i12++) {
            this._layers[i12].layer.off("add remove", this._onLayerChange, this);
          }
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(layer, name) {
          this._addLayer(layer, name);
          return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(layer, name) {
          this._addLayer(layer, name, true);
          return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj = this._getLayer(stamp(layer));
          if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
          }
          return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link = this._layersLink = create$1("a", className + "-toggle", container);
          link.href = "#";
          link.title = "Layers";
          link.setAttribute("role", "button");
          on(link, {
            keydown: function(e17) {
              if (e17.keyCode === 13) {
                this._expandSafely();
              }
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(e17) {
              preventDefault(e17);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id3) {
          for (var i12 = 0; i12 < this._layers.length; i12++) {
            if (this._layers[i12] && stamp(this._layers[i12].layer) === id3) {
              return this._layers[i12];
            }
          }
        },
        _addLayer: function(layer, name, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind(function(a72, b42) {
              return this.options.sortFunction(a72.layer, b42.layer, a72.name, b42.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty(this._baseLayersList);
          empty(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i12, obj, baseLayersCount = 0;
          for (i12 = 0; i12 < this._layers.length; i12++) {
            obj = this._layers[i12];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e17) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj = this._getLayer(stamp(e17.target));
          var type = obj.overlay ? e17.type === "add" ? "overlayadd" : "overlayremove" : e17.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj);
          }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(name, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
          if (obj.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj.layer);
          on(input, "click", this._onInputClick, this);
          var name = document.createElement("span");
          name.innerHTML = " " + obj.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i12 = inputs.length - 1; i12 >= 0; i12--) {
            input = inputs[i12];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i12 = 0; i12 < removedLayers.length; i12++) {
            if (this._map.hasLayer(removedLayers[i12])) {
              this._map.removeLayer(removedLayers[i12]);
            }
          }
          for (i12 = 0; i12 < addedLayers.length; i12++) {
            if (!this._map.hasLayer(addedLayers[i12])) {
              this._map.addLayer(addedLayers[i12]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i12 = inputs.length - 1; i12 >= 0; i12--) {
            input = inputs[i12];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
      };
      var Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map2) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
          this._zoomInButton = this._createButton(
            options.zoomInText,
            options.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options.zoomOutText,
            options.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e17) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e17.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e17) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e17.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html2, title, className, container, fn) {
          var link = create$1("a", className, container);
          link.innerHTML = html2;
          link.href = "#";
          link.title = title;
          link.setAttribute("role", "button");
          link.setAttribute("aria-label", title);
          disableClickPropagation(link);
          on(link, "click", stop);
          on(link, "click", fn, this);
          on(link, "click", this._refocusOnMap, this);
          return link;
        },
        _updateDisabled: function() {
          var map2 = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map2._zoom === map2.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map2._zoom === map2.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map2.mergeOptions({
        zoomControl: true
      });
      Map2.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options) {
        return new Zoom(options);
      };
      var Scale = Control.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: true,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: true
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(map2) {
          var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
          this._addScales(options, className + "-line", container);
          map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
          map2.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map2) {
          map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
          if (options.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map2 = this._map, y42 = map2.getSize().y / 2;
          var maxMeters = map2.distance(
            map2.containerPointToLatLng([0, y42]),
            map2.containerPointToLatLng([this.options.maxWidth, y42])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale2, text, ratio) {
          scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale2.innerHTML = text;
        },
        _getRoundNum: function(num) {
          var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d52 = num / pow10;
          d52 = d52 >= 10 ? 10 : d52 >= 5 ? 5 : d52 >= 3 ? 3 : d52 >= 2 ? 2 : 1;
          return pow10 * d52;
        }
      });
      var scale = function(options) {
        return new Scale(options);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options) {
          setOptions(this, options);
          this._attributions = {};
        },
        onAdd: function(map2) {
          map2.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i12 in map2._layers) {
            if (map2._layers[i12].getAttribution) {
              this.addAttribution(map2._layers[i12].getAttribution());
            }
          }
          this._update();
          map2.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map2) {
          map2.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(prefix) {
          this.options.prefix = prefix;
          this._update();
          return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (!this._attributions[text]) {
            this._attributions[text] = 0;
          }
          this._attributions[text]++;
          this._update();
          return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (this._attributions[text]) {
            this._attributions[text]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i12 in this._attributions) {
            if (this._attributions[i12]) {
              attribs.push(i12);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map2.mergeOptions({
        attributionControl: true
      });
      Map2.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options) {
        return new Attribution(options);
      };
      Control.Layers = Layers;
      Control.Zoom = Zoom;
      Control.Scale = Scale;
      Control.Attribution = Attribution;
      control2.layers = layers;
      control2.zoom = zoom;
      control2.scale = scale;
      control2.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map2) {
          this._map = map2;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Handler.addTo = function(map2, name) {
        map2.addHandler(name, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(element, dragStartTarget, preventOutline2, options) {
          setOptions(this, options);
          this._element = element;
          this._dragStartTarget = dragStartTarget || element;
          this._preventOutline = preventOutline2;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e17) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e17.touches && e17.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e17.shiftKey || e17.which !== 1 && e17.button !== 1 && !e17.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e17.touches ? e17.touches[0] : e17, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale22(sizedParent);
          var mouseevent = e17.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e17) {
          if (!this._enabled) {
            return;
          }
          if (e17.touches && e17.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e17.touches && e17.touches.length === 1 ? e17.touches[0] : e17, offset22 = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset22.x && !offset22.y) {
            return;
          }
          if (Math.abs(offset22.x) + Math.abs(offset22.y) < this.options.clickTolerance) {
            return;
          }
          offset22.x /= this._parentScale.x;
          offset22.y /= this._parentScale.y;
          preventDefault(e17);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e17.target || e17.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset22);
          this._moving = true;
          this._lastEvent = e17;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e17 = { originalEvent: this._lastEvent };
          this.fire("predrag", e17);
          setPosition(this._element, this._newPos);
          this.fire("drag", e17);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round22) {
        var clippedPoints, edges = [1, 4, 2, 8], i12, j42, k42, a72, b42, len, edge2, p42;
        for (i12 = 0, len = points.length; i12 < len; i12++) {
          points[i12]._code = _getBitCode(points[i12], bounds);
        }
        for (k42 = 0; k42 < 4; k42++) {
          edge2 = edges[k42];
          clippedPoints = [];
          for (i12 = 0, len = points.length, j42 = len - 1; i12 < len; j42 = i12++) {
            a72 = points[i12];
            b42 = points[j42];
            if (!(a72._code & edge2)) {
              if (b42._code & edge2) {
                p42 = _getEdgeIntersection(b42, a72, edge2, bounds, round22);
                p42._code = _getBitCode(p42, bounds);
                clippedPoints.push(p42);
              }
              clippedPoints.push(a72);
            } else if (!(b42._code & edge2)) {
              p42 = _getEdgeIntersection(b42, a72, edge2, bounds, round22);
              p42._code = _getBitCode(p42, bounds);
              clippedPoints.push(p42);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i12, j42, p1, p222, f82, area, x52, y42, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i12 = 0; i12 < len; i12++) {
          var latlng = toLatLng(latlngs[i12]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x52 = y42 = 0;
        for (i12 = 0, j42 = len - 1; i12 < len; j42 = i12++) {
          p1 = points[i12];
          p222 = points[j42];
          f82 = p1.y * p222.x - p222.y * p1.x;
          x52 += (p1.x + p222.x) * f82;
          y42 += (p1.y + p222.y) * f82;
          area += f82 * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x52 / area, y42 / area];
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i12 = 0; i12 < coords.length; i12++) {
          var latlng = toLatLng(coords[i12]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p42, p1, p222) {
        return Math.sqrt(_sqClosestPointOnSegment(p42, p1, p222, true));
      }
      function closestPointOnSegment(p42, p1, p222) {
        return _sqClosestPointOnSegment(p42, p1, p222);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i12, newPoints = [];
        for (i12 = 0; i12 < len; i12++) {
          if (markers[i12]) {
            newPoints.push(points[i12]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index2, i12, sqDist;
        for (i12 = first + 1; i12 <= last - 1; i12++) {
          sqDist = _sqClosestPointOnSegment(points[i12], points[first], points[last], true);
          if (sqDist > maxSqDist) {
            index2 = i12;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index2] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index2);
          _simplifyDPStep(points, markers, sqTolerance, index2, last);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i12 = 1, prev = 0, len = points.length; i12 < len; i12++) {
          if (_sqDist(points[i12], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i12]);
            prev = i12;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a72, b42, bounds, useLastCode, round22) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a72, bounds), codeB = _getBitCode(b42, bounds), codeOut, p42, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a72, b42];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p42 = _getEdgeIntersection(a72, b42, codeOut, bounds, round22);
          newCode = _getBitCode(p42, bounds);
          if (codeOut === codeA) {
            a72 = p42;
            codeA = newCode;
          } else {
            b42 = p42;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a72, b42, code, bounds, round22) {
        var dx = b42.x - a72.x, dy = b42.y - a72.y, min22 = bounds.min, max22 = bounds.max, x52, y42;
        if (code & 8) {
          x52 = a72.x + dx * (max22.y - a72.y) / dy;
          y42 = max22.y;
        } else if (code & 4) {
          x52 = a72.x + dx * (min22.y - a72.y) / dy;
          y42 = min22.y;
        } else if (code & 2) {
          x52 = max22.x;
          y42 = a72.y + dy * (max22.x - a72.x) / dx;
        } else if (code & 1) {
          x52 = min22.x;
          y42 = a72.y + dy * (min22.x - a72.x) / dx;
        }
        return new Point(x52, y42, round22);
      }
      function _getBitCode(p42, bounds) {
        var code = 0;
        if (p42.x < bounds.min.x) {
          code |= 1;
        } else if (p42.x > bounds.max.x) {
          code |= 2;
        }
        if (p42.y < bounds.min.y) {
          code |= 4;
        } else if (p42.y > bounds.max.y) {
          code |= 8;
        }
        return code;
      }
      function _sqDist(p1, p222) {
        var dx = p222.x - p1.x, dy = p222.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p42, p1, p222, sqDist) {
        var x52 = p1.x, y42 = p1.y, dx = p222.x - x52, dy = p222.y - y42, dot = dx * dx + dy * dy, t11;
        if (dot > 0) {
          t11 = ((p42.x - x52) * dx + (p42.y - y42) * dy) / dot;
          if (t11 > 1) {
            x52 = p222.x;
            y42 = p222.y;
          } else if (t11 > 0) {
            x52 += dx * t11;
            y42 += dy * t11;
          }
        }
        dx = p42.x - x52;
        dy = p42.y - y42;
        return sqDist ? dx * dx + dy * dy : new Point(x52, y42);
      }
      function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i12, halfDist, segDist, dist, p1, p222, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i12 = 0; i12 < len; i12++) {
          var latlng = toLatLng(latlngs[i12]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i12 = 0, halfDist = 0; i12 < len - 1; i12++) {
          halfDist += points[i12].distanceTo(points[i12 + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i12 = 0, dist = 0; i12 < len - 1; i12++) {
            p1 = points[i12];
            p222 = points[i12 + 1];
            segDist = p1.distanceTo(p222);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p222.x - ratio * (p222.x - p1.x),
                p222.y - ratio * (p222.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point(latlng.lng, latlng.lat);
        },
        unproject: function(point) {
          return new LatLng(point.y, point.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d52 = Math.PI / 180, r112 = this.R, y42 = latlng.lat * d52, tmp = this.R_MINOR / r112, e17 = Math.sqrt(1 - tmp * tmp), con = e17 * Math.sin(y42);
          var ts = Math.tan(Math.PI / 4 - y42 / 2) / Math.pow((1 - con) / (1 + con), e17 / 2);
          y42 = -r112 * Math.log(Math.max(ts, 1e-10));
          return new Point(latlng.lng * d52 * r112, y42);
        },
        unproject: function(point) {
          var d52 = 180 / Math.PI, r112 = this.R, tmp = this.R_MINOR / r112, e17 = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r112), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i12 = 0, dphi = 0.1, con; i12 < 15 && Math.abs(dphi) > 1e-7; i12++) {
            con = e17 * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e17 / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng(phi * d52, point.x * d52 / r112);
        }
      };
      var index = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG4326 = extend({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS.Earth = Earth;
      CRS.EPSG3395 = EPSG3395;
      CRS.EPSG3857 = EPSG3857;
      CRS.EPSG900913 = EPSG900913;
      CRS.EPSG4326 = EPSG4326;
      CRS.Simple = Simple;
      var Layer = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: true
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(map2) {
          map2.addLayer(this);
          return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(obj) {
          if (obj) {
            obj.removeLayer(this);
          }
          return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(name) {
          return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e17) {
          var map2 = e17.target;
          if (!map2.hasLayer(this)) {
            return;
          }
          this._map = map2;
          this._zoomAnimated = map2._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map2.on(events, this);
            this.once("remove", function() {
              map2.off(events, this);
            }, this);
          }
          this.onAdd(map2);
          this.fire("add");
          map2.fire("layeradd", { layer: this });
        }
      });
      Map2.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id3 = stamp(layer);
          if (this._layers[id3]) {
            return this;
          }
          this._layers[id3] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(layer) {
          var id3 = stamp(layer);
          if (!this._layers[id3]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id3];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(method, context) {
          for (var i12 in this._layers) {
            method.call(context, this._layers[i12]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
          for (var i12 = 0, len = layers2.length; i12 < len; i12++) {
            this.addLayer(layers2[i12]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id3 = stamp(layer);
          if (this._zoomBoundLayers[id3]) {
            delete this._zoomBoundLayers[id3];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i12 in this._zoomBoundLayers) {
            var options = this._zoomBoundLayers[i12].options;
            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer.extend({
        initialize: function(layers2, options) {
          setOptions(this, options);
          this._layers = {};
          var i12, len;
          if (layers2) {
            for (i12 = 0, len = layers2.length; i12 < len; i12++) {
              this.addLayer(layers2[i12]);
            }
          }
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(layer) {
          var id3 = this.getLayerId(layer);
          this._layers[id3] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(layer) {
          var id3 = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id3]) {
            this._map.removeLayer(this._layers[id3]);
          }
          delete this._layers[id3];
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i12, layer;
          for (i12 in this._layers) {
            layer = this._layers[i12];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map2) {
          this.eachLayer(map2.addLayer, map2);
        },
        onRemove: function(map2) {
          this.eachLayer(map2.removeLayer, map2);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(method, context) {
          for (var i12 in this._layers) {
            method.call(context, this._layers[i12]);
          }
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(id3) {
          return this._layers[id3];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options) {
        return new LayerGroup(layers2, options);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(style3) {
          return this.invoke("setStyle", style3);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var bounds = new LatLngBounds();
          for (var id3 in this._layers) {
            var layer = this._layers[id3];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup = function(layers2, options) {
        return new FeatureGroup(layers2, options);
      };
      var Icon = Class.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
          var src = this._getIconUrl(name);
          if (!src) {
            if (name === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name) {
          var options = this.options;
          var sizeOption = options[name + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size22 = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size22 && size22.divideBy(2, true));
          img.className = "leaflet-marker-" + name + " " + (options.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size22) {
            img.style.width = size22.x + "px";
            img.style.height = size22.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name) {
          return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
      });
      function icon(options) {
        return new Icon(options);
      }
      var IconDefault = Icon.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function(path) {
          var strip = function(str, re, idx) {
            var match = re.exec(str);
            return match && match[idx];
          };
          path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
          return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path = this._stripUrl(path);
          if (path) {
            return path;
          }
          var link = document.querySelector('link[href$="leaflet.css"]');
          if (!link) {
            return "";
          }
          return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker4) {
          this._marker = marker4;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e17) {
          var marker4 = this._marker, map2 = marker4._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker4._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin).add(padding),
            bounds.max._subtract(origin).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map2.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker4._icon, this._draggable._newPos);
            this._onDrag(e17);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e17));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e17) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e17));
          }
        },
        _onDrag: function(e17) {
          var marker4 = this._marker, shadow = marker4._shadow, iconPos = getPosition(marker4._icon), latlng = marker4._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker4._latlng = latlng;
          e17.latlng = latlng;
          e17.oldLatLng = this._oldLatLng;
          marker4.fire("move", e17).fire("drag", e17);
        },
        _onDragEnd: function(e17) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e17);
        }
      });
      var Marker = Layer.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new IconDefault(),
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: true,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: false,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: false,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: true,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: false,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: false,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map2) {
          this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map2.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map2) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map2.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(offset22) {
          this.options.zIndexOffset = offset22;
          return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options.title) {
              icon2.title = options.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset22) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset22;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size22 = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
          map2.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size22.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker3(latlng, options) {
        return new Marker(latlng, options);
      }
      var Path = Layer.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: true,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: false,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: true
        },
        beforeAdd: function(map2) {
          this._renderer = map2.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(style3) {
          setOptions(this, style3);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style3 && Object.prototype.hasOwnProperty.call(style3, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: true,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options) {
          var radius = options && options.radius || this._radius;
          Path.prototype.setStyle.call(this, options);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r112 = this._radius, r226 = this._radiusY || r112, w42 = this._clickTolerance(), p42 = [r112 + w42, r226 + w42];
          this._pxBounds = new Bounds(this._point.subtract(p42), this._point.add(p42));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p42) {
          return p42.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
      }
      var Circle2 = CircleMarker.extend({
        initialize: function(latlng, options, legacyOptions) {
          if (typeof options === "number") {
            options = extend({}, legacyOptions, { radius: options });
          }
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
          if (crs.distance === Earth.distance) {
            var d52 = Math.PI / 180, latR = this._mRadius / Earth.R / d52, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p42 = top.add(bottom).divideBy(2), lat2 = map2.unproject(p42).lat, lngR = Math.acos((Math.cos(latR * d52) - Math.sin(lat * d52) * Math.sin(lat2 * d52)) / (Math.cos(lat * d52) * Math.cos(lat2 * d52))) / d52;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p42.subtract(map2.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p42.x - map2.project([lat2, lng - lngR]).x;
            this._radiusY = p42.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map2.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle2(latlng, options, legacyOptions) {
        return new Circle2(latlng, options, legacyOptions);
      }
      var Polyline2 = Path.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: false
        },
        initialize: function(latlngs, options) {
          setOptions(this, options);
          this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p42) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p222;
          for (var j42 = 0, jLen = this._parts.length; j42 < jLen; j42++) {
            var points = this._parts[j42];
            for (var i12 = 1, len = points.length; i12 < len; i12++) {
              p1 = points[i12 - 1];
              p222 = points[i12];
              var sqDist = closest(p42, p1, p222, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p42, p1, p222);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(latlngs) {
          var result = [], flat = isFlat(latlngs);
          for (var i12 = 0, len = latlngs.length; i12 < len; i12++) {
            if (flat) {
              result[i12] = toLatLng(latlngs[i12]);
              this._bounds.extend(result[i12]);
            } else {
              result[i12] = this._convertLatLngs(latlngs[i12]);
            }
          }
          return result;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w42 = this._clickTolerance(), p42 = new Point(w42, w42);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p42),
            this._rawPxBounds.max.add(p42)
          ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(latlngs, result, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i12, ring;
          if (flat) {
            ring = [];
            for (i12 = 0; i12 < len; i12++) {
              ring[i12] = this._map.latLngToLayerPoint(latlngs[i12]);
              projectedBounds.extend(ring[i12]);
            }
            result.push(ring);
          } else {
            for (i12 = 0; i12 < len; i12++) {
              this._projectLatlngs(latlngs[i12], result, projectedBounds);
            }
          }
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts2 = this._parts, i12, j42, k42, len, len2, segment, points;
          for (i12 = 0, k42 = 0, len = this._rings.length; i12 < len; i12++) {
            points = this._rings[i12];
            for (j42 = 0, len2 = points.length; j42 < len2 - 1; j42++) {
              segment = clipSegment(points[j42], points[j42 + 1], bounds, j42, true);
              if (!segment) {
                continue;
              }
              parts2[k42] = parts2[k42] || [];
              parts2[k42].push(segment[0]);
              if (segment[1] !== points[j42 + 1] || j42 === len2 - 2) {
                parts2[k42].push(segment[1]);
                k42++;
              }
            }
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          var parts2 = this._parts, tolerance = this.options.smoothFactor;
          for (var i12 = 0, len = parts2.length; i12 < len; i12++) {
            parts2[i12] = simplify(parts2[i12], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p42, closed) {
          var i12, j42, k42, len, len2, part, w42 = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p42)) {
            return false;
          }
          for (i12 = 0, len = this._parts.length; i12 < len; i12++) {
            part = this._parts[i12];
            for (j42 = 0, len2 = part.length, k42 = len2 - 1; j42 < len2; k42 = j42++) {
              if (!closed && j42 === 0) {
                continue;
              }
              if (pointToSegmentDistance(p42, part[k42], part[j42]) <= w42) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline2(latlngs, options) {
        return new Polyline2(latlngs, options);
      }
      Polyline2._flat = _flat;
      var Polygon2 = Polyline2.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result = Polyline2.prototype._convertLatLngs.call(this, latlngs), len = result.length;
          if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
            result.pop();
          }
          return result;
        },
        _setLatLngs: function(latlngs) {
          Polyline2.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w42 = this.options.weight, p42 = new Point(w42, w42);
          bounds = new Bounds(bounds.min.subtract(p42), bounds.max.add(p42));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i12 = 0, len = this._rings.length, clipped; i12 < len; i12++) {
            clipped = clipPolygon(this._rings[i12], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p42) {
          var inside = false, part, p1, p222, i12, j42, k42, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p42)) {
            return false;
          }
          for (i12 = 0, len = this._parts.length; i12 < len; i12++) {
            part = this._parts[i12];
            for (j42 = 0, len2 = part.length, k42 = len2 - 1; j42 < len2; k42 = j42++) {
              p1 = part[j42];
              p222 = part[k42];
              if (p1.y > p42.y !== p222.y > p42.y && p42.x < (p222.x - p1.x) * (p42.y - p1.y) / (p222.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline2.prototype._containsPoint.call(this, p42, true);
        }
      });
      function polygon2(latlngs, options) {
        return new Polygon2(latlngs, options);
      }
      var GeoJSON2 = FeatureGroup.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(geojson, options) {
          setOptions(this, options);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(geojson) {
          var features = isArray(geojson) ? geojson : geojson.features, i12, len, feature;
          if (features) {
            for (i12 = 0, len = features.length; i12 < len; i12++) {
              feature = features[i12];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options = this.options;
          if (options.filter && !options.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options.onEachFeature) {
            options.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(style3) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style3);
          }, this);
        },
        _setLayerStyle: function(layer, style3) {
          if (layer.setStyle) {
            if (typeof style3 === "function") {
              style3 = style3(layer.feature);
            }
            layer.setStyle(style3);
          }
        }
      });
      function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i12, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options);
          case "MultiPoint":
            for (i12 = 0, len = coords.length; i12 < len; i12++) {
              latlng = _coordsToLatLng(coords[i12]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline2(latlngs, options);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon2(latlngs, options);
          case "GeometryCollection":
            for (i12 = 0, len = geometry.geometries.length; i12 < len; i12++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i12],
                type: "Feature",
                properties: geojson.properties
              }, options);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i12 = 0, len = geometry.features.length; i12 < len; i12++) {
              var featureLayer = geometryToLayer(geometry.features[i12], options);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
      }
      function coordsToLatLng(coords) {
        return new LatLng(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i12 = 0, len = coords.length, latlng; i12 < len; i12++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i12], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i12]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i12 = 0, len = latlngs.length; i12 < len; i12++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i12], isFlat(latlngs[i12]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i12], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker.include(PointToGeoJSON);
      Circle2.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline2.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon2.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON2(geojson, options) {
        return new GeoJSON2(geojson, options);
      }
      var geoJson = geoJSON2;
      var ImageOverlay = Layer.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(url, bounds, options) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind(this.fire, this, "load");
          img.onerror = bind(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e17) {
          var scale2 = this._map.getZoomScale(e17.zoom), offset22 = this._map._latLngBoundsToNewLayerBounds(this._bounds, e17.zoom, e17.center).min;
          setTransform(this._image, offset22, scale2);
        },
        _reset: function() {
          var image = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size22 = bounds.getSize();
          setPosition(image, bounds.min);
          image.style.width = size22.x + "px";
          image.style.height = size22.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
      };
      var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: true,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: true,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: true,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: false,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j42 = 0; j42 < sourceElements.length; j42++) {
              sources.push(sourceElements[j42].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i12 = 0; i12 < this._url.length; i12++) {
            var source = create$1("source");
            source.src = this._url[i12];
            vid.appendChild(source);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
      }
      var DivOverlay = Layer.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: false,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(options, source) {
          if (options && (options instanceof LatLng || isArray(options))) {
            this._latlng = toLatLng(options);
            setOptions(this, source);
          } else {
            setOptions(this, options);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this)) {
            map2.addLayer(this);
          }
          return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map2) {
          this._zoomAnimated = map2._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map2._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map2) {
          if (map2._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(content) {
          this._content = content;
          this.update();
          return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id3 in layers2) {
              if (layers2[id3]._map) {
                source = layers2[id3];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node = this._contentNode;
          var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content === "string") {
            node.innerHTML = content;
          } else {
            while (node.hasChildNodes()) {
              node.removeChild(node.firstChild);
            }
            node.appendChild(content);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset22 = toPoint(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset22 = offset22.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset22.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset22.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map2.include({
        _initOverlay: function(OverlayClass, content, latlng, options) {
          var overlay = content;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options).setContent(content);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer.include({
        _initOverlay: function(OverlayClass, old, content, options) {
          var overlay = content;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options);
            overlay._source = this;
          } else {
            overlay = old && !options ? old : new OverlayClass(options, this);
            overlay.setContent(content);
          }
          return overlay;
        }
      });
      var Popup = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: true,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: false,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: true,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: true,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: true,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(map2) {
          map2 = arguments.length ? map2 : this._source._map;
          if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
            map2.removeLayer(map2._popup);
          }
          map2._popup = this;
          return DivOverlay.prototype.openOn.call(this, map2);
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          map2.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix + "-tip-container", container);
          this._tip = create$1("div", prefix + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style3 = container.style;
          style3.width = "";
          style3.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style3.width = width + 1 + "px";
          style3.whiteSpace = "";
          style3.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style3.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e17) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e17.zoom, e17.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size22 = map2.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size22.x) {
            dx = containerPos.x + containerWidth - size22.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size22.y) {
            dy = containerPos.y + containerHeight - size22.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map2.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup = function(options, source) {
        return new Popup(options, source);
      };
      Map2.mergeOptions({
        closePopupOnClick: true
      });
      Map2.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(popup2, latlng, options) {
          this._initOverlay(Popup, popup2, latlng, options).openOn(this);
          return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(popup2) {
          popup2 = arguments.length ? popup2 : this._popup;
          if (popup2) {
            popup2.close();
          }
          return this;
        }
      });
      Layer.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(content, options) {
          this._popup = this._initOverlay(Popup, this._popup, content, options);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(content) {
          if (this._popup) {
            this._popup.setContent(content);
          }
          return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e17) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e17);
          var target = e17.layer || e17.target;
          if (this._popup._source === target && !(target instanceof Path)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e17.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e17.latlng);
        },
        _movePopup: function(e17) {
          this._popup.setLatLng(e17.latlng);
        },
        _onKeyPress: function(e17) {
          if (e17.originalEvent.keyCode === 13) {
            this._openPopup(e17);
          }
        }
      });
      var Tooltip = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: false,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: false,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(map2) {
          DivOverlay.prototype.onAdd.call(this, map2);
          this.setOpacity(this.options.opacity);
          map2.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map2) {
          DivOverlay.prototype.onRemove.call(this, map2);
          map2.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset22 = toPoint(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset22.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint(subX, subY, true)).add(offset22).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e17) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e17.zoom, e17.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip = function(options, source) {
        return new Tooltip(options, source);
      };
      Map2.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(tooltip2, latlng, options) {
          this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
          return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(tooltip2) {
          tooltip2.close();
          return this;
        }
      });
      Layer.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(content, options) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(content) {
          if (this._tooltip) {
            this._tooltip.setContent(content);
          }
          return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e17) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e17);
            });
            return;
          }
          this._tooltip._source = e17.layer || e17.target;
          this.openTooltip(this._tooltip.options.sticky ? e17.latlng : void 0);
        },
        _moveTooltip: function(e17) {
          var latlng = e17.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e17.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e17.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: false,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
          if (options.html instanceof Element) {
            empty(div);
            div.appendChild(options.html);
          } else {
            div.innerHTML = options.html !== false ? options.html : "";
          }
          if (options.bgPos) {
            var bgPos = toPoint(options.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon2(options) {
        return new DivIcon(options);
      }
      Icon.Default = IconDefault;
      var GridLayer = Layer.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Browser.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: true,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: false,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map2) {
          map2._addZoomLimit(this);
        },
        onRemove: function(map2) {
          this._removeAllTiles();
          remove(this._container);
          map2._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var s9 = this.options.tileSize;
          return s9 instanceof Point ? s9 : new Point(s9, s9);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i12 = 0, len = layers2.length, zIndex; i12 < len; i12++) {
            zIndex = layers2[i12].style.zIndex;
            if (layers2[i12] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z42 in this._levels) {
            z42 = Number(z42);
            if (this._levels[z42].el.children.length || z42 === zoom2) {
              this._levels[z42].el.style.zIndex = maxZoom - Math.abs(zoom2 - z42);
              this._onUpdateLevel(z42);
            } else {
              remove(this._levels[z42].el);
              this._removeTilesAtZoom(z42);
              this._onRemoveLevel(z42);
              delete this._levels[z42];
            }
          }
          var level = this._levels[zoom2], map2 = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z42 in this._levels) {
            remove(this._levels[z42].el);
            this._onRemoveLevel(Number(z42));
            delete this._levels[z42];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x52, y42, z42, minZoom) {
          var x222 = Math.floor(x52 / 2), y222 = Math.floor(y42 / 2), z222 = z42 - 1, coords2 = new Point(+x222, +y222);
          coords2.z = +z222;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z222 > minZoom) {
            return this._retainParent(x222, y222, z222, minZoom);
          }
          return false;
        },
        _retainChildren: function(x52, y42, z42, maxZoom) {
          for (var i12 = 2 * x52; i12 < 2 * x52 + 2; i12++) {
            for (var j42 = 2 * y42; j42 < 2 * y42 + 2; j42++) {
              var coords = new Point(i12, j42);
              coords.z = z42 + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z42 + 1 < maxZoom) {
                this._retainChildren(i12, j42, z42 + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e17) {
          var animating = e17 && (e17.pinch || e17.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e17) {
          this._setView(e17.center, e17.zoom, true, e17.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options = this.options;
          if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
            return options.minNativeZoom;
          }
          if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
            return options.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i12 in this._levels) {
            this._setZoomTransform(this._levels[i12], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser.any3d) {
            setTransform(level.el, translate, scale2);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(center) {
          var map2 = this._map;
          if (!map2) {
            return;
          }
          var zoom2 = this._clampZoom(map2.getZoom());
          if (center === void 0) {
            center = map2.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c92 = this._tiles[key].coords;
            if (c92.z !== this._tileZoom || !noPruneRange.contains(new Point(c92.x, c92.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j42 = tileRange.min.y; j42 <= tileRange.max.y; j42++) {
            for (var i12 = tileRange.min.x; i12 <= tileRange.max.x; i12++) {
              var coords = new Point(i12, j42);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a72, b42) {
            return a72.distanceTo(tileCenter) - b42.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i12 = 0; i12 < queue.length; i12++) {
              this._addTile(queue[i12], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se22 = map2.unproject(sePoint, coords.z);
          return [nw, se22];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(key) {
          var k42 = key.split(":"), coords = new Point(+k42[0], +k42[1]);
          coords.z = +k42[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +/* @__PURE__ */ new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options) {
        return new GridLayer(options);
      }
      var TileLayer2 = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: false,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: false,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: false
        },
        initialize: function(url, options) {
          this._url = url;
          options = setOptions(this, options);
          if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
            options.tileSize = Math.floor(options.tileSize / 2);
            if (!options.zoomReverse) {
              options.zoomOffset++;
              options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
            } else {
              options.zoomOffset--;
              options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
            }
            options.minZoom = Math.max(0, options.minZoom);
          } else if (!options.zoomReverse) {
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
          } else {
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
          }
          if (typeof options.subdomains === "string") {
            options.subdomains = options.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(coords) {
          var data = {
            r: Browser.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser.ielt9) {
            setTimeout(bind(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e17) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e17, tile);
        },
        _onTileRemove: function(e17) {
          e17.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index2];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var i12, tile;
          for (i12 in this._tiles) {
            if (this._tiles[i12].coords.z !== this._tileZoom) {
              tile = this._tiles[i12].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i12].coords;
                remove(tile);
                delete this._tiles[i12];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer2(url, options) {
        return new TileLayer2(url, options);
      }
      var TileLayerWMS = TileLayer2.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: false,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: false
        },
        initialize: function(url, options) {
          this._url = url;
          var wmsParams = extend({}, this.defaultWmsParams);
          for (var i12 in options) {
            if (!(i12 in this.options)) {
              wmsParams[i12] = options[i12];
            }
          }
          options = setOptions(this, options);
          var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map2) {
          this._crs = this.options.crs || map2.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer2.prototype.onAdd.call(this, map2);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min22 = bounds.min, max22 = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min22.y, min22.x, max22.y, max22.x] : [min22.x, min22.y, max22.x, max22.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(params, noRedraw) {
          extend(this.wmsParams, params);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
      }
      TileLayer2.WMS = TileLayerWMS;
      tileLayer2.wms = tileLayerWMS;
      var Renderer = Layer.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(options) {
          setOptions(this, options);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser.any3d) {
            setTransform(this._container, topLeftOffset, scale2);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id3 in this._layers) {
            this._layers[id3]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id3 in this._layers) {
            this._layers[id3]._project();
          }
        },
        _updatePaths: function() {
          for (var id3 in this._layers) {
            this._layers[id3]._update();
          }
        },
        _update: function() {
          var p42 = this.options.padding, size22 = this._map.getSize(), min22 = this._map.containerPointToLayerPoint(size22.multiplyBy(-p42)).round();
          this._bounds = new Bounds(min22, min22.add(size22.multiplyBy(1 + p42 * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id3 in this._layers) {
            layer = this._layers[id3];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b42 = this._bounds, container = this._container, size22 = b42.getSize(), m42 = Browser.retina ? 2 : 1;
          setPosition(container, b42.min);
          container.width = m42 * size22.x;
          container.height = m42 * size22.y;
          container.style.width = size22.x + "px";
          container.style.height = size22.y + "px";
          if (Browser.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b42.min.x, -b42.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order;
          }
          this._drawLast = order;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order = layer._order;
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts2 = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i12;
            for (i12 = 0; i12 < parts2.length; i12++) {
              dashValue = Number(parts2[i12]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size22 = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size22.x, size22.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size22 = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size22.x, size22.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i12, j42, len2, p42, parts2 = layer._parts, len = parts2.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i12 = 0; i12 < len; i12++) {
            for (j42 = 0, len2 = parts2[i12].length; j42 < len2; j42++) {
              p42 = parts2[i12][j42];
              ctx[j42 ? "lineTo" : "moveTo"](p42.x, p42.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p42 = layer._point, ctx = this._ctx, r112 = Math.max(Math.round(layer._radius), 1), s9 = (Math.max(Math.round(layer._radiusY), 1) || r112) / r112;
          if (s9 !== 1) {
            ctx.save();
            ctx.scale(1, s9);
          }
          ctx.beginPath();
          ctx.arc(p42.x, p42.y / s9, r112, 0, Math.PI * 2, false);
          if (s9 !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options = layer.options;
          if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || "evenodd");
          }
          if (options.stroke && options.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
          }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(e17) {
          var point = this._map.mouseEventToLayerPoint(e17), layer, clickedLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              if (!(e17.type === "click" || e17.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e17);
        },
        _onMouseMove: function(e17) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point = this._map.mouseEventToLayerPoint(e17);
          this._handleMouseHover(e17, point);
        },
        _handleMouseOut: function(e17) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e17, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e17, point) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e17);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e17, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e17);
          this._mouseHoverThrottled = true;
          setTimeout(bind(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e17, type) {
          this._map._fireDOMEvent(e17, type || e17.type, layers2);
        },
        _bringToFront: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order.prev = this._drawLast;
          this._drawLast.next = order;
          order.next = null;
          this._drawLast = order;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order.prev = null;
          order.next = this._drawFirst;
          this._drawFirst.prev = order;
          this._drawFirst = order;
          this._requestRedraw(layer);
        }
      });
      function canvas(options) {
        return Browser.canvas ? new Canvas(options) : null;
      }
      var vmlCreate = function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name) {
            return document.createElement("<lvml:" + name + ' class="lvml">');
          };
        } catch (e17) {
        }
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
          container.stroked = !!options.stroke;
          container.filled = !!options.fill;
          if (options.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options.weight + "px";
            stroke.color = options.color;
            stroke.opacity = options.opacity;
            if (options.dashArray) {
              stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options.lineCap.replace("butt", "flat");
            stroke.joinstyle = options.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options.fillColor || options.color;
            fill.opacity = options.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p42 = layer._point.round(), r112 = Math.round(layer._radius), r226 = Math.round(layer._radiusY || r112);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p42.x + "," + p42.y + " " + r112 + "," + r226 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path) {
          layer._path.v = path;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create = Browser.vml ? vmlCreate : svgCreate;
      var SVG = Renderer.extend({
        _initContainer: function() {
          this._container = create("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b42 = this._bounds, size22 = b42.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size22)) {
            this._svgSize = size22;
            container.setAttribute("width", size22.x);
            container.setAttribute("height", size22.y);
          }
          setPosition(container, b42.min);
          container.setAttribute("viewBox", [b42.min.x, b42.min.y, size22.x, size22.y].join(" "));
          this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function(layer) {
          var path = layer._path = create("path");
          if (layer.options.className) {
            addClass(path, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path = layer._path, options = layer.options;
          if (!path) {
            return;
          }
          if (options.stroke) {
            path.setAttribute("stroke", options.color);
            path.setAttribute("stroke-opacity", options.opacity);
            path.setAttribute("stroke-width", options.weight);
            path.setAttribute("stroke-linecap", options.lineCap);
            path.setAttribute("stroke-linejoin", options.lineJoin);
            if (options.dashArray) {
              path.setAttribute("stroke-dasharray", options.dashArray);
            } else {
              path.removeAttribute("stroke-dasharray");
            }
            if (options.dashOffset) {
              path.setAttribute("stroke-dashoffset", options.dashOffset);
            } else {
              path.removeAttribute("stroke-dashoffset");
            }
          } else {
            path.setAttribute("stroke", "none");
          }
          if (options.fill) {
            path.setAttribute("fill", options.fillColor || options.color);
            path.setAttribute("fill-opacity", options.fillOpacity);
            path.setAttribute("fill-rule", options.fillRule || "evenodd");
          } else {
            path.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p42 = layer._point, r112 = Math.max(Math.round(layer._radius), 1), r226 = Math.max(Math.round(layer._radiusY), 1) || r112, arc = "a" + r112 + "," + r226 + " 0 1,0 ";
          var d52 = layer._empty() ? "M0 0" : "M" + (p42.x - r112) + "," + p42.y + arc + r112 * 2 + ",0 " + arc + -r112 * 2 + ",0 ";
          this._setPath(layer, d52);
        },
        _setPath: function(layer, path) {
          layer._path.setAttribute("d", path);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser.vml) {
        SVG.include(vmlMixin);
      }
      function svg2(options) {
        return Browser.svg || Browser.vml ? new SVG(options) : null;
      }
      Map2.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name) {
          if (name === "overlayPane" || name === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name });
            this._paneRenderers[name] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options) {
          return this.options.preferCanvas && canvas(options) || svg2(options);
        }
      });
      var Rectangle2 = Polygon2.extend({
        initialize: function(latLngBounds2, options) {
          Polygon2.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds2), options);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(latLngBounds2) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds2));
        },
        _boundsToLatLngs: function(latLngBounds2) {
          latLngBounds2 = toLatLngBounds(latLngBounds2);
          return [
            latLngBounds2.getSouthWest(),
            latLngBounds2.getNorthWest(),
            latLngBounds2.getNorthEast(),
            latLngBounds2.getSouthEast()
          ];
        }
      });
      function rectangle2(latLngBounds2, options) {
        return new Rectangle2(latLngBounds2, options);
      }
      SVG.create = create;
      SVG.pointsToPath = pointsToPath;
      GeoJSON2.geometryToLayer = geometryToLayer;
      GeoJSON2.coordsToLatLng = coordsToLatLng;
      GeoJSON2.coordsToLatLngs = coordsToLatLngs;
      GeoJSON2.latLngToCoords = latLngToCoords;
      GeoJSON2.latLngsToCoords = latLngsToCoords;
      GeoJSON2.getFeature = getFeature;
      GeoJSON2.asFeature = asFeature;
      Map2.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map2) {
          this._map = map2;
          this._container = map2._container;
          this._pane = map2._panes.overlayPane;
          this._resetStateTimeout = 0;
          map2.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e17) {
          if (!e17.shiftKey || e17.which !== 1 && e17.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e17);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e17) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e17);
          var bounds = new Bounds(this._point, this._startPoint), size22 = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size22.x + "px";
          this._box.style.height = size22.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e17) {
          if (e17.which !== 1 && e17.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
          var bounds = new LatLngBounds(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e17) {
          if (e17.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map2.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e17) {
          var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e17.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map2.options.doubleClickZoom === "center") {
            map2.setZoom(zoom2);
          } else {
            map2.setZoomAround(e17.containerPoint, zoom2);
          }
        }
      });
      Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map2.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map2 = this._map;
            this._draggable = new Draggable(map2._mapPane, map2._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map2.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map2.on("zoomend", this._onZoomEnd, this);
              map2.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map2 = this._map;
          map2._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map2.fire("movestart").fire("dragstart");
          if (map2.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e17) {
          if (this._map.options.inertia) {
            var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time);
            this._prunePositions(time);
          }
          this._map.fire("move", e17).fire("drag", e17);
        },
        _prunePositions: function(time) {
          while (this._positions.length > 1 && time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold) {
          return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset22 = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset22.x < limit.min.x) {
            offset22.x = this._viscousLimit(offset22.x, limit.min.x);
          }
          if (offset22.y < limit.min.y) {
            offset22.y = this._viscousLimit(offset22.y, limit.min.y);
          }
          if (offset22.x > limit.max.x) {
            offset22.x = this._viscousLimit(offset22.x, limit.max.x);
          }
          if (offset22.y > limit.max.y) {
            offset22.y = this._viscousLimit(offset22.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset22);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x52 = this._draggable._newPos.x, newX1 = (x52 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x52 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e17) {
          var map2 = this._map, options = map2.options, noInertia = !options.inertia || e17.noInertia || this._times.length < 2;
          map2.fire("dragend", e17);
          if (noInertia) {
            map2.fire("moveend");
          } else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset22 = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset22.x && !offset22.y) {
              map2.fire("moveend");
            } else {
              offset22 = map2._limitOffset(offset22, map2.options.maxBounds);
              requestAnimFrame(function() {
                map2.panBy(offset22, {
                  duration: decelerationDuration,
                  easeLinearity: ease,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map2.addInitHook("addHandler", "dragging", Drag);
      Map2.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map2) {
          this._map = map2;
          this._setPanDelta(map2.options.keyboardPanDelta);
          this._setZoomDelta(map2.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys = this._panKeys = {}, codes = this.keyCodes, i12, len;
          for (i12 = 0, len = codes.left.length; i12 < len; i12++) {
            keys[codes.left[i12]] = [-1 * panDelta, 0];
          }
          for (i12 = 0, len = codes.right.length; i12 < len; i12++) {
            keys[codes.right[i12]] = [panDelta, 0];
          }
          for (i12 = 0, len = codes.down.length; i12 < len; i12++) {
            keys[codes.down[i12]] = [0, panDelta];
          }
          for (i12 = 0, len = codes.up.length; i12 < len; i12++) {
            keys[codes.up[i12]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys = this._zoomKeys = {}, codes = this.keyCodes, i12, len;
          for (i12 = 0, len = codes.zoomIn.length; i12 < len; i12++) {
            keys[codes.zoomIn[i12]] = zoomDelta;
          }
          for (i12 = 0, len = codes.zoomOut.length; i12 < len; i12++) {
            keys[codes.zoomOut[i12]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e17) {
          if (e17.altKey || e17.ctrlKey || e17.metaKey) {
            return;
          }
          var key = e17.keyCode, map2 = this._map, offset22;
          if (key in this._panKeys) {
            if (!map2._panAnim || !map2._panAnim._inProgress) {
              offset22 = this._panKeys[key];
              if (e17.shiftKey) {
                offset22 = toPoint(offset22).multiplyBy(3);
              }
              if (map2.options.maxBounds) {
                offset22 = map2._limitOffset(toPoint(offset22), map2.options.maxBounds);
              }
              if (map2.options.worldCopyJump) {
                var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset22)));
                map2.panTo(newLatLng);
              } else {
                map2.panBy(offset22);
              }
            }
          } else if (key in this._zoomKeys) {
            map2.setZoom(map2.getZoom() + (e17.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
            map2.closePopup();
          } else {
            return;
          }
          stop(e17);
        }
      });
      Map2.addInitHook("addHandler", "keyboard", Keyboard);
      Map2.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e17) {
          var delta = getWheelDelta(e17);
          var debounce2 = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e17);
          if (!this._startTime) {
            this._startTime = +/* @__PURE__ */ new Date();
          }
          var left = Math.max(debounce2 - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind(this._performZoom, this), left);
          stop(e17);
        },
        _performZoom: function() {
          var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
          map2._stop();
          var d222 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d322 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d222)))) / Math.LN2, d422 = snap ? Math.ceil(d322 / snap) * snap : d322, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d422 : -d422)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map2.options.scrollWheelZoom === "center") {
            map2.setZoom(zoom2 + delta);
          } else {
            map2.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map2.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e17) {
          clearTimeout(this._holdTimeout);
          if (e17.touches.length !== 1) {
            return;
          }
          var first = e17.touches[0];
          this._startPos = this._newPos = new Point(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e17) {
          var first = e17.touches[0];
          this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e17) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            // detail: 1,
            screenX: e17.screenX,
            screenY: e17.screenY,
            clientX: e17.clientX,
            clientY: e17.clientY
            // button: 2,
            // buttons: 2
          });
          simulatedEvent._simulated = true;
          e17.target.dispatchEvent(simulatedEvent);
        }
      });
      Map2.addInitHook("addHandler", "tapHold", TapHold);
      Map2.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e17) {
          var map2 = this._map;
          if (!e17.touches || e17.touches.length !== 2 || map2._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map2.mouseEventToContainerPoint(e17.touches[0]), p222 = map2.mouseEventToContainerPoint(e17.touches[1]);
          this._centerPoint = map2.getSize()._divideBy(2);
          this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
          if (map2.options.touchZoom !== "center") {
            this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p222)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p222);
          this._startZoom = map2.getZoom();
          this._moved = false;
          this._zooming = true;
          map2._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e17);
        },
        _onTouchMove: function(e17) {
          if (!e17.touches || e17.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e17.touches[0]), p222 = map2.mouseEventToContainerPoint(e17.touches[1]), scale2 = p1.distanceTo(p222) / this._startDist;
          this._zoom = map2.getScaleZoom(scale2, this._startZoom);
          if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
            this._zoom = map2._limitZoom(this._zoom);
          }
          if (map2.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale2 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p222)._divideBy(2)._subtract(this._centerPoint);
            if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map2._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e17);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map2.BoxZoom = BoxZoom;
      Map2.DoubleClickZoom = DoubleClickZoom;
      Map2.Drag = Drag;
      Map2.Keyboard = Keyboard;
      Map2.ScrollWheelZoom = ScrollWheelZoom;
      Map2.TapHold = TapHold;
      Map2.TouchZoom = TouchZoom;
      exports2.Bounds = Bounds;
      exports2.Browser = Browser;
      exports2.CRS = CRS;
      exports2.Canvas = Canvas;
      exports2.Circle = Circle2;
      exports2.CircleMarker = CircleMarker;
      exports2.Class = Class;
      exports2.Control = Control;
      exports2.DivIcon = DivIcon;
      exports2.DivOverlay = DivOverlay;
      exports2.DomEvent = DomEvent;
      exports2.DomUtil = DomUtil;
      exports2.Draggable = Draggable;
      exports2.Evented = Evented;
      exports2.FeatureGroup = FeatureGroup;
      exports2.GeoJSON = GeoJSON2;
      exports2.GridLayer = GridLayer;
      exports2.Handler = Handler;
      exports2.Icon = Icon;
      exports2.ImageOverlay = ImageOverlay;
      exports2.LatLng = LatLng;
      exports2.LatLngBounds = LatLngBounds;
      exports2.Layer = Layer;
      exports2.LayerGroup = LayerGroup;
      exports2.LineUtil = LineUtil;
      exports2.Map = Map2;
      exports2.Marker = Marker;
      exports2.Mixin = Mixin;
      exports2.Path = Path;
      exports2.Point = Point;
      exports2.PolyUtil = PolyUtil;
      exports2.Polygon = Polygon2;
      exports2.Polyline = Polyline2;
      exports2.Popup = Popup;
      exports2.PosAnimation = PosAnimation;
      exports2.Projection = index;
      exports2.Rectangle = Rectangle2;
      exports2.Renderer = Renderer;
      exports2.SVG = SVG;
      exports2.SVGOverlay = SVGOverlay;
      exports2.TileLayer = TileLayer2;
      exports2.Tooltip = Tooltip;
      exports2.Transformation = Transformation;
      exports2.Util = Util;
      exports2.VideoOverlay = VideoOverlay;
      exports2.bind = bind;
      exports2.bounds = toBounds;
      exports2.canvas = canvas;
      exports2.circle = circle2;
      exports2.circleMarker = circleMarker;
      exports2.control = control2;
      exports2.divIcon = divIcon2;
      exports2.extend = extend;
      exports2.featureGroup = featureGroup;
      exports2.geoJSON = geoJSON2;
      exports2.geoJson = geoJson;
      exports2.gridLayer = gridLayer;
      exports2.icon = icon;
      exports2.imageOverlay = imageOverlay;
      exports2.latLng = toLatLng;
      exports2.latLngBounds = toLatLngBounds;
      exports2.layerGroup = layerGroup;
      exports2.map = createMap;
      exports2.marker = marker3;
      exports2.point = toPoint;
      exports2.polygon = polygon2;
      exports2.polyline = polyline2;
      exports2.popup = popup;
      exports2.rectangle = rectangle2;
      exports2.setOptions = setOptions;
      exports2.stamp = stamp;
      exports2.svg = svg2;
      exports2.svgOverlay = svgOverlay;
      exports2.tileLayer = tileLayer2;
      exports2.tooltip = tooltip;
      exports2.transformation = toTransformation;
      exports2.version = version22;
      exports2.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports2.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports2;
    });
  }
});
var require_leaflet = __commonJS({
  "leaflet/leaflet.js"(exports, module) {
    !function(t11, e17) {
      "object" == typeof exports && "undefined" != typeof module ? e17(exports) : "function" == typeof define && define.amd ? define(["exports"], e17) : e17((t11 = "undefined" != typeof globalThis ? globalThis : t11 || self).leaflet = {});
    }(exports, function(t11) {
      "use strict";
      function l11(t12) {
        for (var e18, i13, n18 = 1, o16 = arguments.length; n18 < o16; n18++) for (e18 in i13 = arguments[n18]) t12[e18] = i13[e18];
        return t12;
      }
      var R42 = Object.create || function(t12) {
        return N42.prototype = t12, new N42();
      };
      function N42() {
      }
      function a72(t12, e18) {
        var i13, n18 = Array.prototype.slice;
        return t12.bind ? t12.bind.apply(t12, n18.call(arguments, 1)) : (i13 = n18.call(arguments, 2), function() {
          return t12.apply(e18, i13.length ? i13.concat(n18.call(arguments)) : arguments);
        });
      }
      var D42 = 0;
      function h92(t12) {
        return "_leaflet_id" in t12 || (t12._leaflet_id = ++D42), t12._leaflet_id;
      }
      function j42(t12, e18, i13) {
        var n18, o16, s10 = function() {
          n18 = false, o16 && (r12.apply(i13, o16), o16 = false);
        }, r12 = function() {
          n18 ? o16 = arguments : (t12.apply(i13, arguments), setTimeout(s10, e18), n18 = true);
        };
        return r12;
      }
      function H2(t12, e18, i13) {
        var n18 = e18[1], e18 = e18[0], o16 = n18 - e18;
        return t12 === n18 && i13 ? t12 : ((t12 - e18) % o16 + o16) % o16 + e18;
      }
      function u62() {
        return false;
      }
      function i12(t12, e18) {
        return false === e18 ? t12 : (e18 = Math.pow(10, void 0 === e18 ? 6 : e18), Math.round(t12 * e18) / e18);
      }
      function W(t12) {
        return t12.trim ? t12.trim() : t12.replace(/^\s+|\s+$/g, "");
      }
      function F32(t12) {
        return W(t12).split(/\s+/);
      }
      function c92(t12, e18) {
        for (var i13 in Object.prototype.hasOwnProperty.call(t12, "options") || (t12.options = t12.options ? R42(t12.options) : {}), e18) t12.options[i13] = e18[i13];
        return t12.options;
      }
      function U32(t12, e18, i13) {
        var n18, o16 = [];
        for (n18 in t12) o16.push(encodeURIComponent(i13 ? n18.toUpperCase() : n18) + "=" + encodeURIComponent(t12[n18]));
        return (e18 && -1 !== e18.indexOf("?") ? "&" : "?") + o16.join("&");
      }
      var V42 = /\{ *([\w_ -]+) *\}/g;
      function q32(t12, i13) {
        return t12.replace(V42, function(t13, e18) {
          e18 = i13[e18];
          if (void 0 === e18) throw new Error("No value provided for variable " + t13);
          return e18 = "function" == typeof e18 ? e18(i13) : e18;
        });
      }
      var d52 = Array.isArray || function(t12) {
        return "[object Array]" === Object.prototype.toString.call(t12);
      };
      function G32(t12, e18) {
        for (var i13 = 0; i13 < t12.length; i13++) if (t12[i13] === e18) return i13;
        return -1;
      }
      var K32 = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function Y32(t12) {
        return window["webkit" + t12] || window["moz" + t12] || window["ms" + t12];
      }
      var X = 0;
      function J(t12) {
        var e18 = +/* @__PURE__ */ new Date(), i13 = Math.max(0, 16 - (e18 - X));
        return X = e18 + i13, window.setTimeout(t12, i13);
      }
      var $42 = window.requestAnimationFrame || Y32("RequestAnimationFrame") || J, Q32 = window.cancelAnimationFrame || Y32("CancelAnimationFrame") || Y32("CancelRequestAnimationFrame") || function(t12) {
        window.clearTimeout(t12);
      };
      function x52(t12, e18, i13) {
        if (!i13 || $42 !== J) return $42.call(window, a72(t12, e18));
        t12.call(e18);
      }
      function r112(t12) {
        t12 && Q32.call(window, t12);
      }
      var tt = { __proto__: null, extend: l11, create: R42, bind: a72, get lastId() {
        return D42;
      }, stamp: h92, throttle: j42, wrapNum: H2, falseFn: u62, formatNum: i12, trim: W, splitWords: F32, setOptions: c92, getParamString: U32, template: q32, isArray: d52, indexOf: G32, emptyImageUrl: K32, requestFn: $42, cancelFn: Q32, requestAnimFrame: x52, cancelAnimFrame: r112 };
      function et35() {
      }
      et35.extend = function(t12) {
        function e18() {
          c92(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
        }
        var i13, n18 = e18.__super__ = this.prototype, o16 = R42(n18);
        for (i13 in (o16.constructor = e18).prototype = o16, this) Object.prototype.hasOwnProperty.call(this, i13) && "prototype" !== i13 && "__super__" !== i13 && (e18[i13] = this[i13]);
        if (t12.statics && l11(e18, t12.statics), t12.includes) {
          var s10 = t12.includes;
          if ("undefined" != typeof L && L && L.Mixin) {
            s10 = d52(s10) ? s10 : [s10];
            for (var r12 = 0; r12 < s10.length; r12++) s10[r12] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
          l11.apply(null, [o16].concat(t12.includes));
        }
        return l11(o16, t12), delete o16.statics, delete o16.includes, o16.options && (o16.options = n18.options ? R42(n18.options) : {}, l11(o16.options, t12.options)), o16._initHooks = [], o16.callInitHooks = function() {
          if (!this._initHooksCalled) {
            n18.callInitHooks && n18.callInitHooks.call(this), this._initHooksCalled = true;
            for (var t13 = 0, e19 = o16._initHooks.length; t13 < e19; t13++) o16._initHooks[t13].call(this);
          }
        }, e18;
      }, et35.include = function(t12) {
        var e18 = this.prototype.options;
        return l11(this.prototype, t12), t12.options && (this.prototype.options = e18, this.mergeOptions(t12.options)), this;
      }, et35.mergeOptions = function(t12) {
        return l11(this.prototype.options, t12), this;
      }, et35.addInitHook = function(t12) {
        var e18 = Array.prototype.slice.call(arguments, 1), i13 = "function" == typeof t12 ? t12 : function() {
          this[t12].apply(this, e18);
        };
        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i13), this;
      };
      var e17 = { on: function(t12, e18, i13) {
        if ("object" == typeof t12) for (var n18 in t12) this._on(n18, t12[n18], e18);
        else for (var o16 = 0, s10 = (t12 = F32(t12)).length; o16 < s10; o16++) this._on(t12[o16], e18, i13);
        return this;
      }, off: function(t12, e18, i13) {
        if (arguments.length) if ("object" == typeof t12) for (var n18 in t12) this._off(n18, t12[n18], e18);
        else {
          t12 = F32(t12);
          for (var o16 = 1 === arguments.length, s10 = 0, r12 = t12.length; s10 < r12; s10++) o16 ? this._off(t12[s10]) : this._off(t12[s10], e18, i13);
        }
        else delete this._events;
        return this;
      }, _on: function(t12, e18, i13, n18) {
        "function" != typeof e18 ? console.warn("wrong listener type: " + typeof e18) : false === this._listens(t12, e18, i13) && (e18 = { fn: e18, ctx: i13 = i13 === this ? void 0 : i13 }, n18 && (e18.once = true), this._events = this._events || {}, this._events[t12] = this._events[t12] || [], this._events[t12].push(e18));
      }, _off: function(t12, e18, i13) {
        var n18, o16, s10;
        if (this._events && (n18 = this._events[t12])) if (1 === arguments.length) {
          if (this._firingCount) for (o16 = 0, s10 = n18.length; o16 < s10; o16++) n18[o16].fn = u62;
          delete this._events[t12];
        } else "function" != typeof e18 ? console.warn("wrong listener type: " + typeof e18) : false !== (e18 = this._listens(t12, e18, i13)) && (i13 = n18[e18], this._firingCount && (i13.fn = u62, this._events[t12] = n18 = n18.slice()), n18.splice(e18, 1));
      }, fire: function(t12, e18, i13) {
        if (this.listens(t12, i13)) {
          var n18 = l11({}, e18, { type: t12, target: this, sourceTarget: e18 && e18.sourceTarget || this });
          if (this._events) {
            var o16 = this._events[t12];
            if (o16) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var s10 = 0, r12 = o16.length; s10 < r12; s10++) {
                var a8 = o16[s10], h10 = a8.fn;
                a8.once && this.off(t12, h10, a8.ctx), h10.call(a8.ctx || this, n18);
              }
              this._firingCount--;
            }
          }
          i13 && this._propagateEvent(n18);
        }
        return this;
      }, listens: function(t12, e18, i13, n18) {
        "string" != typeof t12 && console.warn('"string" type argument expected');
        var o16 = e18, s10 = ("function" != typeof e18 && (n18 = !!e18, i13 = o16 = void 0), this._events && this._events[t12]);
        if (s10 && s10.length && false !== this._listens(t12, o16, i13)) return true;
        if (n18) {
          for (var r12 in this._eventParents) if (this._eventParents[r12].listens(t12, e18, i13, n18)) return true;
        }
        return false;
      }, _listens: function(t12, e18, i13) {
        if (this._events) {
          var n18 = this._events[t12] || [];
          if (!e18) return !!n18.length;
          i13 === this && (i13 = void 0);
          for (var o16 = 0, s10 = n18.length; o16 < s10; o16++) if (n18[o16].fn === e18 && n18[o16].ctx === i13) return o16;
        }
        return false;
      }, once: function(t12, e18, i13) {
        if ("object" == typeof t12) for (var n18 in t12) this._on(n18, t12[n18], e18, true);
        else for (var o16 = 0, s10 = (t12 = F32(t12)).length; o16 < s10; o16++) this._on(t12[o16], e18, i13, true);
        return this;
      }, addEventParent: function(t12) {
        return this._eventParents = this._eventParents || {}, this._eventParents[h92(t12)] = t12, this;
      }, removeEventParent: function(t12) {
        return this._eventParents && delete this._eventParents[h92(t12)], this;
      }, _propagateEvent: function(t12) {
        for (var e18 in this._eventParents) this._eventParents[e18].fire(t12.type, l11({ layer: t12.target, propagatedFrom: t12.target }, t12), true);
      } }, it = (e17.addEventListener = e17.on, e17.removeEventListener = e17.clearAllEventListeners = e17.off, e17.addOneTimeEventListener = e17.once, e17.fireEvent = e17.fire, e17.hasEventListeners = e17.listens, et35.extend(e17));
      function p42(t12, e18, i13) {
        this.x = i13 ? Math.round(t12) : t12, this.y = i13 ? Math.round(e18) : e18;
      }
      var nt5 = Math.trunc || function(t12) {
        return 0 < t12 ? Math.floor(t12) : Math.ceil(t12);
      };
      function m42(t12, e18, i13) {
        return t12 instanceof p42 ? t12 : d52(t12) ? new p42(t12[0], t12[1]) : null == t12 ? t12 : "object" == typeof t12 && "x" in t12 && "y" in t12 ? new p42(t12.x, t12.y) : new p42(t12, e18, i13);
      }
      function f82(t12, e18) {
        if (t12) for (var i13 = e18 ? [t12, e18] : t12, n18 = 0, o16 = i13.length; n18 < o16; n18++) this.extend(i13[n18]);
      }
      function _42(t12, e18) {
        return !t12 || t12 instanceof f82 ? t12 : new f82(t12, e18);
      }
      function s9(t12, e18) {
        if (t12) for (var i13 = e18 ? [t12, e18] : t12, n18 = 0, o16 = i13.length; n18 < o16; n18++) this.extend(i13[n18]);
      }
      function g42(t12, e18) {
        return t12 instanceof s9 ? t12 : new s9(t12, e18);
      }
      function v42(t12, e18, i13) {
        if (isNaN(t12) || isNaN(e18)) throw new Error("Invalid LatLng object: (" + t12 + ", " + e18 + ")");
        this.lat = +t12, this.lng = +e18, void 0 !== i13 && (this.alt = +i13);
      }
      function w42(t12, e18, i13) {
        return t12 instanceof v42 ? t12 : d52(t12) && "object" != typeof t12[0] ? 3 === t12.length ? new v42(t12[0], t12[1], t12[2]) : 2 === t12.length ? new v42(t12[0], t12[1]) : null : null == t12 ? t12 : "object" == typeof t12 && "lat" in t12 ? new v42(t12.lat, "lng" in t12 ? t12.lng : t12.lon, t12.alt) : void 0 === e18 ? null : new v42(t12, e18, i13);
      }
      p42.prototype = { clone: function() {
        return new p42(this.x, this.y);
      }, add: function(t12) {
        return this.clone()._add(m42(t12));
      }, _add: function(t12) {
        return this.x += t12.x, this.y += t12.y, this;
      }, subtract: function(t12) {
        return this.clone()._subtract(m42(t12));
      }, _subtract: function(t12) {
        return this.x -= t12.x, this.y -= t12.y, this;
      }, divideBy: function(t12) {
        return this.clone()._divideBy(t12);
      }, _divideBy: function(t12) {
        return this.x /= t12, this.y /= t12, this;
      }, multiplyBy: function(t12) {
        return this.clone()._multiplyBy(t12);
      }, _multiplyBy: function(t12) {
        return this.x *= t12, this.y *= t12, this;
      }, scaleBy: function(t12) {
        return new p42(this.x * t12.x, this.y * t12.y);
      }, unscaleBy: function(t12) {
        return new p42(this.x / t12.x, this.y / t12.y);
      }, round: function() {
        return this.clone()._round();
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }, floor: function() {
        return this.clone()._floor();
      }, _floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      }, ceil: function() {
        return this.clone()._ceil();
      }, _ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      }, trunc: function() {
        return this.clone()._trunc();
      }, _trunc: function() {
        return this.x = nt5(this.x), this.y = nt5(this.y), this;
      }, distanceTo: function(t12) {
        var e18 = (t12 = m42(t12)).x - this.x, t12 = t12.y - this.y;
        return Math.sqrt(e18 * e18 + t12 * t12);
      }, equals: function(t12) {
        return (t12 = m42(t12)).x === this.x && t12.y === this.y;
      }, contains: function(t12) {
        return t12 = m42(t12), Math.abs(t12.x) <= Math.abs(this.x) && Math.abs(t12.y) <= Math.abs(this.y);
      }, toString: function() {
        return "Point(" + i12(this.x) + ", " + i12(this.y) + ")";
      } }, f82.prototype = { extend: function(t12) {
        var e18, i13;
        if (t12) {
          if (t12 instanceof p42 || "number" == typeof t12[0] || "x" in t12) e18 = i13 = m42(t12);
          else if (e18 = (t12 = _42(t12)).min, i13 = t12.max, !e18 || !i13) return this;
          this.min || this.max ? (this.min.x = Math.min(e18.x, this.min.x), this.max.x = Math.max(i13.x, this.max.x), this.min.y = Math.min(e18.y, this.min.y), this.max.y = Math.max(i13.y, this.max.y)) : (this.min = e18.clone(), this.max = i13.clone());
        }
        return this;
      }, getCenter: function(t12) {
        return m42((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t12);
      }, getBottomLeft: function() {
        return m42(this.min.x, this.max.y);
      }, getTopRight: function() {
        return m42(this.max.x, this.min.y);
      }, getTopLeft: function() {
        return this.min;
      }, getBottomRight: function() {
        return this.max;
      }, getSize: function() {
        return this.max.subtract(this.min);
      }, contains: function(t12) {
        var e18, i13;
        return (t12 = ("number" == typeof t12[0] || t12 instanceof p42 ? m42 : _42)(t12)) instanceof f82 ? (e18 = t12.min, i13 = t12.max) : e18 = i13 = t12, e18.x >= this.min.x && i13.x <= this.max.x && e18.y >= this.min.y && i13.y <= this.max.y;
      }, intersects: function(t12) {
        t12 = _42(t12);
        var e18 = this.min, i13 = this.max, n18 = t12.min, t12 = t12.max, o16 = t12.x >= e18.x && n18.x <= i13.x, t12 = t12.y >= e18.y && n18.y <= i13.y;
        return o16 && t12;
      }, overlaps: function(t12) {
        t12 = _42(t12);
        var e18 = this.min, i13 = this.max, n18 = t12.min, t12 = t12.max, o16 = t12.x > e18.x && n18.x < i13.x, t12 = t12.y > e18.y && n18.y < i13.y;
        return o16 && t12;
      }, isValid: function() {
        return !(!this.min || !this.max);
      }, pad: function(t12) {
        var e18 = this.min, i13 = this.max, n18 = Math.abs(e18.x - i13.x) * t12, t12 = Math.abs(e18.y - i13.y) * t12;
        return _42(m42(e18.x - n18, e18.y - t12), m42(i13.x + n18, i13.y + t12));
      }, equals: function(t12) {
        return !!t12 && (t12 = _42(t12), this.min.equals(t12.getTopLeft()) && this.max.equals(t12.getBottomRight()));
      } }, s9.prototype = { extend: function(t12) {
        var e18, i13, n18 = this._southWest, o16 = this._northEast;
        if (t12 instanceof v42) i13 = e18 = t12;
        else {
          if (!(t12 instanceof s9)) return t12 ? this.extend(w42(t12) || g42(t12)) : this;
          if (e18 = t12._southWest, i13 = t12._northEast, !e18 || !i13) return this;
        }
        return n18 || o16 ? (n18.lat = Math.min(e18.lat, n18.lat), n18.lng = Math.min(e18.lng, n18.lng), o16.lat = Math.max(i13.lat, o16.lat), o16.lng = Math.max(i13.lng, o16.lng)) : (this._southWest = new v42(e18.lat, e18.lng), this._northEast = new v42(i13.lat, i13.lng)), this;
      }, pad: function(t12) {
        var e18 = this._southWest, i13 = this._northEast, n18 = Math.abs(e18.lat - i13.lat) * t12, t12 = Math.abs(e18.lng - i13.lng) * t12;
        return new s9(new v42(e18.lat - n18, e18.lng - t12), new v42(i13.lat + n18, i13.lng + t12));
      }, getCenter: function() {
        return new v42((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
      }, getSouthWest: function() {
        return this._southWest;
      }, getNorthEast: function() {
        return this._northEast;
      }, getNorthWest: function() {
        return new v42(this.getNorth(), this.getWest());
      }, getSouthEast: function() {
        return new v42(this.getSouth(), this.getEast());
      }, getWest: function() {
        return this._southWest.lng;
      }, getSouth: function() {
        return this._southWest.lat;
      }, getEast: function() {
        return this._northEast.lng;
      }, getNorth: function() {
        return this._northEast.lat;
      }, contains: function(t12) {
        t12 = ("number" == typeof t12[0] || t12 instanceof v42 || "lat" in t12 ? w42 : g42)(t12);
        var e18, i13, n18 = this._southWest, o16 = this._northEast;
        return t12 instanceof s9 ? (e18 = t12.getSouthWest(), i13 = t12.getNorthEast()) : e18 = i13 = t12, e18.lat >= n18.lat && i13.lat <= o16.lat && e18.lng >= n18.lng && i13.lng <= o16.lng;
      }, intersects: function(t12) {
        t12 = g42(t12);
        var e18 = this._southWest, i13 = this._northEast, n18 = t12.getSouthWest(), t12 = t12.getNorthEast(), o16 = t12.lat >= e18.lat && n18.lat <= i13.lat, t12 = t12.lng >= e18.lng && n18.lng <= i13.lng;
        return o16 && t12;
      }, overlaps: function(t12) {
        t12 = g42(t12);
        var e18 = this._southWest, i13 = this._northEast, n18 = t12.getSouthWest(), t12 = t12.getNorthEast(), o16 = t12.lat > e18.lat && n18.lat < i13.lat, t12 = t12.lng > e18.lng && n18.lng < i13.lng;
        return o16 && t12;
      }, toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      }, equals: function(t12, e18) {
        return !!t12 && (t12 = g42(t12), this._southWest.equals(t12.getSouthWest(), e18) && this._northEast.equals(t12.getNorthEast(), e18));
      }, isValid: function() {
        return !(!this._southWest || !this._northEast);
      } };
      var ot = { latLngToPoint: function(t12, e18) {
        t12 = this.projection.project(t12), e18 = this.scale(e18);
        return this.transformation._transform(t12, e18);
      }, pointToLatLng: function(t12, e18) {
        e18 = this.scale(e18), t12 = this.transformation.untransform(t12, e18);
        return this.projection.unproject(t12);
      }, project: function(t12) {
        return this.projection.project(t12);
      }, unproject: function(t12) {
        return this.projection.unproject(t12);
      }, scale: function(t12) {
        return 256 * Math.pow(2, t12);
      }, zoom: function(t12) {
        return Math.log(t12 / 256) / Math.LN2;
      }, getProjectedBounds: function(t12) {
        var e18;
        return this.infinite ? null : (e18 = this.projection.bounds, t12 = this.scale(t12), new f82(this.transformation.transform(e18.min, t12), this.transformation.transform(e18.max, t12)));
      }, infinite: !(v42.prototype = { equals: function(t12, e18) {
        return !!t12 && (t12 = w42(t12), Math.max(Math.abs(this.lat - t12.lat), Math.abs(this.lng - t12.lng)) <= (void 0 === e18 ? 1e-9 : e18));
      }, toString: function(t12) {
        return "LatLng(" + i12(this.lat, t12) + ", " + i12(this.lng, t12) + ")";
      }, distanceTo: function(t12) {
        return st32.distance(this, w42(t12));
      }, wrap: function() {
        return st32.wrapLatLng(this);
      }, toBounds: function(t12) {
        var t12 = 180 * t12 / 40075017, e18 = t12 / Math.cos(Math.PI / 180 * this.lat);
        return g42([this.lat - t12, this.lng - e18], [this.lat + t12, this.lng + e18]);
      }, clone: function() {
        return new v42(this.lat, this.lng, this.alt);
      } }), wrapLatLng: function(t12) {
        var e18 = this.wrapLng ? H2(t12.lng, this.wrapLng, true) : t12.lng;
        return new v42(this.wrapLat ? H2(t12.lat, this.wrapLat, true) : t12.lat, e18, t12.alt);
      }, wrapLatLngBounds: function(t12) {
        var e18 = t12.getCenter(), i13 = this.wrapLatLng(e18), n18 = e18.lat - i13.lat, e18 = e18.lng - i13.lng;
        return 0 == n18 && 0 == e18 ? t12 : (i13 = t12.getSouthWest(), t12 = t12.getNorthEast(), new s9(new v42(i13.lat - n18, i13.lng - e18), new v42(t12.lat - n18, t12.lng - e18)));
      } }, st32 = l11({}, ot, { wrapLng: [-180, 180], R: 6371e3, distance: function(t12, e18) {
        var i13 = Math.PI / 180, n18 = t12.lat * i13, o16 = e18.lat * i13, s10 = Math.sin((e18.lat - t12.lat) * i13 / 2), e18 = Math.sin((e18.lng - t12.lng) * i13 / 2), t12 = s10 * s10 + Math.cos(n18) * Math.cos(o16) * e18 * e18, i13 = 2 * Math.atan2(Math.sqrt(t12), Math.sqrt(1 - t12));
        return this.R * i13;
      } }), rt4 = 6378137, rt4 = { R: rt4, MAX_LATITUDE: 85.0511287798, project: function(t12) {
        var e18 = Math.PI / 180, i13 = this.MAX_LATITUDE, i13 = Math.max(Math.min(i13, t12.lat), -i13), i13 = Math.sin(i13 * e18);
        return new p42(this.R * t12.lng * e18, this.R * Math.log((1 + i13) / (1 - i13)) / 2);
      }, unproject: function(t12) {
        var e18 = 180 / Math.PI;
        return new v42((2 * Math.atan(Math.exp(t12.y / this.R)) - Math.PI / 2) * e18, t12.x * e18 / this.R);
      }, bounds: new f82([-(rt4 = rt4 * Math.PI), -rt4], [rt4, rt4]) };
      function at(t12, e18, i13, n18) {
        d52(t12) ? (this._a = t12[0], this._b = t12[1], this._c = t12[2], this._d = t12[3]) : (this._a = t12, this._b = e18, this._c = i13, this._d = n18);
      }
      function ht3(t12, e18, i13, n18) {
        return new at(t12, e18, i13, n18);
      }
      at.prototype = { transform: function(t12, e18) {
        return this._transform(t12.clone(), e18);
      }, _transform: function(t12, e18) {
        return t12.x = (e18 = e18 || 1) * (this._a * t12.x + this._b), t12.y = e18 * (this._c * t12.y + this._d), t12;
      }, untransform: function(t12, e18) {
        return new p42((t12.x / (e18 = e18 || 1) - this._b) / this._a, (t12.y / e18 - this._d) / this._c);
      } };
      var lt32 = l11({}, st32, { code: "EPSG:3857", projection: rt4, transformation: ht3(lt32 = 0.5 / (Math.PI * rt4.R), 0.5, -lt32, 0.5) }), ut = l11({}, lt32, { code: "EPSG:900913" });
      function ct(t12) {
        return document.createElementNS("http://www.w3.org/2000/svg", t12);
      }
      function dt3(t12, e18) {
        for (var i13, n18, o16, s10, r12 = "", a8 = 0, h10 = t12.length; a8 < h10; a8++) {
          for (i13 = 0, n18 = (o16 = t12[a8]).length; i13 < n18; i13++) r12 += (i13 ? "L" : "M") + (s10 = o16[i13]).x + " " + s10.y;
          r12 += e18 ? b42.svg ? "z" : "x" : "";
        }
        return r12 || "M0 0";
      }
      var _t2 = document.documentElement.style, pt = "ActiveXObject" in window, mt2 = pt && !document.addEventListener, n17 = "msLaunchUri" in navigator && !("documentMode" in document), ft = y42("webkit"), gt2 = y42("android"), vt = y42("android 2") || y42("android 3"), yt2 = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), yt2 = gt2 && y42("Google") && yt2 < 537 && !("AudioNode" in window), xt = !!window.opera, wt2 = !n17 && y42("chrome"), bt2 = y42("gecko") && !ft && !xt && !pt, Pt = !wt2 && y42("safari"), Lt = y42("phantom"), o15 = "OTransition" in _t2, Tt = 0 === navigator.platform.indexOf("Win"), Mt = pt && "transition" in _t2, zt = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !vt, _t2 = "MozPerspective" in _t2, Ct = !window.L_DISABLE_3D && (Mt || zt || _t2) && !o15 && !Lt, Zt2 = "undefined" != typeof orientation || y42("mobile"), St = Zt2 && ft, Et = Zt2 && zt, kt = !window.PointerEvent && window.MSPointerEvent, Ot = !(!window.PointerEvent && !kt), At = "ontouchstart" in window || !!window.TouchEvent, Bt2 = !window.L_NO_TOUCH && (At || Ot), It = Zt2 && xt, Rt5 = Zt2 && bt2, Nt = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI), Dt = function() {
        var t12 = false;
        try {
          var e18 = Object.defineProperty({}, "passive", { get: function() {
            t12 = true;
          } });
          window.addEventListener("testPassiveEventSupport", u62, e18), window.removeEventListener("testPassiveEventSupport", u62, e18);
        } catch (t13) {
        }
        return t12;
      }(), jt = !!document.createElement("canvas").getContext, Ht = !(!document.createElementNS || !ct("svg").createSVGRect), Wt = !!Ht && ((Wt = document.createElement("div")).innerHTML = "<svg/>", "http://www.w3.org/2000/svg" === (Wt.firstChild && Wt.firstChild.namespaceURI));
      function y42(t12) {
        return 0 <= navigator.userAgent.toLowerCase().indexOf(t12);
      }
      var b42 = { ie: pt, ielt9: mt2, edge: n17, webkit: ft, android: gt2, android23: vt, androidStock: yt2, opera: xt, chrome: wt2, gecko: bt2, safari: Pt, phantom: Lt, opera12: o15, win: Tt, ie3d: Mt, webkit3d: zt, gecko3d: _t2, any3d: Ct, mobile: Zt2, mobileWebkit: St, mobileWebkit3d: Et, msPointer: kt, pointer: Ot, touch: Bt2, touchNative: At, mobileOpera: It, mobileGecko: Rt5, retina: Nt, passiveEvents: Dt, canvas: jt, svg: Ht, vml: !Ht && function() {
        try {
          var t12 = document.createElement("div"), e18 = (t12.innerHTML = '<v:shape adj="1"/>', t12.firstChild);
          return e18.style.behavior = "url(#default#VML)", e18 && "object" == typeof e18.adj;
        } catch (t13) {
          return false;
        }
      }(), inlineSvg: Wt, mac: 0 === navigator.platform.indexOf("Mac"), linux: 0 === navigator.platform.indexOf("Linux") }, Ft3 = b42.msPointer ? "MSPointerDown" : "pointerdown", Ut = b42.msPointer ? "MSPointerMove" : "pointermove", Vt = b42.msPointer ? "MSPointerUp" : "pointerup", qt2 = b42.msPointer ? "MSPointerCancel" : "pointercancel", Gt = { touchstart: Ft3, touchmove: Ut, touchend: Vt, touchcancel: qt2 }, Kt2 = { touchstart: function(t12, e18) {
        e18.MSPOINTER_TYPE_TOUCH && e18.pointerType === e18.MSPOINTER_TYPE_TOUCH && O32(e18);
        ee22(t12, e18);
      }, touchmove: ee22, touchend: ee22, touchcancel: ee22 }, Yt = {}, Xt = false;
      function Jt(t12, e18, i13) {
        return "touchstart" !== e18 || Xt || (document.addEventListener(Ft3, $t2, true), document.addEventListener(Ut, Qt, true), document.addEventListener(Vt, te, true), document.addEventListener(qt2, te, true), Xt = true), Kt2[e18] ? (i13 = Kt2[e18].bind(this, i13), t12.addEventListener(Gt[e18], i13, false), i13) : (console.warn("wrong event specified:", e18), u62);
      }
      function $t2(t12) {
        Yt[t12.pointerId] = t12;
      }
      function Qt(t12) {
        Yt[t12.pointerId] && (Yt[t12.pointerId] = t12);
      }
      function te(t12) {
        delete Yt[t12.pointerId];
      }
      function ee22(t12, e18) {
        if (e18.pointerType !== (e18.MSPOINTER_TYPE_MOUSE || "mouse")) {
          for (var i13 in e18.touches = [], Yt) e18.touches.push(Yt[i13]);
          e18.changedTouches = [e18], t12(e18);
        }
      }
      var ie22 = 200;
      function ne(t12, i13) {
        t12.addEventListener("dblclick", i13);
        var n18, o16 = 0;
        function e18(t13) {
          var e19;
          1 !== t13.detail ? n18 = t13.detail : "mouse" === t13.pointerType || t13.sourceCapabilities && !t13.sourceCapabilities.firesTouchEvents || ((e19 = Ne(t13)).some(function(t14) {
            return t14 instanceof HTMLLabelElement && t14.attributes.for;
          }) && !e19.some(function(t14) {
            return t14 instanceof HTMLInputElement || t14 instanceof HTMLSelectElement;
          }) || ((e19 = Date.now()) - o16 <= ie22 ? 2 === ++n18 && i13(function(t14) {
            var e20, i14, n19 = {};
            for (i14 in t14) e20 = t14[i14], n19[i14] = e20 && e20.bind ? e20.bind(t14) : e20;
            return (t14 = n19).type = "dblclick", n19.detail = 2, n19.isTrusted = false, n19._simulated = true, n19;
          }(t13)) : n18 = 1, o16 = e19));
        }
        return t12.addEventListener("click", e18), { dblclick: i13, simDblclick: e18 };
      }
      var oe, se22, re, ae, he, le, ue = we(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), ce = we(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), de = "webkitTransition" === ce || "OTransition" === ce ? ce + "End" : "transitionend";
      function _e(t12) {
        return "string" == typeof t12 ? document.getElementById(t12) : t12;
      }
      function pe(t12, e18) {
        var i13 = t12.style[e18] || t12.currentStyle && t12.currentStyle[e18];
        return "auto" === (i13 = i13 && "auto" !== i13 || !document.defaultView ? i13 : (t12 = document.defaultView.getComputedStyle(t12, null)) ? t12[e18] : null) ? null : i13;
      }
      function P42(t12, e18, i13) {
        t12 = document.createElement(t12);
        return t12.className = e18 || "", i13 && i13.appendChild(t12), t12;
      }
      function T42(t12) {
        var e18 = t12.parentNode;
        e18 && e18.removeChild(t12);
      }
      function me(t12) {
        for (; t12.firstChild; ) t12.removeChild(t12.firstChild);
      }
      function fe(t12) {
        var e18 = t12.parentNode;
        e18 && e18.lastChild !== t12 && e18.appendChild(t12);
      }
      function ge(t12) {
        var e18 = t12.parentNode;
        e18 && e18.firstChild !== t12 && e18.insertBefore(t12, e18.firstChild);
      }
      function ve(t12, e18) {
        return void 0 !== t12.classList ? t12.classList.contains(e18) : 0 < (t12 = xe4(t12)).length && new RegExp("(^|\\s)" + e18 + "(\\s|$)").test(t12);
      }
      function M42(t12, e18) {
        var i13;
        if (void 0 !== t12.classList) for (var n18 = F32(e18), o16 = 0, s10 = n18.length; o16 < s10; o16++) t12.classList.add(n18[o16]);
        else ve(t12, e18) || ye(t12, ((i13 = xe4(t12)) ? i13 + " " : "") + e18);
      }
      function z42(t12, e18) {
        void 0 !== t12.classList ? t12.classList.remove(e18) : ye(t12, W((" " + xe4(t12) + " ").replace(" " + e18 + " ", " ")));
      }
      function ye(t12, e18) {
        void 0 === t12.className.baseVal ? t12.className = e18 : t12.className.baseVal = e18;
      }
      function xe4(t12) {
        return void 0 === (t12 = t12.correspondingElement ? t12.correspondingElement : t12).className.baseVal ? t12.className : t12.className.baseVal;
      }
      function C2(t12, e18) {
        if ("opacity" in t12.style) t12.style.opacity = e18;
        else if ("filter" in t12.style) {
          var i13 = false, n18 = "DXImageTransform.Microsoft.Alpha";
          try {
            i13 = t12.filters.item(n18);
          } catch (t13) {
            if (1 === e18) return;
          }
          e18 = Math.round(100 * e18), i13 ? (i13.Enabled = 100 !== e18, i13.Opacity = e18) : t12.style.filter += " progid:" + n18 + "(opacity=" + e18 + ")";
        }
      }
      function we(t12) {
        for (var e18 = document.documentElement.style, i13 = 0; i13 < t12.length; i13++) if (t12[i13] in e18) return t12[i13];
        return false;
      }
      function be(t12, e18, i13) {
        e18 = e18 || new p42(0, 0);
        t12.style[ue] = (b42.ie3d ? "translate(" + e18.x + "px," + e18.y + "px)" : "translate3d(" + e18.x + "px," + e18.y + "px,0)") + (i13 ? " scale(" + i13 + ")" : "");
      }
      function Z42(t12, e18) {
        t12._leaflet_pos = e18, b42.any3d ? be(t12, e18) : (t12.style.left = e18.x + "px", t12.style.top = e18.y + "px");
      }
      function Pe(t12) {
        return t12._leaflet_pos || new p42(0, 0);
      }
      function Le() {
        S72(window, "dragstart", O32);
      }
      function Te4() {
        k42(window, "dragstart", O32);
      }
      function Me(t12) {
        for (; -1 === t12.tabIndex; ) t12 = t12.parentNode;
        t12.style && (ze(), le = (he = t12).style.outlineStyle, t12.style.outlineStyle = "none", S72(window, "keydown", ze));
      }
      function ze() {
        he && (he.style.outlineStyle = le, le = he = void 0, k42(window, "keydown", ze));
      }
      function Ce(t12) {
        for (; !((t12 = t12.parentNode).offsetWidth && t12.offsetHeight || t12 === document.body); ) ;
        return t12;
      }
      function Ze(t12) {
        var e18 = t12.getBoundingClientRect();
        return { x: e18.width / t12.offsetWidth || 1, y: e18.height / t12.offsetHeight || 1, boundingClientRect: e18 };
      }
      ae = "onselectstart" in document ? (re = function() {
        S72(window, "selectstart", O32);
      }, function() {
        k42(window, "selectstart", O32);
      }) : (se22 = we(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]), re = function() {
        var t12;
        se22 && (t12 = document.documentElement.style, oe = t12[se22], t12[se22] = "none");
      }, function() {
        se22 && (document.documentElement.style[se22] = oe, oe = void 0);
      });
      pt = { __proto__: null, TRANSFORM: ue, TRANSITION: ce, TRANSITION_END: de, get: _e, getStyle: pe, create: P42, remove: T42, empty: me, toFront: fe, toBack: ge, hasClass: ve, addClass: M42, removeClass: z42, setClass: ye, getClass: xe4, setOpacity: C2, testProp: we, setTransform: be, setPosition: Z42, getPosition: Pe, get disableTextSelection() {
        return re;
      }, get enableTextSelection() {
        return ae;
      }, disableImageDrag: Le, enableImageDrag: Te4, preventOutline: Me, restoreOutline: ze, getSizedParentNode: Ce, getScale: Ze };
      function S72(t12, e18, i13, n18) {
        if (e18 && "object" == typeof e18) for (var o16 in e18) ke34(t12, o16, e18[o16], i13);
        else for (var s10 = 0, r12 = (e18 = F32(e18)).length; s10 < r12; s10++) ke34(t12, e18[s10], i13, n18);
        return this;
      }
      var E42 = "_leaflet_events";
      function k42(t12, e18, i13, n18) {
        if (1 === arguments.length) Se34(t12), delete t12[E42];
        else if (e18 && "object" == typeof e18) for (var o16 in e18) Oe34(t12, o16, e18[o16], i13);
        else if (e18 = F32(e18), 2 === arguments.length) Se34(t12, function(t13) {
          return -1 !== G32(e18, t13);
        });
        else for (var s10 = 0, r12 = e18.length; s10 < r12; s10++) Oe34(t12, e18[s10], i13, n18);
        return this;
      }
      function Se34(t12, e18) {
        for (var i13 in t12[E42]) {
          var n18 = i13.split(/\d/)[0];
          e18 && !e18(n18) || Oe34(t12, n18, null, null, i13);
        }
      }
      var Ee4 = { mouseenter: "mouseover", mouseleave: "mouseout", wheel: !("onwheel" in window) && "mousewheel" };
      function ke34(e18, t12, i13, n18) {
        var o16, s10, r12 = t12 + h92(i13) + (n18 ? "_" + h92(n18) : "");
        e18[E42] && e18[E42][r12] || (s10 = o16 = function(t13) {
          return i13.call(n18 || e18, t13 || window.event);
        }, !b42.touchNative && b42.pointer && 0 === t12.indexOf("touch") ? o16 = Jt(e18, t12, o16) : b42.touch && "dblclick" === t12 ? o16 = ne(e18, o16) : "addEventListener" in e18 ? "touchstart" === t12 || "touchmove" === t12 || "wheel" === t12 || "mousewheel" === t12 ? e18.addEventListener(Ee4[t12] || t12, o16, !!b42.passiveEvents && { passive: false }) : "mouseenter" === t12 || "mouseleave" === t12 ? e18.addEventListener(Ee4[t12], o16 = function(t13) {
          t13 = t13 || window.event, We(e18, t13) && s10(t13);
        }, false) : e18.addEventListener(t12, s10, false) : e18.attachEvent("on" + t12, o16), e18[E42] = e18[E42] || {}, e18[E42][r12] = o16);
      }
      function Oe34(t12, e18, i13, n18, o16) {
        o16 = o16 || e18 + h92(i13) + (n18 ? "_" + h92(n18) : "");
        var s10, r12, i13 = t12[E42] && t12[E42][o16];
        i13 && (!b42.touchNative && b42.pointer && 0 === e18.indexOf("touch") ? (n18 = t12, r12 = i13, Gt[s10 = e18] ? n18.removeEventListener(Gt[s10], r12, false) : console.warn("wrong event specified:", s10)) : b42.touch && "dblclick" === e18 ? (n18 = i13, (r12 = t12).removeEventListener("dblclick", n18.dblclick), r12.removeEventListener("click", n18.simDblclick)) : "removeEventListener" in t12 ? t12.removeEventListener(Ee4[e18] || e18, i13, false) : t12.detachEvent("on" + e18, i13), t12[E42][o16] = null);
      }
      function Ae(t12) {
        return t12.stopPropagation ? t12.stopPropagation() : t12.originalEvent ? t12.originalEvent._stopped = true : t12.cancelBubble = true, this;
      }
      function Be(t12) {
        return ke34(t12, "wheel", Ae), this;
      }
      function Ie(t12) {
        return S72(t12, "mousedown touchstart dblclick contextmenu", Ae), t12._leaflet_disable_click = true, this;
      }
      function O32(t12) {
        return t12.preventDefault ? t12.preventDefault() : t12.returnValue = false, this;
      }
      function Re32(t12) {
        return O32(t12), Ae(t12), this;
      }
      function Ne(t12) {
        if (t12.composedPath) return t12.composedPath();
        for (var e18 = [], i13 = t12.target; i13; ) e18.push(i13), i13 = i13.parentNode;
        return e18;
      }
      function De(t12, e18) {
        var i13, n18;
        return e18 ? (n18 = (i13 = Ze(e18)).boundingClientRect, new p42((t12.clientX - n18.left) / i13.x - e18.clientLeft, (t12.clientY - n18.top) / i13.y - e18.clientTop)) : new p42(t12.clientX, t12.clientY);
      }
      var je = b42.linux && b42.chrome ? window.devicePixelRatio : b42.mac ? 3 * window.devicePixelRatio : 0 < window.devicePixelRatio ? 2 * window.devicePixelRatio : 1;
      function He(t12) {
        return b42.edge ? t12.wheelDeltaY / 2 : t12.deltaY && 0 === t12.deltaMode ? -t12.deltaY / je : t12.deltaY && 1 === t12.deltaMode ? 20 * -t12.deltaY : t12.deltaY && 2 === t12.deltaMode ? 60 * -t12.deltaY : t12.deltaX || t12.deltaZ ? 0 : t12.wheelDelta ? (t12.wheelDeltaY || t12.wheelDelta) / 2 : t12.detail && Math.abs(t12.detail) < 32765 ? 20 * -t12.detail : t12.detail ? t12.detail / -32765 * 60 : 0;
      }
      function We(t12, e18) {
        var i13 = e18.relatedTarget;
        if (!i13) return true;
        try {
          for (; i13 && i13 !== t12; ) i13 = i13.parentNode;
        } catch (t13) {
          return false;
        }
        return i13 !== t12;
      }
      var mt2 = { __proto__: null, on: S72, off: k42, stopPropagation: Ae, disableScrollPropagation: Be, disableClickPropagation: Ie, preventDefault: O32, stop: Re32, getPropagationPath: Ne, getMousePosition: De, getWheelDelta: He, isExternalTarget: We, addListener: S72, removeListener: k42 }, Fe = it.extend({ run: function(t12, e18, i13, n18) {
        this.stop(), this._el = t12, this._inProgress = true, this._duration = i13 || 0.25, this._easeOutPower = 1 / Math.max(n18 || 0.5, 0.2), this._startPos = Pe(t12), this._offset = e18.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
      }, stop: function() {
        this._inProgress && (this._step(true), this._complete());
      }, _animate: function() {
        this._animId = x52(this._animate, this), this._step();
      }, _step: function(t12) {
        var e18 = +/* @__PURE__ */ new Date() - this._startTime, i13 = 1e3 * this._duration;
        e18 < i13 ? this._runFrame(this._easeOut(e18 / i13), t12) : (this._runFrame(1), this._complete());
      }, _runFrame: function(t12, e18) {
        t12 = this._startPos.add(this._offset.multiplyBy(t12));
        e18 && t12._round(), Z42(this._el, t12), this.fire("step");
      }, _complete: function() {
        r112(this._animId), this._inProgress = false, this.fire("end");
      }, _easeOut: function(t12) {
        return 1 - Math.pow(1 - t12, this._easeOutPower);
      } }), A2 = it.extend({ options: { crs: lt32, center: void 0, zoom: void 0, minZoom: void 0, maxZoom: void 0, layers: [], maxBounds: void 0, renderer: void 0, zoomAnimation: true, zoomAnimationThreshold: 4, fadeAnimation: true, markerZoomAnimation: true, transform3DLimit: 8388608, zoomSnap: 1, zoomDelta: 1, trackResize: true }, initialize: function(t12, e18) {
        e18 = c92(this, e18), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = true, this._initContainer(t12), this._initLayout(), this._onResize = a72(this._onResize, this), this._initEvents(), e18.maxBounds && this.setMaxBounds(e18.maxBounds), void 0 !== e18.zoom && (this._zoom = this._limitZoom(e18.zoom)), e18.center && void 0 !== e18.zoom && this.setView(w42(e18.center), e18.zoom, { reset: true }), this.callInitHooks(), this._zoomAnimated = ce && b42.any3d && !b42.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), S72(this._proxy, de, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
      }, setView: function(t12, e18, i13) {
        if ((e18 = void 0 === e18 ? this._zoom : this._limitZoom(e18), t12 = this._limitCenter(w42(t12), e18, this.options.maxBounds), i13 = i13 || {}, this._stop(), this._loaded && !i13.reset && true !== i13) && (void 0 !== i13.animate && (i13.zoom = l11({ animate: i13.animate }, i13.zoom), i13.pan = l11({ animate: i13.animate, duration: i13.duration }, i13.pan)), this._zoom !== e18 ? this._tryAnimatedZoom && this._tryAnimatedZoom(t12, e18, i13.zoom) : this._tryAnimatedPan(t12, i13.pan))) return clearTimeout(this._sizeTimer), this;
        return this._resetView(t12, e18, i13.pan && i13.pan.noMoveStart), this;
      }, setZoom: function(t12, e18) {
        return this._loaded ? this.setView(this.getCenter(), t12, { zoom: e18 }) : (this._zoom = t12, this);
      }, zoomIn: function(t12, e18) {
        return t12 = t12 || (b42.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t12, e18);
      }, zoomOut: function(t12, e18) {
        return t12 = t12 || (b42.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t12, e18);
      }, setZoomAround: function(t12, e18, i13) {
        var n18 = this.getZoomScale(e18), o16 = this.getSize().divideBy(2), t12 = (t12 instanceof p42 ? t12 : this.latLngToContainerPoint(t12)).subtract(o16).multiplyBy(1 - 1 / n18), n18 = this.containerPointToLatLng(o16.add(t12));
        return this.setView(n18, e18, { zoom: i13 });
      }, _getBoundsCenterZoom: function(t12, e18) {
        e18 = e18 || {}, t12 = t12.getBounds ? t12.getBounds() : g42(t12);
        var i13 = m42(e18.paddingTopLeft || e18.padding || [0, 0]), n18 = m42(e18.paddingBottomRight || e18.padding || [0, 0]), o16 = this.getBoundsZoom(t12, false, i13.add(n18));
        return (o16 = "number" == typeof e18.maxZoom ? Math.min(e18.maxZoom, o16) : o16) === 1 / 0 ? { center: t12.getCenter(), zoom: o16 } : (e18 = n18.subtract(i13).divideBy(2), n18 = this.project(t12.getSouthWest(), o16), i13 = this.project(t12.getNorthEast(), o16), { center: this.unproject(n18.add(i13).divideBy(2).add(e18), o16), zoom: o16 });
      }, fitBounds: function(t12, e18) {
        if ((t12 = g42(t12)).isValid()) return t12 = this._getBoundsCenterZoom(t12, e18), this.setView(t12.center, t12.zoom, e18);
        throw new Error("Bounds are not valid.");
      }, fitWorld: function(t12) {
        return this.fitBounds([[-90, -180], [90, 180]], t12);
      }, panTo: function(t12, e18) {
        return this.setView(t12, this._zoom, { pan: e18 });
      }, panBy: function(t12, e18) {
        var i13;
        return e18 = e18 || {}, (t12 = m42(t12).round()).x || t12.y ? (true === e18.animate || this.getSize().contains(t12) ? (this._panAnim || (this._panAnim = new Fe(), this._panAnim.on({ step: this._onPanTransitionStep, end: this._onPanTransitionEnd }, this)), e18.noMoveStart || this.fire("movestart"), false !== e18.animate ? (M42(this._mapPane, "leaflet-pan-anim"), i13 = this._getMapPanePos().subtract(t12).round(), this._panAnim.run(this._mapPane, i13, e18.duration || 0.25, e18.easeLinearity)) : (this._rawPanBy(t12), this.fire("move").fire("moveend"))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t12)), this.getZoom()), this) : this.fire("moveend");
      }, flyTo: function(n18, o16, t12) {
        if (false === (t12 = t12 || {}).animate || !b42.any3d) return this.setView(n18, o16, t12);
        this._stop();
        var s10 = this.project(this.getCenter()), r12 = this.project(n18), e18 = this.getSize(), a8 = this._zoom, h10 = (n18 = w42(n18), o16 = void 0 === o16 ? a8 : o16, Math.max(e18.x, e18.y)), i13 = h10 * this.getZoomScale(a8, o16), l12 = r12.distanceTo(s10) || 1, u72 = 1.42, c10 = u72 * u72;
        function d62(t13) {
          t13 = (i13 * i13 - h10 * h10 + (t13 ? -1 : 1) * c10 * c10 * l12 * l12) / (2 * (t13 ? i13 : h10) * c10 * l12), t13 = Math.sqrt(t13 * t13 + 1) - t13;
          return t13 < 1e-9 ? -18 : Math.log(t13);
        }
        function _52(t13) {
          return (Math.exp(t13) - Math.exp(-t13)) / 2;
        }
        function p52(t13) {
          return (Math.exp(t13) + Math.exp(-t13)) / 2;
        }
        var m52 = d62(0);
        function f92(t13) {
          return h10 * (p52(m52) * (_52(t13 = m52 + u72 * t13) / p52(t13)) - _52(m52)) / c10;
        }
        var g52 = Date.now(), v52 = (d62(1) - m52) / u72, y52 = t12.duration ? 1e3 * t12.duration : 1e3 * v52 * 0.8;
        return this._moveStart(true, t12.noMoveStart), function t13() {
          var e19 = (Date.now() - g52) / y52, i14 = (1 - Math.pow(1 - e19, 1.5)) * v52;
          e19 <= 1 ? (this._flyToFrame = x52(t13, this), this._move(this.unproject(s10.add(r12.subtract(s10).multiplyBy(f92(i14) / l12)), a8), this.getScaleZoom(h10 / (e19 = i14, h10 * (p52(m52) / p52(m52 + u72 * e19))), a8), { flyTo: true })) : this._move(n18, o16)._moveEnd(true);
        }.call(this), this;
      }, flyToBounds: function(t12, e18) {
        t12 = this._getBoundsCenterZoom(t12, e18);
        return this.flyTo(t12.center, t12.zoom, e18);
      }, setMaxBounds: function(t12) {
        return t12 = g42(t12), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), t12.isValid() ? (this.options.maxBounds = t12, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
      }, setMinZoom: function(t12) {
        var e18 = this.options.minZoom;
        return this.options.minZoom = t12, this._loaded && e18 !== t12 && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t12) : this;
      }, setMaxZoom: function(t12) {
        var e18 = this.options.maxZoom;
        return this.options.maxZoom = t12, this._loaded && e18 !== t12 && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t12) : this;
      }, panInsideBounds: function(t12, e18) {
        this._enforcingBounds = true;
        var i13 = this.getCenter(), t12 = this._limitCenter(i13, this._zoom, g42(t12));
        return i13.equals(t12) || this.panTo(t12, e18), this._enforcingBounds = false, this;
      }, panInside: function(t12, e18) {
        var i13 = m42((e18 = e18 || {}).paddingTopLeft || e18.padding || [0, 0]), n18 = m42(e18.paddingBottomRight || e18.padding || [0, 0]), o16 = this.project(this.getCenter()), t12 = this.project(t12), s10 = this.getPixelBounds(), i13 = _42([s10.min.add(i13), s10.max.subtract(n18)]), s10 = i13.getSize();
        return i13.contains(t12) || (this._enforcingBounds = true, n18 = t12.subtract(i13.getCenter()), i13 = i13.extend(t12).getSize().subtract(s10), o16.x += n18.x < 0 ? -i13.x : i13.x, o16.y += n18.y < 0 ? -i13.y : i13.y, this.panTo(this.unproject(o16), e18), this._enforcingBounds = false), this;
      }, invalidateSize: function(t12) {
        if (!this._loaded) return this;
        t12 = l11({ animate: false, pan: true }, true === t12 ? { animate: true } : t12);
        var e18 = this.getSize(), i13 = (this._sizeChanged = true, this._lastCenter = null, this.getSize()), n18 = e18.divideBy(2).round(), o16 = i13.divideBy(2).round(), n18 = n18.subtract(o16);
        return n18.x || n18.y ? (t12.animate && t12.pan ? this.panBy(n18) : (t12.pan && this._rawPanBy(n18), this.fire("move"), t12.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(a72(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", { oldSize: e18, newSize: i13 })) : this;
      }, stop: function() {
        return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
      }, locate: function(t12) {
        var e18, i13;
        return t12 = this._locateOptions = l11({ timeout: 1e4, watch: false }, t12), "geolocation" in navigator ? (e18 = a72(this._handleGeolocationResponse, this), i13 = a72(this._handleGeolocationError, this), t12.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e18, i13, t12) : navigator.geolocation.getCurrentPosition(e18, i13, t12)) : this._handleGeolocationError({ code: 0, message: "Geolocation not supported." }), this;
      }, stopLocate: function() {
        return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = false), this;
      }, _handleGeolocationError: function(t12) {
        var e18;
        this._container._leaflet_id && (e18 = t12.code, t12 = t12.message || (1 === e18 ? "permission denied" : 2 === e18 ? "position unavailable" : "timeout"), this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", { code: e18, message: "Geolocation error: " + t12 + "." }));
      }, _handleGeolocationResponse: function(t12) {
        if (this._container._leaflet_id) {
          var e18, i13, n18 = new v42(t12.coords.latitude, t12.coords.longitude), o16 = n18.toBounds(2 * t12.coords.accuracy), s10 = this._locateOptions, r12 = (s10.setView && (e18 = this.getBoundsZoom(o16), this.setView(n18, s10.maxZoom ? Math.min(e18, s10.maxZoom) : e18)), { latlng: n18, bounds: o16, timestamp: t12.timestamp });
          for (i13 in t12.coords) "number" == typeof t12.coords[i13] && (r12[i13] = t12.coords[i13]);
          this.fire("locationfound", r12);
        }
      }, addHandler: function(t12, e18) {
        return e18 && (e18 = this[t12] = new e18(this), this._handlers.push(e18), this.options[t12] && e18.enable()), this;
      }, remove: function() {
        if (this._initEvents(true), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance");
        try {
          delete this._container._leaflet_id, delete this._containerId;
        } catch (t13) {
          this._container._leaflet_id = void 0, this._containerId = void 0;
        }
        for (var t12 in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), T42(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (r112(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers) this._layers[t12].remove();
        for (t12 in this._panes) T42(this._panes[t12]);
        return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
      }, createPane: function(t12, e18) {
        e18 = P42("div", "leaflet-pane" + (t12 ? " leaflet-" + t12.replace("Pane", "") + "-pane" : ""), e18 || this._mapPane);
        return t12 && (this._panes[t12] = e18), e18;
      }, getCenter: function() {
        return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
      }, getZoom: function() {
        return this._zoom;
      }, getBounds: function() {
        var t12 = this.getPixelBounds();
        return new s9(this.unproject(t12.getBottomLeft()), this.unproject(t12.getTopRight()));
      }, getMinZoom: function() {
        return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom;
      }, getMaxZoom: function() {
        return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
      }, getBoundsZoom: function(t12, e18, i13) {
        t12 = g42(t12), i13 = m42(i13 || [0, 0]);
        var n18 = this.getZoom() || 0, o16 = this.getMinZoom(), s10 = this.getMaxZoom(), r12 = t12.getNorthWest(), t12 = t12.getSouthEast(), i13 = this.getSize().subtract(i13), t12 = _42(this.project(t12, n18), this.project(r12, n18)).getSize(), r12 = b42.any3d ? this.options.zoomSnap : 1, a8 = i13.x / t12.x, i13 = i13.y / t12.y, t12 = e18 ? Math.max(a8, i13) : Math.min(a8, i13), n18 = this.getScaleZoom(t12, n18);
        return r12 && (n18 = Math.round(n18 / (r12 / 100)) * (r12 / 100), n18 = e18 ? Math.ceil(n18 / r12) * r12 : Math.floor(n18 / r12) * r12), Math.max(o16, Math.min(s10, n18));
      }, getSize: function() {
        return this._size && !this._sizeChanged || (this._size = new p42(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = false), this._size.clone();
      }, getPixelBounds: function(t12, e18) {
        t12 = this._getTopLeftPoint(t12, e18);
        return new f82(t12, t12.add(this.getSize()));
      }, getPixelOrigin: function() {
        return this._checkIfLoaded(), this._pixelOrigin;
      }, getPixelWorldBounds: function(t12) {
        return this.options.crs.getProjectedBounds(void 0 === t12 ? this.getZoom() : t12);
      }, getPane: function(t12) {
        return "string" == typeof t12 ? this._panes[t12] : t12;
      }, getPanes: function() {
        return this._panes;
      }, getContainer: function() {
        return this._container;
      }, getZoomScale: function(t12, e18) {
        var i13 = this.options.crs;
        return e18 = void 0 === e18 ? this._zoom : e18, i13.scale(t12) / i13.scale(e18);
      }, getScaleZoom: function(t12, e18) {
        var i13 = this.options.crs, t12 = (e18 = void 0 === e18 ? this._zoom : e18, i13.zoom(t12 * i13.scale(e18)));
        return isNaN(t12) ? 1 / 0 : t12;
      }, project: function(t12, e18) {
        return e18 = void 0 === e18 ? this._zoom : e18, this.options.crs.latLngToPoint(w42(t12), e18);
      }, unproject: function(t12, e18) {
        return e18 = void 0 === e18 ? this._zoom : e18, this.options.crs.pointToLatLng(m42(t12), e18);
      }, layerPointToLatLng: function(t12) {
        t12 = m42(t12).add(this.getPixelOrigin());
        return this.unproject(t12);
      }, latLngToLayerPoint: function(t12) {
        return this.project(w42(t12))._round()._subtract(this.getPixelOrigin());
      }, wrapLatLng: function(t12) {
        return this.options.crs.wrapLatLng(w42(t12));
      }, wrapLatLngBounds: function(t12) {
        return this.options.crs.wrapLatLngBounds(g42(t12));
      }, distance: function(t12, e18) {
        return this.options.crs.distance(w42(t12), w42(e18));
      }, containerPointToLayerPoint: function(t12) {
        return m42(t12).subtract(this._getMapPanePos());
      }, layerPointToContainerPoint: function(t12) {
        return m42(t12).add(this._getMapPanePos());
      }, containerPointToLatLng: function(t12) {
        t12 = this.containerPointToLayerPoint(m42(t12));
        return this.layerPointToLatLng(t12);
      }, latLngToContainerPoint: function(t12) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(w42(t12)));
      }, mouseEventToContainerPoint: function(t12) {
        return De(t12, this._container);
      }, mouseEventToLayerPoint: function(t12) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t12));
      }, mouseEventToLatLng: function(t12) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(t12));
      }, _initContainer: function(t12) {
        t12 = this._container = _e(t12);
        if (!t12) throw new Error("Map container not found.");
        if (t12._leaflet_id) throw new Error("Map container is already initialized.");
        S72(t12, "scroll", this._onScroll, this), this._containerId = h92(t12);
      }, _initLayout: function() {
        var t12 = this._container, e18 = (this._fadeAnimated = this.options.fadeAnimation && b42.any3d, M42(t12, "leaflet-container" + (b42.touch ? " leaflet-touch" : "") + (b42.retina ? " leaflet-retina" : "") + (b42.ielt9 ? " leaflet-oldie" : "") + (b42.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : "")), pe(t12, "position"));
        "absolute" !== e18 && "relative" !== e18 && "fixed" !== e18 && "sticky" !== e18 && (t12.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
      }, _initPanes: function() {
        var t12 = this._panes = {};
        this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Z42(this._mapPane, new p42(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (M42(t12.markerPane, "leaflet-zoom-hide"), M42(t12.shadowPane, "leaflet-zoom-hide"));
      }, _resetView: function(t12, e18, i13) {
        Z42(this._mapPane, new p42(0, 0));
        var n18 = !this._loaded, o16 = (this._loaded = true, e18 = this._limitZoom(e18), this.fire("viewprereset"), this._zoom !== e18);
        this._moveStart(o16, i13)._move(t12, e18)._moveEnd(o16), this.fire("viewreset"), n18 && this.fire("load");
      }, _moveStart: function(t12, e18) {
        return t12 && this.fire("zoomstart"), e18 || this.fire("movestart"), this;
      }, _move: function(t12, e18, i13, n18) {
        void 0 === e18 && (e18 = this._zoom);
        var o16 = this._zoom !== e18;
        return this._zoom = e18, this._lastCenter = t12, this._pixelOrigin = this._getNewPixelOrigin(t12), n18 ? i13 && i13.pinch && this.fire("zoom", i13) : ((o16 || i13 && i13.pinch) && this.fire("zoom", i13), this.fire("move", i13)), this;
      }, _moveEnd: function(t12) {
        return t12 && this.fire("zoomend"), this.fire("moveend");
      }, _stop: function() {
        return r112(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
      }, _rawPanBy: function(t12) {
        Z42(this._mapPane, this._getMapPanePos().subtract(t12));
      }, _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      }, _panInsideMaxBounds: function() {
        this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
      }, _checkIfLoaded: function() {
        if (!this._loaded) throw new Error("Set map center and zoom first.");
      }, _initEvents: function(t12) {
        this._targets = {};
        var e18 = t12 ? k42 : S72;
        e18((this._targets[h92(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && e18(window, "resize", this._onResize, this), b42.any3d && this.options.transform3DLimit && (t12 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
      }, _onResize: function() {
        r112(this._resizeRequest), this._resizeRequest = x52(function() {
          this.invalidateSize({ debounceMoveend: true });
        }, this);
      }, _onScroll: function() {
        this._container.scrollTop = 0, this._container.scrollLeft = 0;
      }, _onMoveEnd: function() {
        var t12 = this._getMapPanePos();
        Math.max(Math.abs(t12.x), Math.abs(t12.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
      }, _findEventTargets: function(t12, e18) {
        for (var i13, n18 = [], o16 = "mouseout" === e18 || "mouseover" === e18, s10 = t12.target || t12.srcElement, r12 = false; s10; ) {
          if ((i13 = this._targets[h92(s10)]) && ("click" === e18 || "preclick" === e18) && this._draggableMoved(i13)) {
            r12 = true;
            break;
          }
          if (i13 && i13.listens(e18, true)) {
            if (o16 && !We(s10, t12)) break;
            if (n18.push(i13), o16) break;
          }
          if (s10 === this._container) break;
          s10 = s10.parentNode;
        }
        return n18 = n18.length || r12 || o16 || !this.listens(e18, true) ? n18 : [this];
      }, _isClickDisabled: function(t12) {
        for (; t12 && t12 !== this._container; ) {
          if (t12._leaflet_disable_click) return true;
          t12 = t12.parentNode;
        }
      }, _handleDOMEvent: function(t12) {
        var e18, i13 = t12.target || t12.srcElement;
        !this._loaded || i13._leaflet_disable_events || "click" === t12.type && this._isClickDisabled(i13) || ("mousedown" === (e18 = t12.type) && Me(i13), this._fireDOMEvent(t12, e18));
      }, _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"], _fireDOMEvent: function(t12, e18, i13) {
        "click" === t12.type && ((a8 = l11({}, t12)).type = "preclick", this._fireDOMEvent(a8, a8.type, i13));
        var n18 = this._findEventTargets(t12, e18);
        if (i13) {
          for (var o16 = [], s10 = 0; s10 < i13.length; s10++) i13[s10].listens(e18, true) && o16.push(i13[s10]);
          n18 = o16.concat(n18);
        }
        if (n18.length) {
          "contextmenu" === e18 && O32(t12);
          var r12, a8 = n18[0], h10 = { originalEvent: t12 };
          for ("keypress" !== t12.type && "keydown" !== t12.type && "keyup" !== t12.type && (r12 = a8.getLatLng && (!a8._radius || a8._radius <= 10), h10.containerPoint = r12 ? this.latLngToContainerPoint(a8.getLatLng()) : this.mouseEventToContainerPoint(t12), h10.layerPoint = this.containerPointToLayerPoint(h10.containerPoint), h10.latlng = r12 ? a8.getLatLng() : this.layerPointToLatLng(h10.layerPoint)), s10 = 0; s10 < n18.length; s10++) if (n18[s10].fire(e18, h10, true), h10.originalEvent._stopped || false === n18[s10].options.bubblingMouseEvents && -1 !== G32(this._mouseEvents, e18)) return;
        }
      }, _draggableMoved: function(t12) {
        return (t12 = t12.dragging && t12.dragging.enabled() ? t12 : this).dragging && t12.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      }, _clearHandlers: function() {
        for (var t12 = 0, e18 = this._handlers.length; t12 < e18; t12++) this._handlers[t12].disable();
      }, whenReady: function(t12, e18) {
        return this._loaded ? t12.call(e18 || this, { target: this }) : this.on("load", t12, e18), this;
      }, _getMapPanePos: function() {
        return Pe(this._mapPane) || new p42(0, 0);
      }, _moved: function() {
        var t12 = this._getMapPanePos();
        return t12 && !t12.equals([0, 0]);
      }, _getTopLeftPoint: function(t12, e18) {
        return (t12 && void 0 !== e18 ? this._getNewPixelOrigin(t12, e18) : this.getPixelOrigin()).subtract(this._getMapPanePos());
      }, _getNewPixelOrigin: function(t12, e18) {
        var i13 = this.getSize()._divideBy(2);
        return this.project(t12, e18)._subtract(i13)._add(this._getMapPanePos())._round();
      }, _latLngToNewLayerPoint: function(t12, e18, i13) {
        i13 = this._getNewPixelOrigin(i13, e18);
        return this.project(t12, e18)._subtract(i13);
      }, _latLngBoundsToNewLayerBounds: function(t12, e18, i13) {
        i13 = this._getNewPixelOrigin(i13, e18);
        return _42([this.project(t12.getSouthWest(), e18)._subtract(i13), this.project(t12.getNorthWest(), e18)._subtract(i13), this.project(t12.getSouthEast(), e18)._subtract(i13), this.project(t12.getNorthEast(), e18)._subtract(i13)]);
      }, _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      }, _getCenterOffset: function(t12) {
        return this.latLngToLayerPoint(t12).subtract(this._getCenterLayerPoint());
      }, _limitCenter: function(t12, e18, i13) {
        var n18, o16;
        return !i13 || (n18 = this.project(t12, e18), o16 = this.getSize().divideBy(2), o16 = new f82(n18.subtract(o16), n18.add(o16)), o16 = this._getBoundsOffset(o16, i13, e18), Math.abs(o16.x) <= 1 && Math.abs(o16.y) <= 1) ? t12 : this.unproject(n18.add(o16), e18);
      }, _limitOffset: function(t12, e18) {
        var i13;
        return e18 ? (i13 = new f82((i13 = this.getPixelBounds()).min.add(t12), i13.max.add(t12)), t12.add(this._getBoundsOffset(i13, e18))) : t12;
      }, _getBoundsOffset: function(t12, e18, i13) {
        e18 = _42(this.project(e18.getNorthEast(), i13), this.project(e18.getSouthWest(), i13)), i13 = e18.min.subtract(t12.min), e18 = e18.max.subtract(t12.max);
        return new p42(this._rebound(i13.x, -e18.x), this._rebound(i13.y, -e18.y));
      }, _rebound: function(t12, e18) {
        return 0 < t12 + e18 ? Math.round(t12 - e18) / 2 : Math.max(0, Math.ceil(t12)) - Math.max(0, Math.floor(e18));
      }, _limitZoom: function(t12) {
        var e18 = this.getMinZoom(), i13 = this.getMaxZoom(), n18 = b42.any3d ? this.options.zoomSnap : 1;
        return n18 && (t12 = Math.round(t12 / n18) * n18), Math.max(e18, Math.min(i13, t12));
      }, _onPanTransitionStep: function() {
        this.fire("move");
      }, _onPanTransitionEnd: function() {
        z42(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
      }, _tryAnimatedPan: function(t12, e18) {
        t12 = this._getCenterOffset(t12)._trunc();
        return !(true !== (e18 && e18.animate) && !this.getSize().contains(t12)) && (this.panBy(t12, e18), true);
      }, _createAnimProxy: function() {
        var t12 = this._proxy = P42("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(t12), this.on("zoomanim", function(t13) {
          var e18 = ue, i13 = this._proxy.style[e18];
          be(this._proxy, this.project(t13.center, t13.zoom), this.getZoomScale(t13.zoom, 1)), i13 === this._proxy.style[e18] && this._animatingZoom && this._onZoomTransitionEnd();
        }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
      }, _destroyAnimProxy: function() {
        T42(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
      }, _animMoveEnd: function() {
        var t12 = this.getCenter(), e18 = this.getZoom();
        be(this._proxy, this.project(t12, e18), this.getZoomScale(e18, 1));
      }, _catchTransitionEnd: function(t12) {
        this._animatingZoom && 0 <= t12.propertyName.indexOf("transform") && this._onZoomTransitionEnd();
      }, _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      }, _tryAnimatedZoom: function(t12, e18, i13) {
        if (!this._animatingZoom) {
          if (i13 = i13 || {}, !this._zoomAnimated || false === i13.animate || this._nothingToAnimate() || Math.abs(e18 - this._zoom) > this.options.zoomAnimationThreshold) return false;
          var n18 = this.getZoomScale(e18), n18 = this._getCenterOffset(t12)._divideBy(1 - 1 / n18);
          if (true !== i13.animate && !this.getSize().contains(n18)) return false;
          x52(function() {
            this._moveStart(true, i13.noMoveStart || false)._animateZoom(t12, e18, true);
          }, this);
        }
        return true;
      }, _animateZoom: function(t12, e18, i13, n18) {
        this._mapPane && (i13 && (this._animatingZoom = true, this._animateToCenter = t12, this._animateToZoom = e18, M42(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", { center: t12, zoom: e18, noUpdate: n18 }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, true), setTimeout(a72(this._onZoomTransitionEnd, this), 250));
      }, _onZoomTransitionEnd: function() {
        this._animatingZoom && (this._mapPane && z42(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = false, this._move(this._animateToCenter, this._animateToZoom, void 0, true), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(true));
      } });
      function Ue(t12) {
        return new B42(t12);
      }
      var B42 = et35.extend({ options: { position: "topright" }, initialize: function(t12) {
        c92(this, t12);
      }, getPosition: function() {
        return this.options.position;
      }, setPosition: function(t12) {
        var e18 = this._map;
        return e18 && e18.removeControl(this), this.options.position = t12, e18 && e18.addControl(this), this;
      }, getContainer: function() {
        return this._container;
      }, addTo: function(t12) {
        this.remove(), this._map = t12;
        var e18 = this._container = this.onAdd(t12), i13 = this.getPosition(), t12 = t12._controlCorners[i13];
        return M42(e18, "leaflet-control"), -1 !== i13.indexOf("bottom") ? t12.insertBefore(e18, t12.firstChild) : t12.appendChild(e18), this._map.on("unload", this.remove, this), this;
      }, remove: function() {
        return this._map && (T42(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null), this;
      }, _refocusOnMap: function(t12) {
        this._map && t12 && 0 < t12.screenX && 0 < t12.screenY && this._map.getContainer().focus();
      } }), Ve = (A2.include({ addControl: function(t12) {
        return t12.addTo(this), this;
      }, removeControl: function(t12) {
        return t12.remove(), this;
      }, _initControlPos: function() {
        var i13 = this._controlCorners = {}, n18 = "leaflet-", o16 = this._controlContainer = P42("div", n18 + "control-container", this._container);
        function t12(t13, e18) {
          i13[t13 + e18] = P42("div", n18 + t13 + " " + n18 + e18, o16);
        }
        t12("top", "left"), t12("top", "right"), t12("bottom", "left"), t12("bottom", "right");
      }, _clearControlPos: function() {
        for (var t12 in this._controlCorners) T42(this._controlCorners[t12]);
        T42(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
      } }), B42.extend({ options: { collapsed: true, position: "topright", autoZIndex: true, hideSingleBase: false, sortLayers: false, sortFunction: function(t12, e18, i13, n18) {
        return i13 < n18 ? -1 : n18 < i13 ? 1 : 0;
      } }, initialize: function(t12, e18, i13) {
        for (var n18 in c92(this, i13), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = false, this._preventClick = false, t12) this._addLayer(t12[n18], n18);
        for (n18 in e18) this._addLayer(e18[n18], n18, true);
      }, onAdd: function(t12) {
        this._initLayout(), this._update(), (this._map = t12).on("zoomend", this._checkDisabledLayers, this);
        for (var e18 = 0; e18 < this._layers.length; e18++) this._layers[e18].layer.on("add remove", this._onLayerChange, this);
        return this._container;
      }, addTo: function(t12) {
        return B42.prototype.addTo.call(this, t12), this._expandIfNotCollapsed();
      }, onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var t12 = 0; t12 < this._layers.length; t12++) this._layers[t12].layer.off("add remove", this._onLayerChange, this);
      }, addBaseLayer: function(t12, e18) {
        return this._addLayer(t12, e18), this._map ? this._update() : this;
      }, addOverlay: function(t12, e18) {
        return this._addLayer(t12, e18, true), this._map ? this._update() : this;
      }, removeLayer: function(t12) {
        t12.off("add remove", this._onLayerChange, this);
        t12 = this._getLayer(h92(t12));
        return t12 && this._layers.splice(this._layers.indexOf(t12), 1), this._map ? this._update() : this;
      }, expand: function() {
        M42(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
        var t12 = this._map.getSize().y - (this._container.offsetTop + 50);
        return t12 < this._section.clientHeight ? (M42(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = t12 + "px") : z42(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
      }, collapse: function() {
        return z42(this._container, "leaflet-control-layers-expanded"), this;
      }, _initLayout: function() {
        var t12 = "leaflet-control-layers", e18 = this._container = P42("div", t12), i13 = this.options.collapsed, n18 = (e18.setAttribute("aria-haspopup", true), Ie(e18), Be(e18), this._section = P42("section", t12 + "-list")), o16 = (i13 && (this._map.on("click", this.collapse, this), S72(e18, { mouseenter: this._expandSafely, mouseleave: this.collapse }, this)), this._layersLink = P42("a", t12 + "-toggle", e18));
        o16.href = "#", o16.title = "Layers", o16.setAttribute("role", "button"), S72(o16, { keydown: function(t13) {
          13 === t13.keyCode && this._expandSafely();
        }, click: function(t13) {
          O32(t13), this._expandSafely();
        } }, this), i13 || this.expand(), this._baseLayersList = P42("div", t12 + "-base", n18), this._separator = P42("div", t12 + "-separator", n18), this._overlaysList = P42("div", t12 + "-overlays", n18), e18.appendChild(n18);
      }, _getLayer: function(t12) {
        for (var e18 = 0; e18 < this._layers.length; e18++) if (this._layers[e18] && h92(this._layers[e18].layer) === t12) return this._layers[e18];
      }, _addLayer: function(t12, e18, i13) {
        this._map && t12.on("add remove", this._onLayerChange, this), this._layers.push({ layer: t12, name: e18, overlay: i13 }), this.options.sortLayers && this._layers.sort(a72(function(t13, e19) {
          return this.options.sortFunction(t13.layer, e19.layer, t13.name, e19.name);
        }, this)), this.options.autoZIndex && t12.setZIndex && (this._lastZIndex++, t12.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
      }, _update: function() {
        if (this._container) {
          me(this._baseLayersList), me(this._overlaysList), this._layerControlInputs = [];
          for (var t12, e18, i13, n18 = 0, o16 = 0; o16 < this._layers.length; o16++) i13 = this._layers[o16], this._addItem(i13), e18 = e18 || i13.overlay, t12 = t12 || !i13.overlay, n18 += i13.overlay ? 0 : 1;
          this.options.hideSingleBase && (this._baseLayersList.style.display = (t12 = t12 && 1 < n18) ? "" : "none"), this._separator.style.display = e18 && t12 ? "" : "none";
        }
        return this;
      }, _onLayerChange: function(t12) {
        this._handlingClick || this._update();
        var e18 = this._getLayer(h92(t12.target)), t12 = e18.overlay ? "add" === t12.type ? "overlayadd" : "overlayremove" : "add" === t12.type ? "baselayerchange" : null;
        t12 && this._map.fire(t12, e18);
      }, _createRadioElement: function(t12, e18) {
        t12 = '<input type="radio" class="leaflet-control-layers-selector" name="' + t12 + '"' + (e18 ? ' checked="checked"' : "") + "/>", e18 = document.createElement("div");
        return e18.innerHTML = t12, e18.firstChild;
      }, _addItem: function(t12) {
        var e18, i13 = document.createElement("label"), n18 = this._map.hasLayer(t12.layer), n18 = (t12.overlay ? ((e18 = document.createElement("input")).type = "checkbox", e18.className = "leaflet-control-layers-selector", e18.defaultChecked = n18) : e18 = this._createRadioElement("leaflet-base-layers_" + h92(this), n18), this._layerControlInputs.push(e18), e18.layerId = h92(t12.layer), S72(e18, "click", this._onInputClick, this), document.createElement("span")), o16 = (n18.innerHTML = " " + t12.name, document.createElement("span"));
        return i13.appendChild(o16), o16.appendChild(e18), o16.appendChild(n18), (t12.overlay ? this._overlaysList : this._baseLayersList).appendChild(i13), this._checkDisabledLayers(), i13;
      }, _onInputClick: function() {
        if (!this._preventClick) {
          var t12, e18, i13 = this._layerControlInputs, n18 = [], o16 = [];
          this._handlingClick = true;
          for (var s10 = i13.length - 1; 0 <= s10; s10--) t12 = i13[s10], e18 = this._getLayer(t12.layerId).layer, t12.checked ? n18.push(e18) : t12.checked || o16.push(e18);
          for (s10 = 0; s10 < o16.length; s10++) this._map.hasLayer(o16[s10]) && this._map.removeLayer(o16[s10]);
          for (s10 = 0; s10 < n18.length; s10++) this._map.hasLayer(n18[s10]) || this._map.addLayer(n18[s10]);
          this._handlingClick = false, this._refocusOnMap();
        }
      }, _checkDisabledLayers: function() {
        for (var t12, e18, i13 = this._layerControlInputs, n18 = this._map.getZoom(), o16 = i13.length - 1; 0 <= o16; o16--) t12 = i13[o16], e18 = this._getLayer(t12.layerId).layer, t12.disabled = void 0 !== e18.options.minZoom && n18 < e18.options.minZoom || void 0 !== e18.options.maxZoom && n18 > e18.options.maxZoom;
      }, _expandIfNotCollapsed: function() {
        return this._map && !this.options.collapsed && this.expand(), this;
      }, _expandSafely: function() {
        var t12 = this._section, e18 = (this._preventClick = true, S72(t12, "click", O32), this.expand(), this);
        setTimeout(function() {
          k42(t12, "click", O32), e18._preventClick = false;
        });
      } })), qe = B42.extend({ options: { position: "topleft", zoomInText: '<span aria-hidden="true">+</span>', zoomInTitle: "Zoom in", zoomOutText: '<span aria-hidden="true">&#x2212;</span>', zoomOutTitle: "Zoom out" }, onAdd: function(t12) {
        var e18 = "leaflet-control-zoom", i13 = P42("div", e18 + " leaflet-bar"), n18 = this.options;
        return this._zoomInButton = this._createButton(n18.zoomInText, n18.zoomInTitle, e18 + "-in", i13, this._zoomIn), this._zoomOutButton = this._createButton(n18.zoomOutText, n18.zoomOutTitle, e18 + "-out", i13, this._zoomOut), this._updateDisabled(), t12.on("zoomend zoomlevelschange", this._updateDisabled, this), i13;
      }, onRemove: function(t12) {
        t12.off("zoomend zoomlevelschange", this._updateDisabled, this);
      }, disable: function() {
        return this._disabled = true, this._updateDisabled(), this;
      }, enable: function() {
        return this._disabled = false, this._updateDisabled(), this;
      }, _zoomIn: function(t12) {
        !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t12.shiftKey ? 3 : 1));
      }, _zoomOut: function(t12) {
        !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t12.shiftKey ? 3 : 1));
      }, _createButton: function(t12, e18, i13, n18, o16) {
        i13 = P42("a", i13, n18);
        return i13.innerHTML = t12, i13.href = "#", i13.title = e18, i13.setAttribute("role", "button"), i13.setAttribute("aria-label", e18), Ie(i13), S72(i13, "click", Re32), S72(i13, "click", o16, this), S72(i13, "click", this._refocusOnMap, this), i13;
      }, _updateDisabled: function() {
        var t12 = this._map, e18 = "leaflet-disabled";
        z42(this._zoomInButton, e18), z42(this._zoomOutButton, e18), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), !this._disabled && t12._zoom !== t12.getMinZoom() || (M42(this._zoomOutButton, e18), this._zoomOutButton.setAttribute("aria-disabled", "true")), !this._disabled && t12._zoom !== t12.getMaxZoom() || (M42(this._zoomInButton, e18), this._zoomInButton.setAttribute("aria-disabled", "true"));
      } }), Ge = (A2.mergeOptions({ zoomControl: true }), A2.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new qe(), this.addControl(this.zoomControl));
      }), B42.extend({ options: { position: "bottomleft", maxWidth: 100, metric: true, imperial: true }, onAdd: function(t12) {
        var e18 = "leaflet-control-scale", i13 = P42("div", e18), n18 = this.options;
        return this._addScales(n18, e18 + "-line", i13), t12.on(n18.updateWhenIdle ? "moveend" : "move", this._update, this), t12.whenReady(this._update, this), i13;
      }, onRemove: function(t12) {
        t12.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      }, _addScales: function(t12, e18, i13) {
        t12.metric && (this._mScale = P42("div", e18, i13)), t12.imperial && (this._iScale = P42("div", e18, i13));
      }, _update: function() {
        var t12 = this._map, e18 = t12.getSize().y / 2, t12 = t12.distance(t12.containerPointToLatLng([0, e18]), t12.containerPointToLatLng([this.options.maxWidth, e18]));
        this._updateScales(t12);
      }, _updateScales: function(t12) {
        this.options.metric && t12 && this._updateMetric(t12), this.options.imperial && t12 && this._updateImperial(t12);
      }, _updateMetric: function(t12) {
        var e18 = this._getRoundNum(t12);
        this._updateScale(this._mScale, e18 < 1e3 ? e18 + " m" : e18 / 1e3 + " km", e18 / t12);
      }, _updateImperial: function(t12) {
        var e18, i13, t12 = 3.2808399 * t12;
        5280 < t12 ? (i13 = this._getRoundNum(e18 = t12 / 5280), this._updateScale(this._iScale, i13 + " mi", i13 / e18)) : (i13 = this._getRoundNum(t12), this._updateScale(this._iScale, i13 + " ft", i13 / t12));
      }, _updateScale: function(t12, e18, i13) {
        t12.style.width = Math.round(this.options.maxWidth * i13) + "px", t12.innerHTML = e18;
      }, _getRoundNum: function(t12) {
        var e18 = Math.pow(10, (Math.floor(t12) + "").length - 1), t12 = t12 / e18;
        return e18 * (t12 = 10 <= t12 ? 10 : 5 <= t12 ? 5 : 3 <= t12 ? 3 : 2 <= t12 ? 2 : 1);
      } })), Ke = B42.extend({ options: { position: "bottomright", prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (b42.inlineSvg ? '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ' : "") + "Leaflet</a>" }, initialize: function(t12) {
        c92(this, t12), this._attributions = {};
      }, onAdd: function(t12) {
        for (var e18 in (t12.attributionControl = this)._container = P42("div", "leaflet-control-attribution"), Ie(this._container), t12._layers) t12._layers[e18].getAttribution && this.addAttribution(t12._layers[e18].getAttribution());
        return this._update(), t12.on("layeradd", this._addAttribution, this), this._container;
      }, onRemove: function(t12) {
        t12.off("layeradd", this._addAttribution, this);
      }, _addAttribution: function(t12) {
        t12.layer.getAttribution && (this.addAttribution(t12.layer.getAttribution()), t12.layer.once("remove", function() {
          this.removeAttribution(t12.layer.getAttribution());
        }, this));
      }, setPrefix: function(t12) {
        return this.options.prefix = t12, this._update(), this;
      }, addAttribution: function(t12) {
        return t12 && (this._attributions[t12] || (this._attributions[t12] = 0), this._attributions[t12]++, this._update()), this;
      }, removeAttribution: function(t12) {
        return t12 && this._attributions[t12] && (this._attributions[t12]--, this._update()), this;
      }, _update: function() {
        if (this._map) {
          var t12, e18 = [];
          for (t12 in this._attributions) this._attributions[t12] && e18.push(t12);
          var i13 = [];
          this.options.prefix && i13.push(this.options.prefix), e18.length && i13.push(e18.join(", ")), this._container.innerHTML = i13.join(' <span aria-hidden="true">|</span> ');
        }
      } }), n17 = (A2.mergeOptions({ attributionControl: true }), A2.addInitHook(function() {
        this.options.attributionControl && new Ke().addTo(this);
      }), B42.Layers = Ve, B42.Zoom = qe, B42.Scale = Ge, B42.Attribution = Ke, Ue.layers = function(t12, e18, i13) {
        return new Ve(t12, e18, i13);
      }, Ue.zoom = function(t12) {
        return new qe(t12);
      }, Ue.scale = function(t12) {
        return new Ge(t12);
      }, Ue.attribution = function(t12) {
        return new Ke(t12);
      }, et35.extend({ initialize: function(t12) {
        this._map = t12;
      }, enable: function() {
        return this._enabled || (this._enabled = true, this.addHooks()), this;
      }, disable: function() {
        return this._enabled && (this._enabled = false, this.removeHooks()), this;
      }, enabled: function() {
        return !!this._enabled;
      } })), ft = (n17.addTo = function(t12, e18) {
        return t12.addHandler(e18, this), this;
      }, { Events: e17 }), Ye = b42.touch ? "touchstart mousedown" : "mousedown", Xe = it.extend({ options: { clickTolerance: 3 }, initialize: function(t12, e18, i13, n18) {
        c92(this, n18), this._element = t12, this._dragStartTarget = e18 || t12, this._preventOutline = i13;
      }, enable: function() {
        this._enabled || (S72(this._dragStartTarget, Ye, this._onDown, this), this._enabled = true);
      }, disable: function() {
        this._enabled && (Xe._dragging === this && this.finishDrag(true), k42(this._dragStartTarget, Ye, this._onDown, this), this._enabled = false, this._moved = false);
      }, _onDown: function(t12) {
        var e18, i13;
        this._enabled && (this._moved = false, ve(this._element, "leaflet-zoom-anim") || (t12.touches && 1 !== t12.touches.length ? Xe._dragging === this && this.finishDrag() : Xe._dragging || t12.shiftKey || 1 !== t12.which && 1 !== t12.button && !t12.touches || ((Xe._dragging = this)._preventOutline && Me(this._element), Le(), re(), this._moving || (this.fire("down"), i13 = t12.touches ? t12.touches[0] : t12, e18 = Ce(this._element), this._startPoint = new p42(i13.clientX, i13.clientY), this._startPos = Pe(this._element), this._parentScale = Ze(e18), i13 = "mousedown" === t12.type, S72(document, i13 ? "mousemove" : "touchmove", this._onMove, this), S72(document, i13 ? "mouseup" : "touchend touchcancel", this._onUp, this)))));
      }, _onMove: function(t12) {
        var e18;
        this._enabled && (t12.touches && 1 < t12.touches.length ? this._moved = true : !(e18 = new p42((e18 = t12.touches && 1 === t12.touches.length ? t12.touches[0] : t12).clientX, e18.clientY)._subtract(this._startPoint)).x && !e18.y || Math.abs(e18.x) + Math.abs(e18.y) < this.options.clickTolerance || (e18.x /= this._parentScale.x, e18.y /= this._parentScale.y, O32(t12), this._moved || (this.fire("dragstart"), this._moved = true, M42(document.body, "leaflet-dragging"), this._lastTarget = t12.target || t12.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), M42(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(e18), this._moving = true, this._lastEvent = t12, this._updatePosition()));
      }, _updatePosition: function() {
        var t12 = { originalEvent: this._lastEvent };
        this.fire("predrag", t12), Z42(this._element, this._newPos), this.fire("drag", t12);
      }, _onUp: function() {
        this._enabled && this.finishDrag();
      }, finishDrag: function(t12) {
        z42(document.body, "leaflet-dragging"), this._lastTarget && (z42(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), k42(document, "mousemove touchmove", this._onMove, this), k42(document, "mouseup touchend touchcancel", this._onUp, this), Te4(), ae();
        var e18 = this._moved && this._moving;
        this._moving = false, Xe._dragging = false, e18 && this.fire("dragend", { noInertia: t12, distance: this._newPos.distanceTo(this._startPos) });
      } });
      function Je(t12, e18, i13) {
        for (var n18, o16, s10, r12, a8, h10, l12, u72 = [1, 4, 2, 8], c10 = 0, d62 = t12.length; c10 < d62; c10++) t12[c10]._code = si5(t12[c10], e18);
        for (s10 = 0; s10 < 4; s10++) {
          for (h10 = u72[s10], n18 = [], c10 = 0, o16 = (d62 = t12.length) - 1; c10 < d62; o16 = c10++) r12 = t12[c10], a8 = t12[o16], r12._code & h10 ? a8._code & h10 || ((l12 = oi(a8, r12, h10, e18, i13))._code = si5(l12, e18), n18.push(l12)) : (a8._code & h10 && ((l12 = oi(a8, r12, h10, e18, i13))._code = si5(l12, e18), n18.push(l12)), n18.push(r12));
          t12 = n18;
        }
        return t12;
      }
      function $e4(t12, e18) {
        var i13, n18, o16, s10, r12, a8, h10;
        if (!t12 || 0 === t12.length) throw new Error("latlngs not passed");
        I42(t12) || (console.warn("latlngs are not flat! Only the first ring will be used"), t12 = t12[0]);
        for (var l12 = w42([0, 0]), u72 = g42(t12), c10 = (u72.getNorthWest().distanceTo(u72.getSouthWest()) * u72.getNorthEast().distanceTo(u72.getNorthWest()) < 1700 && (l12 = Qe(t12)), t12.length), d62 = [], _52 = 0; _52 < c10; _52++) {
          var p52 = w42(t12[_52]);
          d62.push(e18.project(w42([p52.lat - l12.lat, p52.lng - l12.lng])));
        }
        for (_52 = r12 = a8 = h10 = 0, i13 = c10 - 1; _52 < c10; i13 = _52++) n18 = d62[_52], o16 = d62[i13], s10 = n18.y * o16.x - o16.y * n18.x, a8 += (n18.x + o16.x) * s10, h10 += (n18.y + o16.y) * s10, r12 += 3 * s10;
        u72 = 0 === r12 ? d62[0] : [a8 / r12, h10 / r12], u72 = e18.unproject(m42(u72));
        return w42([u72.lat + l12.lat, u72.lng + l12.lng]);
      }
      function Qe(t12) {
        for (var e18 = 0, i13 = 0, n18 = 0, o16 = 0; o16 < t12.length; o16++) {
          var s10 = w42(t12[o16]);
          e18 += s10.lat, i13 += s10.lng, n18++;
        }
        return w42([e18 / n18, i13 / n18]);
      }
      var ti, gt2 = { __proto__: null, clipPolygon: Je, polygonCenter: $e4, centroid: Qe };
      function ei(t12, e18) {
        if (e18 && t12.length) {
          var i13 = t12 = function(t13, e19) {
            for (var i14 = [t13[0]], n19 = 1, o17 = 0, s11 = t13.length; n19 < s11; n19++) (function(t14, e20) {
              var i15 = e20.x - t14.x, e20 = e20.y - t14.y;
              return i15 * i15 + e20 * e20;
            })(t13[n19], t13[o17]) > e19 && (i14.push(t13[n19]), o17 = n19);
            o17 < s11 - 1 && i14.push(t13[s11 - 1]);
            return i14;
          }(t12, e18 = e18 * e18), n18 = i13.length, o16 = new (typeof Uint8Array != "undefined" ? Uint8Array : Array)(n18);
          o16[0] = o16[n18 - 1] = 1, function t13(e19, i14, n19, o17, s11) {
            var r13, a8, h10, l12 = 0;
            for (a8 = o17 + 1; a8 <= s11 - 1; a8++) h10 = ri(e19[a8], e19[o17], e19[s11], true), l12 < h10 && (r13 = a8, l12 = h10);
            n19 < l12 && (i14[r13] = 1, t13(e19, i14, n19, o17, r13), t13(e19, i14, n19, r13, s11));
          }(i13, o16, e18, 0, n18 - 1);
          var s10, r12 = [];
          for (s10 = 0; s10 < n18; s10++) o16[s10] && r12.push(i13[s10]);
          return r12;
        }
        return t12.slice();
      }
      function ii2(t12, e18, i13) {
        return Math.sqrt(ri(t12, e18, i13, true));
      }
      function ni(t12, e18, i13, n18, o16) {
        var s10, r12, a8, h10 = n18 ? ti : si5(t12, i13), l12 = si5(e18, i13);
        for (ti = l12; ; ) {
          if (!(h10 | l12)) return [t12, e18];
          if (h10 & l12) return false;
          a8 = si5(r12 = oi(t12, e18, s10 = h10 || l12, i13, o16), i13), s10 === h10 ? (t12 = r12, h10 = a8) : (e18 = r12, l12 = a8);
        }
      }
      function oi(t12, e18, i13, n18, o16) {
        var s10, r12, a8 = e18.x - t12.x, e18 = e18.y - t12.y, h10 = n18.min, n18 = n18.max;
        return 8 & i13 ? (s10 = t12.x + a8 * (n18.y - t12.y) / e18, r12 = n18.y) : 4 & i13 ? (s10 = t12.x + a8 * (h10.y - t12.y) / e18, r12 = h10.y) : 2 & i13 ? (s10 = n18.x, r12 = t12.y + e18 * (n18.x - t12.x) / a8) : 1 & i13 && (s10 = h10.x, r12 = t12.y + e18 * (h10.x - t12.x) / a8), new p42(s10, r12, o16);
      }
      function si5(t12, e18) {
        var i13 = 0;
        return t12.x < e18.min.x ? i13 |= 1 : t12.x > e18.max.x && (i13 |= 2), t12.y < e18.min.y ? i13 |= 4 : t12.y > e18.max.y && (i13 |= 8), i13;
      }
      function ri(t12, e18, i13, n18) {
        var o16 = e18.x, e18 = e18.y, s10 = i13.x - o16, r12 = i13.y - e18, a8 = s10 * s10 + r12 * r12;
        return 0 < a8 && (1 < (a8 = ((t12.x - o16) * s10 + (t12.y - e18) * r12) / a8) ? (o16 = i13.x, e18 = i13.y) : 0 < a8 && (o16 += s10 * a8, e18 += r12 * a8)), s10 = t12.x - o16, r12 = t12.y - e18, n18 ? s10 * s10 + r12 * r12 : new p42(o16, e18);
      }
      function I42(t12) {
        return !d52(t12[0]) || "object" != typeof t12[0][0] && void 0 !== t12[0][0];
      }
      function ai(t12) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), I42(t12);
      }
      function hi(t12, e18) {
        var i13, n18, o16, s10, r12, a8;
        if (!t12 || 0 === t12.length) throw new Error("latlngs not passed");
        I42(t12) || (console.warn("latlngs are not flat! Only the first ring will be used"), t12 = t12[0]);
        for (var h10 = w42([0, 0]), l12 = g42(t12), u72 = (l12.getNorthWest().distanceTo(l12.getSouthWest()) * l12.getNorthEast().distanceTo(l12.getNorthWest()) < 1700 && (h10 = Qe(t12)), t12.length), c10 = [], d62 = 0; d62 < u72; d62++) {
          var _52 = w42(t12[d62]);
          c10.push(e18.project(w42([_52.lat - h10.lat, _52.lng - h10.lng])));
        }
        for (i13 = d62 = 0; d62 < u72 - 1; d62++) i13 += c10[d62].distanceTo(c10[d62 + 1]) / 2;
        if (0 === i13) a8 = c10[0];
        else for (n18 = d62 = 0; d62 < u72 - 1; d62++) if (o16 = c10[d62], s10 = c10[d62 + 1], i13 < (n18 += r12 = o16.distanceTo(s10))) {
          a8 = [s10.x - (r12 = (n18 - i13) / r12) * (s10.x - o16.x), s10.y - r12 * (s10.y - o16.y)];
          break;
        }
        l12 = e18.unproject(m42(a8));
        return w42([l12.lat + h10.lat, l12.lng + h10.lng]);
      }
      var vt = { __proto__: null, simplify: ei, pointToSegmentDistance: ii2, closestPointOnSegment: function(t12, e18, i13) {
        return ri(t12, e18, i13);
      }, clipSegment: ni, _getEdgeIntersection: oi, _getBitCode: si5, _sqClosestPointOnSegment: ri, isFlat: I42, _flat: ai, polylineCenter: hi }, yt2 = { project: function(t12) {
        return new p42(t12.lng, t12.lat);
      }, unproject: function(t12) {
        return new v42(t12.y, t12.x);
      }, bounds: new f82([-180, -90], [180, 90]) }, xt = { R: 6378137, R_MINOR: 6356752314245179e-9, bounds: new f82([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]), project: function(t12) {
        var e18 = Math.PI / 180, i13 = this.R, n18 = t12.lat * e18, o16 = this.R_MINOR / i13, o16 = Math.sqrt(1 - o16 * o16), s10 = o16 * Math.sin(n18), s10 = Math.tan(Math.PI / 4 - n18 / 2) / Math.pow((1 - s10) / (1 + s10), o16 / 2), n18 = -i13 * Math.log(Math.max(s10, 1e-10));
        return new p42(t12.lng * e18 * i13, n18);
      }, unproject: function(t12) {
        for (var e18, i13 = 180 / Math.PI, n18 = this.R, o16 = this.R_MINOR / n18, s10 = Math.sqrt(1 - o16 * o16), r12 = Math.exp(-t12.y / n18), a8 = Math.PI / 2 - 2 * Math.atan(r12), h10 = 0, l12 = 0.1; h10 < 15 && 1e-7 < Math.abs(l12); h10++) e18 = s10 * Math.sin(a8), e18 = Math.pow((1 - e18) / (1 + e18), s10 / 2), a8 += l12 = Math.PI / 2 - 2 * Math.atan(r12 * e18) - a8;
        return new v42(a8 * i13, t12.x * i13 / n18);
      } }, wt2 = { __proto__: null, LonLat: yt2, Mercator: xt, SphericalMercator: rt4 }, Pt = l11({}, st32, { code: "EPSG:3395", projection: xt, transformation: ht3(bt2 = 0.5 / (Math.PI * xt.R), 0.5, -bt2, 0.5) }), li = l11({}, st32, { code: "EPSG:4326", projection: yt2, transformation: ht3(1 / 180, 1, -1 / 180, 0.5) }), Lt = l11({}, ot, { projection: yt2, transformation: ht3(1, 0, -1, 0), scale: function(t12) {
        return Math.pow(2, t12);
      }, zoom: function(t12) {
        return Math.log(t12) / Math.LN2;
      }, distance: function(t12, e18) {
        var i13 = e18.lng - t12.lng, e18 = e18.lat - t12.lat;
        return Math.sqrt(i13 * i13 + e18 * e18);
      }, infinite: true }), o15 = (ot.Earth = st32, ot.EPSG3395 = Pt, ot.EPSG3857 = lt32, ot.EPSG900913 = ut, ot.EPSG4326 = li, ot.Simple = Lt, it.extend({ options: { pane: "overlayPane", attribution: null, bubblingMouseEvents: true }, addTo: function(t12) {
        return t12.addLayer(this), this;
      }, remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      }, removeFrom: function(t12) {
        return t12 && t12.removeLayer(this), this;
      }, getPane: function(t12) {
        return this._map.getPane(t12 ? this.options[t12] || t12 : this.options.pane);
      }, addInteractiveTarget: function(t12) {
        return this._map._targets[h92(t12)] = this;
      }, removeInteractiveTarget: function(t12) {
        return delete this._map._targets[h92(t12)], this;
      }, getAttribution: function() {
        return this.options.attribution;
      }, _layerAdd: function(t12) {
        var e18, i13 = t12.target;
        i13.hasLayer(this) && (this._map = i13, this._zoomAnimated = i13._zoomAnimated, this.getEvents && (e18 = this.getEvents(), i13.on(e18, this), this.once("remove", function() {
          i13.off(e18, this);
        }, this)), this.onAdd(i13), this.fire("add"), i13.fire("layeradd", { layer: this }));
      } })), ui = (A2.include({ addLayer: function(t12) {
        var e18;
        if (t12._layerAdd) return e18 = h92(t12), this._layers[e18] || ((this._layers[e18] = t12)._mapToAdd = this, t12.beforeAdd && t12.beforeAdd(this), this.whenReady(t12._layerAdd, t12)), this;
        throw new Error("The provided object is not a Layer.");
      }, removeLayer: function(t12) {
        var e18 = h92(t12);
        return this._layers[e18] && (this._loaded && t12.onRemove(this), delete this._layers[e18], this._loaded && (this.fire("layerremove", { layer: t12 }), t12.fire("remove")), t12._map = t12._mapToAdd = null), this;
      }, hasLayer: function(t12) {
        return h92(t12) in this._layers;
      }, eachLayer: function(t12, e18) {
        for (var i13 in this._layers) t12.call(e18, this._layers[i13]);
        return this;
      }, _addLayers: function(t12) {
        for (var e18 = 0, i13 = (t12 = t12 ? d52(t12) ? t12 : [t12] : []).length; e18 < i13; e18++) this.addLayer(t12[e18]);
      }, _addZoomLimit: function(t12) {
        isNaN(t12.options.maxZoom) && isNaN(t12.options.minZoom) || (this._zoomBoundLayers[h92(t12)] = t12, this._updateZoomLevels());
      }, _removeZoomLimit: function(t12) {
        t12 = h92(t12);
        this._zoomBoundLayers[t12] && (delete this._zoomBoundLayers[t12], this._updateZoomLevels());
      }, _updateZoomLevels: function() {
        var t12, e18 = 1 / 0, i13 = -1 / 0, n18 = this._getZoomSpan();
        for (t12 in this._zoomBoundLayers) var o16 = this._zoomBoundLayers[t12].options, e18 = void 0 === o16.minZoom ? e18 : Math.min(e18, o16.minZoom), i13 = void 0 === o16.maxZoom ? i13 : Math.max(i13, o16.maxZoom);
        this._layersMaxZoom = i13 === -1 / 0 ? void 0 : i13, this._layersMinZoom = e18 === 1 / 0 ? void 0 : e18, n18 !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
      } }), o15.extend({ initialize: function(t12, e18) {
        var i13, n18;
        if (c92(this, e18), this._layers = {}, t12) for (i13 = 0, n18 = t12.length; i13 < n18; i13++) this.addLayer(t12[i13]);
      }, addLayer: function(t12) {
        var e18 = this.getLayerId(t12);
        return this._layers[e18] = t12, this._map && this._map.addLayer(t12), this;
      }, removeLayer: function(t12) {
        t12 = t12 in this._layers ? t12 : this.getLayerId(t12);
        return this._map && this._layers[t12] && this._map.removeLayer(this._layers[t12]), delete this._layers[t12], this;
      }, hasLayer: function(t12) {
        return ("number" == typeof t12 ? t12 : this.getLayerId(t12)) in this._layers;
      }, clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      }, invoke: function(t12) {
        var e18, i13, n18 = Array.prototype.slice.call(arguments, 1);
        for (e18 in this._layers) (i13 = this._layers[e18])[t12] && i13[t12].apply(i13, n18);
        return this;
      }, onAdd: function(t12) {
        this.eachLayer(t12.addLayer, t12);
      }, onRemove: function(t12) {
        this.eachLayer(t12.removeLayer, t12);
      }, eachLayer: function(t12, e18) {
        for (var i13 in this._layers) t12.call(e18, this._layers[i13]);
        return this;
      }, getLayer: function(t12) {
        return this._layers[t12];
      }, getLayers: function() {
        var t12 = [];
        return this.eachLayer(t12.push, t12), t12;
      }, setZIndex: function(t12) {
        return this.invoke("setZIndex", t12);
      }, getLayerId: h92 })), ci = ui.extend({ addLayer: function(t12) {
        return this.hasLayer(t12) ? this : (t12.addEventParent(this), ui.prototype.addLayer.call(this, t12), this.fire("layeradd", { layer: t12 }));
      }, removeLayer: function(t12) {
        return this.hasLayer(t12) ? ((t12 = t12 in this._layers ? this._layers[t12] : t12).removeEventParent(this), ui.prototype.removeLayer.call(this, t12), this.fire("layerremove", { layer: t12 })) : this;
      }, setStyle: function(t12) {
        return this.invoke("setStyle", t12);
      }, bringToFront: function() {
        return this.invoke("bringToFront");
      }, bringToBack: function() {
        return this.invoke("bringToBack");
      }, getBounds: function() {
        var t12, e18 = new s9();
        for (t12 in this._layers) {
          var i13 = this._layers[t12];
          e18.extend(i13.getBounds ? i13.getBounds() : i13.getLatLng());
        }
        return e18;
      } }), di = et35.extend({ options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0], crossOrigin: false }, initialize: function(t12) {
        c92(this, t12);
      }, createIcon: function(t12) {
        return this._createIcon("icon", t12);
      }, createShadow: function(t12) {
        return this._createIcon("shadow", t12);
      }, _createIcon: function(t12, e18) {
        var i13 = this._getIconUrl(t12);
        if (i13) return i13 = this._createImg(i13, e18 && "IMG" === e18.tagName ? e18 : null), this._setIconStyles(i13, t12), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i13.crossOrigin = true === this.options.crossOrigin ? "" : this.options.crossOrigin), i13;
        if ("icon" === t12) throw new Error("iconUrl not set in Icon options (see the docs).");
        return null;
      }, _setIconStyles: function(t12, e18) {
        var i13 = this.options, n18 = i13[e18 + "Size"], n18 = m42(n18 = "number" == typeof n18 ? [n18, n18] : n18), o16 = m42("shadow" === e18 && i13.shadowAnchor || i13.iconAnchor || n18 && n18.divideBy(2, true));
        t12.className = "leaflet-marker-" + e18 + " " + (i13.className || ""), o16 && (t12.style.marginLeft = -o16.x + "px", t12.style.marginTop = -o16.y + "px"), n18 && (t12.style.width = n18.x + "px", t12.style.height = n18.y + "px");
      }, _createImg: function(t12, e18) {
        return (e18 = e18 || document.createElement("img")).src = t12, e18;
      }, _getIconUrl: function(t12) {
        return b42.retina && this.options[t12 + "RetinaUrl"] || this.options[t12 + "Url"];
      } });
      var _i = di.extend({ options: { iconUrl: "marker-icon.png", iconRetinaUrl: "marker-icon-2x.png", shadowUrl: "marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41] }, _getIconUrl: function(t12) {
        return "string" != typeof _i.imagePath && (_i.imagePath = this._detectIconPath()), (this.options.imagePath || _i.imagePath) + di.prototype._getIconUrl.call(this, t12);
      }, _stripUrl: function(t12) {
        function e18(t13, e19, i13) {
          return (e19 = e19.exec(t13)) && e19[i13];
        }
        return (t12 = e18(t12, /^url\((['"])?(.+)\1\)$/, 2)) && e18(t12, /^(.*)marker-icon\.png$/, 1);
      }, _detectIconPath: function() {
        var t12 = P42("div", "leaflet-default-icon-path", document.body), e18 = pe(t12, "background-image") || pe(t12, "backgroundImage");
        return document.body.removeChild(t12), (e18 = this._stripUrl(e18)) ? e18 : (t12 = document.querySelector('link[href$="leaflet.css"]')) ? t12.href.substring(0, t12.href.length - "leaflet.css".length - 1) : "";
      } }), pi = n17.extend({ initialize: function(t12) {
        this._marker = t12;
      }, addHooks: function() {
        var t12 = this._marker._icon;
        this._draggable || (this._draggable = new Xe(t12, t12, true)), this._draggable.on({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).enable(), M42(t12, "leaflet-marker-draggable");
      }, removeHooks: function() {
        this._draggable.off({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).disable(), this._marker._icon && z42(this._marker._icon, "leaflet-marker-draggable");
      }, moved: function() {
        return this._draggable && this._draggable._moved;
      }, _adjustPan: function(t12) {
        var e18 = this._marker, i13 = e18._map, n18 = this._marker.options.autoPanSpeed, o16 = this._marker.options.autoPanPadding, s10 = Pe(e18._icon), r12 = i13.getPixelBounds(), a8 = i13.getPixelOrigin(), a8 = _42(r12.min._subtract(a8).add(o16), r12.max._subtract(a8).subtract(o16));
        a8.contains(s10) || (o16 = m42((Math.max(a8.max.x, s10.x) - a8.max.x) / (r12.max.x - a8.max.x) - (Math.min(a8.min.x, s10.x) - a8.min.x) / (r12.min.x - a8.min.x), (Math.max(a8.max.y, s10.y) - a8.max.y) / (r12.max.y - a8.max.y) - (Math.min(a8.min.y, s10.y) - a8.min.y) / (r12.min.y - a8.min.y)).multiplyBy(n18), i13.panBy(o16, { animate: false }), this._draggable._newPos._add(o16), this._draggable._startPos._add(o16), Z42(e18._icon, this._draggable._newPos), this._onDrag(t12), this._panRequest = x52(this._adjustPan.bind(this, t12)));
      }, _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
      }, _onPreDrag: function(t12) {
        this._marker.options.autoPan && (r112(this._panRequest), this._panRequest = x52(this._adjustPan.bind(this, t12)));
      }, _onDrag: function(t12) {
        var e18 = this._marker, i13 = e18._shadow, n18 = Pe(e18._icon), o16 = e18._map.layerPointToLatLng(n18);
        i13 && Z42(i13, n18), e18._latlng = o16, t12.latlng = o16, t12.oldLatLng = this._oldLatLng, e18.fire("move", t12).fire("drag", t12);
      }, _onDragEnd: function(t12) {
        r112(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t12);
      } }), mi = o15.extend({ options: { icon: new _i(), interactive: true, keyboard: true, title: "", alt: "Marker", zIndexOffset: 0, opacity: 1, riseOnHover: false, riseOffset: 250, pane: "markerPane", shadowPane: "shadowPane", bubblingMouseEvents: false, autoPanOnFocus: true, draggable: false, autoPan: false, autoPanPadding: [50, 50], autoPanSpeed: 10 }, initialize: function(t12, e18) {
        c92(this, e18), this._latlng = w42(t12);
      }, onAdd: function(t12) {
        this._zoomAnimated = this._zoomAnimated && t12.options.markerZoomAnimation, this._zoomAnimated && t12.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
      }, onRemove: function(t12) {
        this.dragging && this.dragging.enabled() && (this.options.draggable = true, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t12.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
      }, getEvents: function() {
        return { zoom: this.update, viewreset: this.update };
      }, getLatLng: function() {
        return this._latlng;
      }, setLatLng: function(t12) {
        var e18 = this._latlng;
        return this._latlng = w42(t12), this.update(), this.fire("move", { oldLatLng: e18, latlng: this._latlng });
      }, setZIndexOffset: function(t12) {
        return this.options.zIndexOffset = t12, this.update();
      }, getIcon: function() {
        return this.options.icon;
      }, setIcon: function(t12) {
        return this.options.icon = t12, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
      }, getElement: function() {
        return this._icon;
      }, update: function() {
        var t12;
        return this._icon && this._map && (t12 = this._map.latLngToLayerPoint(this._latlng).round(), this._setPos(t12)), this;
      }, _initIcon: function() {
        var t12 = this.options, e18 = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), i13 = t12.icon.createIcon(this._icon), n18 = false, i13 = (i13 !== this._icon && (this._icon && this._removeIcon(), n18 = true, t12.title && (i13.title = t12.title), "IMG" === i13.tagName && (i13.alt = t12.alt || "")), M42(i13, e18), t12.keyboard && (i13.tabIndex = "0", i13.setAttribute("role", "button")), this._icon = i13, t12.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), this.options.autoPanOnFocus && S72(i13, "focus", this._panOnFocus, this), t12.icon.createShadow(this._shadow)), o16 = false;
        i13 !== this._shadow && (this._removeShadow(), o16 = true), i13 && (M42(i13, e18), i13.alt = ""), this._shadow = i13, t12.opacity < 1 && this._updateOpacity(), n18 && this.getPane().appendChild(this._icon), this._initInteraction(), i13 && o16 && this.getPane(t12.shadowPane).appendChild(this._shadow);
      }, _removeIcon: function() {
        this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), this.options.autoPanOnFocus && k42(this._icon, "focus", this._panOnFocus, this), T42(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
      }, _removeShadow: function() {
        this._shadow && T42(this._shadow), this._shadow = null;
      }, _setPos: function(t12) {
        this._icon && Z42(this._icon, t12), this._shadow && Z42(this._shadow, t12), this._zIndex = t12.y + this.options.zIndexOffset, this._resetZIndex();
      }, _updateZIndex: function(t12) {
        this._icon && (this._icon.style.zIndex = this._zIndex + t12);
      }, _animateZoom: function(t12) {
        t12 = this._map._latLngToNewLayerPoint(this._latlng, t12.zoom, t12.center).round();
        this._setPos(t12);
      }, _initInteraction: function() {
        var t12;
        this.options.interactive && (M42(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), pi && (t12 = this.options.draggable, this.dragging && (t12 = this.dragging.enabled(), this.dragging.disable()), this.dragging = new pi(this), t12 && this.dragging.enable()));
      }, setOpacity: function(t12) {
        return this.options.opacity = t12, this._map && this._updateOpacity(), this;
      }, _updateOpacity: function() {
        var t12 = this.options.opacity;
        this._icon && C2(this._icon, t12), this._shadow && C2(this._shadow, t12);
      }, _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      }, _resetZIndex: function() {
        this._updateZIndex(0);
      }, _panOnFocus: function() {
        var t12, e18, i13 = this._map;
        i13 && (t12 = (e18 = this.options.icon.options).iconSize ? m42(e18.iconSize) : m42(0, 0), e18 = e18.iconAnchor ? m42(e18.iconAnchor) : m42(0, 0), i13.panInside(this._latlng, { paddingTopLeft: e18, paddingBottomRight: t12.subtract(e18) }));
      }, _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      }, _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      } });
      var fi = o15.extend({ options: { stroke: true, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", dashArray: null, dashOffset: null, fill: false, fillColor: null, fillOpacity: 0.2, fillRule: "evenodd", interactive: true, bubblingMouseEvents: true }, beforeAdd: function(t12) {
        this._renderer = t12.getRenderer(this);
      }, onAdd: function() {
        this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
      }, onRemove: function() {
        this._renderer._removePath(this);
      }, redraw: function() {
        return this._map && this._renderer._updatePath(this), this;
      }, setStyle: function(t12) {
        return c92(this, t12), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t12 && Object.prototype.hasOwnProperty.call(t12, "weight") && this._updateBounds()), this;
      }, bringToFront: function() {
        return this._renderer && this._renderer._bringToFront(this), this;
      }, bringToBack: function() {
        return this._renderer && this._renderer._bringToBack(this), this;
      }, getElement: function() {
        return this._path;
      }, _reset: function() {
        this._project(), this._update();
      }, _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
      } }), gi = fi.extend({ options: { fill: true, radius: 10 }, initialize: function(t12, e18) {
        c92(this, e18), this._latlng = w42(t12), this._radius = this.options.radius;
      }, setLatLng: function(t12) {
        var e18 = this._latlng;
        return this._latlng = w42(t12), this.redraw(), this.fire("move", { oldLatLng: e18, latlng: this._latlng });
      }, getLatLng: function() {
        return this._latlng;
      }, setRadius: function(t12) {
        return this.options.radius = this._radius = t12, this.redraw();
      }, getRadius: function() {
        return this._radius;
      }, setStyle: function(t12) {
        var e18 = t12 && t12.radius || this._radius;
        return fi.prototype.setStyle.call(this, t12), this.setRadius(e18), this;
      }, _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
      }, _updateBounds: function() {
        var t12 = this._radius, e18 = this._radiusY || t12, i13 = this._clickTolerance(), t12 = [t12 + i13, e18 + i13];
        this._pxBounds = new f82(this._point.subtract(t12), this._point.add(t12));
      }, _update: function() {
        this._map && this._updatePath();
      }, _updatePath: function() {
        this._renderer._updateCircle(this);
      }, _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      }, _containsPoint: function(t12) {
        return t12.distanceTo(this._point) <= this._radius + this._clickTolerance();
      } });
      var vi = gi.extend({ initialize: function(t12, e18, i13) {
        if (c92(this, e18 = "number" == typeof e18 ? l11({}, i13, { radius: e18 }) : e18), this._latlng = w42(t12), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN");
        this._mRadius = this.options.radius;
      }, setRadius: function(t12) {
        return this._mRadius = t12, this.redraw();
      }, getRadius: function() {
        return this._mRadius;
      }, getBounds: function() {
        var t12 = [this._radius, this._radiusY || this._radius];
        return new s9(this._map.layerPointToLatLng(this._point.subtract(t12)), this._map.layerPointToLatLng(this._point.add(t12)));
      }, setStyle: fi.prototype.setStyle, _project: function() {
        var t12, e18, i13, n18, o16, s10 = this._latlng.lng, r12 = this._latlng.lat, a8 = this._map, h10 = a8.options.crs;
        h10.distance === st32.distance ? (n18 = Math.PI / 180, o16 = this._mRadius / st32.R / n18, t12 = a8.project([r12 + o16, s10]), e18 = a8.project([r12 - o16, s10]), e18 = t12.add(e18).divideBy(2), i13 = a8.unproject(e18).lat, n18 = Math.acos((Math.cos(o16 * n18) - Math.sin(r12 * n18) * Math.sin(i13 * n18)) / (Math.cos(r12 * n18) * Math.cos(i13 * n18))) / n18, !isNaN(n18) && 0 !== n18 || (n18 = o16 / Math.cos(Math.PI / 180 * r12)), this._point = e18.subtract(a8.getPixelOrigin()), this._radius = isNaN(n18) ? 0 : e18.x - a8.project([i13, s10 - n18]).x, this._radiusY = e18.y - t12.y) : (o16 = h10.unproject(h10.project(this._latlng).subtract([this._mRadius, 0])), this._point = a8.latLngToLayerPoint(this._latlng), this._radius = this._point.x - a8.latLngToLayerPoint(o16).x), this._updateBounds();
      } });
      var yi = fi.extend({ options: { smoothFactor: 1, noClip: false }, initialize: function(t12, e18) {
        c92(this, e18), this._setLatLngs(t12);
      }, getLatLngs: function() {
        return this._latlngs;
      }, setLatLngs: function(t12) {
        return this._setLatLngs(t12), this.redraw();
      }, isEmpty: function() {
        return !this._latlngs.length;
      }, closestLayerPoint: function(t12) {
        for (var e18 = 1 / 0, i13 = null, n18 = ri, o16 = 0, s10 = this._parts.length; o16 < s10; o16++) for (var r12 = this._parts[o16], a8 = 1, h10 = r12.length; a8 < h10; a8++) {
          var l12, u72, c10 = n18(t12, l12 = r12[a8 - 1], u72 = r12[a8], true);
          c10 < e18 && (e18 = c10, i13 = n18(t12, l12, u72));
        }
        return i13 && (i13.distance = Math.sqrt(e18)), i13;
      }, getCenter: function() {
        if (this._map) return hi(this._defaultShape(), this._map.options.crs);
        throw new Error("Must add layer to map before using getCenter()");
      }, getBounds: function() {
        return this._bounds;
      }, addLatLng: function(t12, e18) {
        return e18 = e18 || this._defaultShape(), t12 = w42(t12), e18.push(t12), this._bounds.extend(t12), this.redraw();
      }, _setLatLngs: function(t12) {
        this._bounds = new s9(), this._latlngs = this._convertLatLngs(t12);
      }, _defaultShape: function() {
        return I42(this._latlngs) ? this._latlngs : this._latlngs[0];
      }, _convertLatLngs: function(t12) {
        for (var e18 = [], i13 = I42(t12), n18 = 0, o16 = t12.length; n18 < o16; n18++) i13 ? (e18[n18] = w42(t12[n18]), this._bounds.extend(e18[n18])) : e18[n18] = this._convertLatLngs(t12[n18]);
        return e18;
      }, _project: function() {
        var t12 = new f82();
        this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t12), this._bounds.isValid() && t12.isValid() && (this._rawPxBounds = t12, this._updateBounds());
      }, _updateBounds: function() {
        var t12 = this._clickTolerance(), t12 = new p42(t12, t12);
        this._rawPxBounds && (this._pxBounds = new f82([this._rawPxBounds.min.subtract(t12), this._rawPxBounds.max.add(t12)]));
      }, _projectLatlngs: function(t12, e18, i13) {
        var n18, o16, s10 = t12[0] instanceof v42, r12 = t12.length;
        if (s10) {
          for (o16 = [], n18 = 0; n18 < r12; n18++) o16[n18] = this._map.latLngToLayerPoint(t12[n18]), i13.extend(o16[n18]);
          e18.push(o16);
        } else for (n18 = 0; n18 < r12; n18++) this._projectLatlngs(t12[n18], e18, i13);
      }, _clipPoints: function() {
        var t12 = this._renderer._bounds;
        if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t12)) if (this.options.noClip) this._parts = this._rings;
        else for (var e18, i13, n18, o16, s10 = this._parts, r12 = 0, a8 = 0, h10 = this._rings.length; r12 < h10; r12++) for (e18 = 0, i13 = (o16 = this._rings[r12]).length; e18 < i13 - 1; e18++) (n18 = ni(o16[e18], o16[e18 + 1], t12, e18, true)) && (s10[a8] = s10[a8] || [], s10[a8].push(n18[0]), n18[1] === o16[e18 + 1] && e18 !== i13 - 2 || (s10[a8].push(n18[1]), a8++));
      }, _simplifyPoints: function() {
        for (var t12 = this._parts, e18 = this.options.smoothFactor, i13 = 0, n18 = t12.length; i13 < n18; i13++) t12[i13] = ei(t12[i13], e18);
      }, _update: function() {
        this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
      }, _updatePath: function() {
        this._renderer._updatePoly(this);
      }, _containsPoint: function(t12, e18) {
        var i13, n18, o16, s10, r12, a8, h10 = this._clickTolerance();
        if (this._pxBounds && this._pxBounds.contains(t12)) {
          for (i13 = 0, s10 = this._parts.length; i13 < s10; i13++) for (n18 = 0, o16 = (r12 = (a8 = this._parts[i13]).length) - 1; n18 < r12; o16 = n18++) if ((e18 || 0 !== n18) && ii2(t12, a8[o16], a8[n18]) <= h10) return true;
        }
        return false;
      } });
      yi._flat = ai;
      var xi = yi.extend({ options: { fill: true }, isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      }, getCenter: function() {
        if (this._map) return $e4(this._defaultShape(), this._map.options.crs);
        throw new Error("Must add layer to map before using getCenter()");
      }, _convertLatLngs: function(t12) {
        var t12 = yi.prototype._convertLatLngs.call(this, t12), e18 = t12.length;
        return 2 <= e18 && t12[0] instanceof v42 && t12[0].equals(t12[e18 - 1]) && t12.pop(), t12;
      }, _setLatLngs: function(t12) {
        yi.prototype._setLatLngs.call(this, t12), I42(this._latlngs) && (this._latlngs = [this._latlngs]);
      }, _defaultShape: function() {
        return (I42(this._latlngs[0]) ? this._latlngs : this._latlngs[0])[0];
      }, _clipPoints: function() {
        var t12 = this._renderer._bounds, e18 = this.options.weight, e18 = new p42(e18, e18), t12 = new f82(t12.min.subtract(e18), t12.max.add(e18));
        if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t12)) if (this.options.noClip) this._parts = this._rings;
        else for (var i13, n18 = 0, o16 = this._rings.length; n18 < o16; n18++) (i13 = Je(this._rings[n18], t12, true)).length && this._parts.push(i13);
      }, _updatePath: function() {
        this._renderer._updatePoly(this, true);
      }, _containsPoint: function(t12) {
        var e18, i13, n18, o16, s10, r12, a8, h10, l12 = false;
        if (!this._pxBounds || !this._pxBounds.contains(t12)) return false;
        for (o16 = 0, a8 = this._parts.length; o16 < a8; o16++) for (s10 = 0, r12 = (h10 = (e18 = this._parts[o16]).length) - 1; s10 < h10; r12 = s10++) i13 = e18[s10], n18 = e18[r12], i13.y > t12.y != n18.y > t12.y && t12.x < (n18.x - i13.x) * (t12.y - i13.y) / (n18.y - i13.y) + i13.x && (l12 = !l12);
        return l12 || yi.prototype._containsPoint.call(this, t12, true);
      } });
      var wi = ci.extend({ initialize: function(t12, e18) {
        c92(this, e18), this._layers = {}, t12 && this.addData(t12);
      }, addData: function(t12) {
        var e18, i13, n18, o16 = d52(t12) ? t12 : t12.features;
        if (o16) {
          for (e18 = 0, i13 = o16.length; e18 < i13; e18++) ((n18 = o16[e18]).geometries || n18.geometry || n18.features || n18.coordinates) && this.addData(n18);
          return this;
        }
        var s10, r12 = this.options;
        return (!r12.filter || r12.filter(t12)) && (s10 = bi(t12, r12)) ? (s10.feature = Zi(t12), s10.defaultOptions = s10.options, this.resetStyle(s10), r12.onEachFeature && r12.onEachFeature(t12, s10), this.addLayer(s10)) : this;
      }, resetStyle: function(t12) {
        return void 0 === t12 ? this.eachLayer(this.resetStyle, this) : (t12.options = l11({}, t12.defaultOptions), this._setLayerStyle(t12, this.options.style), this);
      }, setStyle: function(e18) {
        return this.eachLayer(function(t12) {
          this._setLayerStyle(t12, e18);
        }, this);
      }, _setLayerStyle: function(t12, e18) {
        t12.setStyle && ("function" == typeof e18 && (e18 = e18(t12.feature)), t12.setStyle(e18));
      } });
      function bi(t12, e18) {
        var i13, n18, o16, s10, r12 = "Feature" === t12.type ? t12.geometry : t12, a8 = r12 ? r12.coordinates : null, h10 = [], l12 = e18 && e18.pointToLayer, u72 = e18 && e18.coordsToLatLng || Li;
        if (!a8 && !r12) return null;
        switch (r12.type) {
          case "Point":
            return Pi(l12, t12, i13 = u72(a8), e18);
          case "MultiPoint":
            for (o16 = 0, s10 = a8.length; o16 < s10; o16++) i13 = u72(a8[o16]), h10.push(Pi(l12, t12, i13, e18));
            return new ci(h10);
          case "LineString":
          case "MultiLineString":
            return n18 = Ti(a8, "LineString" === r12.type ? 0 : 1, u72), new yi(n18, e18);
          case "Polygon":
          case "MultiPolygon":
            return n18 = Ti(a8, "Polygon" === r12.type ? 1 : 2, u72), new xi(n18, e18);
          case "GeometryCollection":
            for (o16 = 0, s10 = r12.geometries.length; o16 < s10; o16++) {
              var c10 = bi({ geometry: r12.geometries[o16], type: "Feature", properties: t12.properties }, e18);
              c10 && h10.push(c10);
            }
            return new ci(h10);
          case "FeatureCollection":
            for (o16 = 0, s10 = r12.features.length; o16 < s10; o16++) {
              var d62 = bi(r12.features[o16], e18);
              d62 && h10.push(d62);
            }
            return new ci(h10);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function Pi(t12, e18, i13, n18) {
        return t12 ? t12(e18, i13) : new mi(i13, n18 && n18.markersInheritOptions && n18);
      }
      function Li(t12) {
        return new v42(t12[1], t12[0], t12[2]);
      }
      function Ti(t12, e18, i13) {
        for (var n18, o16 = [], s10 = 0, r12 = t12.length; s10 < r12; s10++) n18 = e18 ? Ti(t12[s10], e18 - 1, i13) : (i13 || Li)(t12[s10]), o16.push(n18);
        return o16;
      }
      function Mi(t12, e18) {
        return void 0 !== (t12 = w42(t12)).alt ? [i12(t12.lng, e18), i12(t12.lat, e18), i12(t12.alt, e18)] : [i12(t12.lng, e18), i12(t12.lat, e18)];
      }
      function zi(t12, e18, i13, n18) {
        for (var o16 = [], s10 = 0, r12 = t12.length; s10 < r12; s10++) o16.push(e18 ? zi(t12[s10], I42(t12[s10]) ? 0 : e18 - 1, i13, n18) : Mi(t12[s10], n18));
        return !e18 && i13 && 0 < o16.length && o16.push(o16[0].slice()), o16;
      }
      function Ci(t12, e18) {
        return t12.feature ? l11({}, t12.feature, { geometry: e18 }) : Zi(e18);
      }
      function Zi(t12) {
        return "Feature" === t12.type || "FeatureCollection" === t12.type ? t12 : { type: "Feature", properties: {}, geometry: t12 };
      }
      Tt = { toGeoJSON: function(t12) {
        return Ci(this, { type: "Point", coordinates: Mi(this.getLatLng(), t12) });
      } };
      function Si(t12, e18) {
        return new wi(t12, e18);
      }
      mi.include(Tt), vi.include(Tt), gi.include(Tt), yi.include({ toGeoJSON: function(t12) {
        var e18 = !I42(this._latlngs);
        return Ci(this, { type: (e18 ? "Multi" : "") + "LineString", coordinates: zi(this._latlngs, e18 ? 1 : 0, false, t12) });
      } }), xi.include({ toGeoJSON: function(t12) {
        var e18 = !I42(this._latlngs), i13 = e18 && !I42(this._latlngs[0]), t12 = zi(this._latlngs, i13 ? 2 : e18 ? 1 : 0, true, t12);
        return Ci(this, { type: (i13 ? "Multi" : "") + "Polygon", coordinates: t12 = e18 ? t12 : [t12] });
      } }), ui.include({ toMultiPoint: function(e18) {
        var i13 = [];
        return this.eachLayer(function(t12) {
          i13.push(t12.toGeoJSON(e18).geometry.coordinates);
        }), Ci(this, { type: "MultiPoint", coordinates: i13 });
      }, toGeoJSON: function(e18) {
        var i13, n18, t12 = this.feature && this.feature.geometry && this.feature.geometry.type;
        return "MultiPoint" === t12 ? this.toMultiPoint(e18) : (i13 = "GeometryCollection" === t12, n18 = [], this.eachLayer(function(t13) {
          t13.toGeoJSON && (t13 = t13.toGeoJSON(e18), i13 ? n18.push(t13.geometry) : "FeatureCollection" === (t13 = Zi(t13)).type ? n18.push.apply(n18, t13.features) : n18.push(t13));
        }), i13 ? Ci(this, { geometries: n18, type: "GeometryCollection" }) : { type: "FeatureCollection", features: n18 });
      } });
      var Mt = Si, Ei = o15.extend({ options: { opacity: 1, alt: "", interactive: false, crossOrigin: false, errorOverlayUrl: "", zIndex: 1, className: "" }, initialize: function(t12, e18, i13) {
        this._url = t12, this._bounds = g42(e18), c92(this, i13);
      }, onAdd: function() {
        this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (M42(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
      }, onRemove: function() {
        T42(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
      }, setOpacity: function(t12) {
        return this.options.opacity = t12, this._image && this._updateOpacity(), this;
      }, setStyle: function(t12) {
        return t12.opacity && this.setOpacity(t12.opacity), this;
      }, bringToFront: function() {
        return this._map && fe(this._image), this;
      }, bringToBack: function() {
        return this._map && ge(this._image), this;
      }, setUrl: function(t12) {
        return this._url = t12, this._image && (this._image.src = t12), this;
      }, setBounds: function(t12) {
        return this._bounds = g42(t12), this._map && this._reset(), this;
      }, getEvents: function() {
        var t12 = { zoom: this._reset, viewreset: this._reset };
        return this._zoomAnimated && (t12.zoomanim = this._animateZoom), t12;
      }, setZIndex: function(t12) {
        return this.options.zIndex = t12, this._updateZIndex(), this;
      }, getBounds: function() {
        return this._bounds;
      }, getElement: function() {
        return this._image;
      }, _initImage: function() {
        var t12 = "IMG" === this._url.tagName, e18 = this._image = t12 ? this._url : P42("img");
        M42(e18, "leaflet-image-layer"), this._zoomAnimated && M42(e18, "leaflet-zoom-animated"), this.options.className && M42(e18, this.options.className), e18.onselectstart = u62, e18.onmousemove = u62, e18.onload = a72(this.fire, this, "load"), e18.onerror = a72(this._overlayOnError, this, "error"), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e18.crossOrigin = true === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t12 ? this._url = e18.src : (e18.src = this._url, e18.alt = this.options.alt);
      }, _animateZoom: function(t12) {
        var e18 = this._map.getZoomScale(t12.zoom), t12 = this._map._latLngBoundsToNewLayerBounds(this._bounds, t12.zoom, t12.center).min;
        be(this._image, t12, e18);
      }, _reset: function() {
        var t12 = this._image, e18 = new f82(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), i13 = e18.getSize();
        Z42(t12, e18.min), t12.style.width = i13.x + "px", t12.style.height = i13.y + "px";
      }, _updateOpacity: function() {
        C2(this._image, this.options.opacity);
      }, _updateZIndex: function() {
        this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex);
      }, _overlayOnError: function() {
        this.fire("error");
        var t12 = this.options.errorOverlayUrl;
        t12 && this._url !== t12 && (this._url = t12, this._image.src = t12);
      }, getCenter: function() {
        return this._bounds.getCenter();
      } }), ki = Ei.extend({ options: { autoplay: true, loop: true, keepAspectRatio: true, muted: false, playsInline: true }, _initImage: function() {
        var t12 = "VIDEO" === this._url.tagName, e18 = this._image = t12 ? this._url : P42("video");
        if (M42(e18, "leaflet-image-layer"), this._zoomAnimated && M42(e18, "leaflet-zoom-animated"), this.options.className && M42(e18, this.options.className), e18.onselectstart = u62, e18.onmousemove = u62, e18.onloadeddata = a72(this.fire, this, "load"), t12) {
          for (var i13 = e18.getElementsByTagName("source"), n18 = [], o16 = 0; o16 < i13.length; o16++) n18.push(i13[o16].src);
          this._url = 0 < i13.length ? n18 : [e18.src];
        } else {
          d52(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e18.style, "objectFit") && (e18.style.objectFit = "fill"), e18.autoplay = !!this.options.autoplay, e18.loop = !!this.options.loop, e18.muted = !!this.options.muted, e18.playsInline = !!this.options.playsInline;
          for (var s10 = 0; s10 < this._url.length; s10++) {
            var r12 = P42("source");
            r12.src = this._url[s10], e18.appendChild(r12);
          }
        }
      } });
      var Oi = Ei.extend({ _initImage: function() {
        var t12 = this._image = this._url;
        M42(t12, "leaflet-image-layer"), this._zoomAnimated && M42(t12, "leaflet-zoom-animated"), this.options.className && M42(t12, this.options.className), t12.onselectstart = u62, t12.onmousemove = u62;
      } });
      var Ai = o15.extend({ options: { interactive: false, offset: [0, 0], className: "", pane: void 0, content: "" }, initialize: function(t12, e18) {
        t12 && (t12 instanceof v42 || d52(t12)) ? (this._latlng = w42(t12), c92(this, e18)) : (c92(this, t12), this._source = e18), this.options.content && (this._content = this.options.content);
      }, openOn: function(t12) {
        return (t12 = arguments.length ? t12 : this._source._map).hasLayer(this) || t12.addLayer(this), this;
      }, close: function() {
        return this._map && this._map.removeLayer(this), this;
      }, toggle: function(t12) {
        return this._map ? this.close() : (arguments.length ? this._source = t12 : t12 = this._source, this._prepareOpen(), this.openOn(t12._map)), this;
      }, onAdd: function(t12) {
        this._zoomAnimated = t12._zoomAnimated, this._container || this._initLayout(), t12._fadeAnimated && C2(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t12._fadeAnimated && C2(this._container, 1), this.bringToFront(), this.options.interactive && (M42(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
      }, onRemove: function(t12) {
        t12._fadeAnimated ? (C2(this._container, 0), this._removeTimeout = setTimeout(a72(T42, void 0, this._container), 200)) : T42(this._container), this.options.interactive && (z42(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
      }, getLatLng: function() {
        return this._latlng;
      }, setLatLng: function(t12) {
        return this._latlng = w42(t12), this._map && (this._updatePosition(), this._adjustPan()), this;
      }, getContent: function() {
        return this._content;
      }, setContent: function(t12) {
        return this._content = t12, this.update(), this;
      }, getElement: function() {
        return this._container;
      }, update: function() {
        this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
      }, getEvents: function() {
        var t12 = { zoom: this._updatePosition, viewreset: this._updatePosition };
        return this._zoomAnimated && (t12.zoomanim = this._animateZoom), t12;
      }, isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      }, bringToFront: function() {
        return this._map && fe(this._container), this;
      }, bringToBack: function() {
        return this._map && ge(this._container), this;
      }, _prepareOpen: function(t12) {
        if (!(i13 = this._source)._map) return false;
        if (i13 instanceof ci) {
          var e18, i13 = null, n18 = this._source._layers;
          for (e18 in n18) if (n18[e18]._map) {
            i13 = n18[e18];
            break;
          }
          if (!i13) return false;
          this._source = i13;
        }
        if (!t12) if (i13.getCenter) t12 = i13.getCenter();
        else if (i13.getLatLng) t12 = i13.getLatLng();
        else {
          if (!i13.getBounds) throw new Error("Unable to get source layer LatLng.");
          t12 = i13.getBounds().getCenter();
        }
        return this.setLatLng(t12), this._map && this.update(), true;
      }, _updateContent: function() {
        if (this._content) {
          var t12 = this._contentNode, e18 = "function" == typeof this._content ? this._content(this._source || this) : this._content;
          if ("string" == typeof e18) t12.innerHTML = e18;
          else {
            for (; t12.hasChildNodes(); ) t12.removeChild(t12.firstChild);
            t12.appendChild(e18);
          }
          this.fire("contentupdate");
        }
      }, _updatePosition: function() {
        var t12, e18, i13;
        this._map && (e18 = this._map.latLngToLayerPoint(this._latlng), t12 = m42(this.options.offset), i13 = this._getAnchor(), this._zoomAnimated ? Z42(this._container, e18.add(i13)) : t12 = t12.add(e18).add(i13), e18 = this._containerBottom = -t12.y, i13 = this._containerLeft = -Math.round(this._containerWidth / 2) + t12.x, this._container.style.bottom = e18 + "px", this._container.style.left = i13 + "px");
      }, _getAnchor: function() {
        return [0, 0];
      } }), Bi = (A2.include({ _initOverlay: function(t12, e18, i13, n18) {
        var o16 = e18;
        return o16 instanceof t12 || (o16 = new t12(n18).setContent(e18)), i13 && o16.setLatLng(i13), o16;
      } }), o15.include({ _initOverlay: function(t12, e18, i13, n18) {
        var o16 = i13;
        return o16 instanceof t12 ? (c92(o16, n18), o16._source = this) : (o16 = e18 && !n18 ? e18 : new t12(n18, this)).setContent(i13), o16;
      } }), Ai.extend({ options: { pane: "popupPane", offset: [0, 7], maxWidth: 300, minWidth: 50, maxHeight: null, autoPan: true, autoPanPaddingTopLeft: null, autoPanPaddingBottomRight: null, autoPanPadding: [5, 5], keepInView: false, closeButton: true, autoClose: true, closeOnEscapeKey: true, className: "" }, openOn: function(t12) {
        return !(t12 = arguments.length ? t12 : this._source._map).hasLayer(this) && t12._popup && t12._popup.options.autoClose && t12.removeLayer(t12._popup), t12._popup = this, Ai.prototype.openOn.call(this, t12);
      }, onAdd: function(t12) {
        Ai.prototype.onAdd.call(this, t12), t12.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, true), this._source instanceof fi || this._source.on("preclick", Ae));
      }, onRemove: function(t12) {
        Ai.prototype.onRemove.call(this, t12), t12.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, true), this._source instanceof fi || this._source.off("preclick", Ae));
      }, getEvents: function() {
        var t12 = Ai.prototype.getEvents.call(this);
        return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t12.preclick = this.close), this.options.keepInView && (t12.moveend = this._adjustPan), t12;
      }, _initLayout: function() {
        var t12 = "leaflet-popup", e18 = this._container = P42("div", t12 + " " + (this.options.className || "") + " leaflet-zoom-animated"), i13 = this._wrapper = P42("div", t12 + "-content-wrapper", e18);
        this._contentNode = P42("div", t12 + "-content", i13), Ie(e18), Be(this._contentNode), S72(e18, "contextmenu", Ae), this._tipContainer = P42("div", t12 + "-tip-container", e18), this._tip = P42("div", t12 + "-tip", this._tipContainer), this.options.closeButton && ((i13 = this._closeButton = P42("a", t12 + "-close-button", e18)).setAttribute("role", "button"), i13.setAttribute("aria-label", "Close popup"), i13.href = "#close", i13.innerHTML = '<span aria-hidden="true">&#215;</span>', S72(i13, "click", function(t13) {
          O32(t13), this.close();
        }, this));
      }, _updateLayout: function() {
        var t12 = this._contentNode, e18 = t12.style, i13 = (e18.width = "", e18.whiteSpace = "nowrap", t12.offsetWidth), i13 = Math.min(i13, this.options.maxWidth), i13 = (i13 = Math.max(i13, this.options.minWidth), e18.width = i13 + 1 + "px", e18.whiteSpace = "", e18.height = "", t12.offsetHeight), n18 = this.options.maxHeight, o16 = "leaflet-popup-scrolled";
        (n18 && n18 < i13 ? (e18.height = n18 + "px", M42) : z42)(t12, o16), this._containerWidth = this._container.offsetWidth;
      }, _animateZoom: function(t12) {
        var t12 = this._map._latLngToNewLayerPoint(this._latlng, t12.zoom, t12.center), e18 = this._getAnchor();
        Z42(this._container, t12.add(e18));
      }, _adjustPan: function() {
        var t12, e18, i13, n18, o16, s10, r12, a8;
        this.options.autoPan && (this._map._panAnim && this._map._panAnim.stop(), this._autopanning ? this._autopanning = false : (t12 = this._map, e18 = parseInt(pe(this._container, "marginBottom"), 10) || 0, e18 = this._container.offsetHeight + e18, a8 = this._containerWidth, (i13 = new p42(this._containerLeft, -e18 - this._containerBottom))._add(Pe(this._container)), i13 = t12.layerPointToContainerPoint(i13), o16 = m42(this.options.autoPanPadding), n18 = m42(this.options.autoPanPaddingTopLeft || o16), o16 = m42(this.options.autoPanPaddingBottomRight || o16), s10 = t12.getSize(), r12 = 0, i13.x + a8 + o16.x > s10.x && (r12 = i13.x + a8 - s10.x + o16.x), i13.x - r12 - n18.x < (a8 = 0) && (r12 = i13.x - n18.x), i13.y + e18 + o16.y > s10.y && (a8 = i13.y + e18 - s10.y + o16.y), i13.y - a8 - n18.y < 0 && (a8 = i13.y - n18.y), (r12 || a8) && (this.options.keepInView && (this._autopanning = true), t12.fire("autopanstart").panBy([r12, a8]))));
      }, _getAnchor: function() {
        return m42(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      } })), Ii = (A2.mergeOptions({ closePopupOnClick: true }), A2.include({ openPopup: function(t12, e18, i13) {
        return this._initOverlay(Bi, t12, e18, i13).openOn(this), this;
      }, closePopup: function(t12) {
        return (t12 = arguments.length ? t12 : this._popup) && t12.close(), this;
      } }), o15.include({ bindPopup: function(t12, e18) {
        return this._popup = this._initOverlay(Bi, this._popup, t12, e18), this._popupHandlersAdded || (this.on({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = true), this;
      }, unbindPopup: function() {
        return this._popup && (this.off({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = false, this._popup = null), this;
      }, openPopup: function(t12) {
        return this._popup && (this instanceof ci || (this._popup._source = this), this._popup._prepareOpen(t12 || this._latlng) && this._popup.openOn(this._map)), this;
      }, closePopup: function() {
        return this._popup && this._popup.close(), this;
      }, togglePopup: function() {
        return this._popup && this._popup.toggle(this), this;
      }, isPopupOpen: function() {
        return !!this._popup && this._popup.isOpen();
      }, setPopupContent: function(t12) {
        return this._popup && this._popup.setContent(t12), this;
      }, getPopup: function() {
        return this._popup;
      }, _openPopup: function(t12) {
        var e18;
        this._popup && this._map && (Re32(t12), e18 = t12.layer || t12.target, this._popup._source !== e18 || e18 instanceof fi ? (this._popup._source = e18, this.openPopup(t12.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t12.latlng));
      }, _movePopup: function(t12) {
        this._popup.setLatLng(t12.latlng);
      }, _onKeyPress: function(t12) {
        13 === t12.originalEvent.keyCode && this._openPopup(t12);
      } }), Ai.extend({ options: { pane: "tooltipPane", offset: [0, 0], direction: "auto", permanent: false, sticky: false, opacity: 0.9 }, onAdd: function(t12) {
        Ai.prototype.onAdd.call(this, t12), this.setOpacity(this.options.opacity), t12.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, true));
      }, onRemove: function(t12) {
        Ai.prototype.onRemove.call(this, t12), t12.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, true));
      }, getEvents: function() {
        var t12 = Ai.prototype.getEvents.call(this);
        return this.options.permanent || (t12.preclick = this.close), t12;
      }, _initLayout: function() {
        var t12 = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = P42("div", t12), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + h92(this));
      }, _updateLayout: function() {
      }, _adjustPan: function() {
      }, _setPosition: function(t12) {
        var e18, i13 = this._map, n18 = this._container, o16 = i13.latLngToContainerPoint(i13.getCenter()), i13 = i13.layerPointToContainerPoint(t12), s10 = this.options.direction, r12 = n18.offsetWidth, a8 = n18.offsetHeight, h10 = m42(this.options.offset), l12 = this._getAnchor(), i13 = "top" === s10 ? (e18 = r12 / 2, a8) : "bottom" === s10 ? (e18 = r12 / 2, 0) : (e18 = "center" === s10 ? r12 / 2 : "right" === s10 ? 0 : "left" === s10 ? r12 : i13.x < o16.x ? (s10 = "right", 0) : (s10 = "left", r12 + 2 * (h10.x + l12.x)), a8 / 2);
        t12 = t12.subtract(m42(e18, i13, true)).add(h10).add(l12), z42(n18, "leaflet-tooltip-right"), z42(n18, "leaflet-tooltip-left"), z42(n18, "leaflet-tooltip-top"), z42(n18, "leaflet-tooltip-bottom"), M42(n18, "leaflet-tooltip-" + s10), Z42(n18, t12);
      }, _updatePosition: function() {
        var t12 = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(t12);
      }, setOpacity: function(t12) {
        this.options.opacity = t12, this._container && C2(this._container, t12);
      }, _animateZoom: function(t12) {
        t12 = this._map._latLngToNewLayerPoint(this._latlng, t12.zoom, t12.center);
        this._setPosition(t12);
      }, _getAnchor: function() {
        return m42(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      } })), Ri = (A2.include({ openTooltip: function(t12, e18, i13) {
        return this._initOverlay(Ii, t12, e18, i13).openOn(this), this;
      }, closeTooltip: function(t12) {
        return t12.close(), this;
      } }), o15.include({ bindTooltip: function(t12, e18) {
        return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ii, this._tooltip, t12, e18), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
      }, unbindTooltip: function() {
        return this._tooltip && (this._initTooltipInteractions(true), this.closeTooltip(), this._tooltip = null), this;
      }, _initTooltipInteractions: function(t12) {
        var e18, i13;
        !t12 && this._tooltipHandlersAdded || (e18 = t12 ? "off" : "on", i13 = { remove: this.closeTooltip, move: this._moveTooltip }, this._tooltip.options.permanent ? i13.add = this._openTooltip : (i13.mouseover = this._openTooltip, i13.mouseout = this.closeTooltip, i13.click = this._openTooltip, this._map ? this._addFocusListeners() : i13.add = this._addFocusListeners), this._tooltip.options.sticky && (i13.mousemove = this._moveTooltip), this[e18](i13), this._tooltipHandlersAdded = !t12);
      }, openTooltip: function(t12) {
        return this._tooltip && (this instanceof ci || (this._tooltip._source = this), this._tooltip._prepareOpen(t12) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
      }, closeTooltip: function() {
        if (this._tooltip) return this._tooltip.close();
      }, toggleTooltip: function() {
        return this._tooltip && this._tooltip.toggle(this), this;
      }, isTooltipOpen: function() {
        return this._tooltip.isOpen();
      }, setTooltipContent: function(t12) {
        return this._tooltip && this._tooltip.setContent(t12), this;
      }, getTooltip: function() {
        return this._tooltip;
      }, _addFocusListeners: function() {
        this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
      }, _addFocusListenersOnLayer: function(t12) {
        var e18 = "function" == typeof t12.getElement && t12.getElement();
        e18 && (S72(e18, "focus", function() {
          this._tooltip._source = t12, this.openTooltip();
        }, this), S72(e18, "blur", this.closeTooltip, this));
      }, _setAriaDescribedByOnLayer: function(t12) {
        t12 = "function" == typeof t12.getElement && t12.getElement();
        t12 && t12.setAttribute("aria-describedby", this._tooltip._container.id);
      }, _openTooltip: function(t12) {
        var e18;
        this._tooltip && this._map && (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag ? (this._openOnceFlag = true, (e18 = this)._map.once("moveend", function() {
          e18._openOnceFlag = false, e18._openTooltip(t12);
        })) : (this._tooltip._source = t12.layer || t12.target, this.openTooltip(this._tooltip.options.sticky ? t12.latlng : void 0)));
      }, _moveTooltip: function(t12) {
        var e18 = t12.latlng;
        this._tooltip.options.sticky && t12.originalEvent && (t12 = this._map.mouseEventToContainerPoint(t12.originalEvent), t12 = this._map.containerPointToLayerPoint(t12), e18 = this._map.layerPointToLatLng(t12)), this._tooltip.setLatLng(e18);
      } }), di.extend({ options: { iconSize: [12, 12], html: false, bgPos: null, className: "leaflet-div-icon" }, createIcon: function(t12) {
        var t12 = t12 && "DIV" === t12.tagName ? t12 : document.createElement("div"), e18 = this.options;
        return e18.html instanceof Element ? (me(t12), t12.appendChild(e18.html)) : t12.innerHTML = false !== e18.html ? e18.html : "", e18.bgPos && (e18 = m42(e18.bgPos), t12.style.backgroundPosition = -e18.x + "px " + -e18.y + "px"), this._setIconStyles(t12, "icon"), t12;
      }, createShadow: function() {
        return null;
      } }));
      di.Default = _i;
      var Ni = o15.extend({ options: { tileSize: 256, opacity: 1, updateWhenIdle: b42.mobile, updateWhenZooming: true, updateInterval: 200, zIndex: 1, bounds: null, minZoom: 0, maxZoom: void 0, maxNativeZoom: void 0, minNativeZoom: void 0, noWrap: false, pane: "tilePane", className: "", keepBuffer: 2 }, initialize: function(t12) {
        c92(this, t12);
      }, onAdd: function() {
        this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
      }, beforeAdd: function(t12) {
        t12._addZoomLimit(this);
      }, onRemove: function(t12) {
        this._removeAllTiles(), T42(this._container), t12._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
      }, bringToFront: function() {
        return this._map && (fe(this._container), this._setAutoZIndex(Math.max)), this;
      }, bringToBack: function() {
        return this._map && (ge(this._container), this._setAutoZIndex(Math.min)), this;
      }, getContainer: function() {
        return this._container;
      }, setOpacity: function(t12) {
        return this.options.opacity = t12, this._updateOpacity(), this;
      }, setZIndex: function(t12) {
        return this.options.zIndex = t12, this._updateZIndex(), this;
      }, isLoading: function() {
        return this._loading;
      }, redraw: function() {
        var t12;
        return this._map && (this._removeAllTiles(), (t12 = this._clampZoom(this._map.getZoom())) !== this._tileZoom && (this._tileZoom = t12, this._updateLevels()), this._update()), this;
      }, getEvents: function() {
        var t12 = { viewprereset: this._invalidateAll, viewreset: this._resetView, zoom: this._resetView, moveend: this._onMoveEnd };
        return this.options.updateWhenIdle || (this._onMove || (this._onMove = j42(this._onMoveEnd, this.options.updateInterval, this)), t12.move = this._onMove), this._zoomAnimated && (t12.zoomanim = this._animateZoom), t12;
      }, createTile: function() {
        return document.createElement("div");
      }, getTileSize: function() {
        var t12 = this.options.tileSize;
        return t12 instanceof p42 ? t12 : new p42(t12, t12);
      }, _updateZIndex: function() {
        this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex);
      }, _setAutoZIndex: function(t12) {
        for (var e18, i13 = this.getPane().children, n18 = -t12(-1 / 0, 1 / 0), o16 = 0, s10 = i13.length; o16 < s10; o16++) e18 = i13[o16].style.zIndex, i13[o16] !== this._container && e18 && (n18 = t12(n18, +e18));
        isFinite(n18) && (this.options.zIndex = n18 + t12(-1, 1), this._updateZIndex());
      }, _updateOpacity: function() {
        if (this._map && !b42.ielt9) {
          C2(this._container, this.options.opacity);
          var t12, e18 = +/* @__PURE__ */ new Date(), i13 = false, n18 = false;
          for (t12 in this._tiles) {
            var o16, s10 = this._tiles[t12];
            s10.current && s10.loaded && (o16 = Math.min(1, (e18 - s10.loaded) / 200), C2(s10.el, o16), o16 < 1 ? i13 = true : (s10.active ? n18 = true : this._onOpaqueTile(s10), s10.active = true));
          }
          n18 && !this._noPrune && this._pruneTiles(), i13 && (r112(this._fadeFrame), this._fadeFrame = x52(this._updateOpacity, this));
        }
      }, _onOpaqueTile: u62, _initContainer: function() {
        this._container || (this._container = P42("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
      }, _updateLevels: function() {
        var t12 = this._tileZoom, e18 = this.options.maxZoom;
        if (void 0 !== t12) {
          for (var i13 in this._levels) i13 = Number(i13), this._levels[i13].el.children.length || i13 === t12 ? (this._levels[i13].el.style.zIndex = e18 - Math.abs(t12 - i13), this._onUpdateLevel(i13)) : (T42(this._levels[i13].el), this._removeTilesAtZoom(i13), this._onRemoveLevel(i13), delete this._levels[i13]);
          var n18 = this._levels[t12], o16 = this._map;
          return n18 || ((n18 = this._levels[t12] = {}).el = P42("div", "leaflet-tile-container leaflet-zoom-animated", this._container), n18.el.style.zIndex = e18, n18.origin = o16.project(o16.unproject(o16.getPixelOrigin()), t12).round(), n18.zoom = t12, this._setZoomTransform(n18, o16.getCenter(), o16.getZoom()), u62(n18.el.offsetWidth), this._onCreateLevel(n18)), this._level = n18;
        }
      }, _onUpdateLevel: u62, _onRemoveLevel: u62, _onCreateLevel: u62, _pruneTiles: function() {
        if (this._map) {
          var t12, e18, i13, n18 = this._map.getZoom();
          if (n18 > this.options.maxZoom || n18 < this.options.minZoom) this._removeAllTiles();
          else {
            for (t12 in this._tiles) (i13 = this._tiles[t12]).retain = i13.current;
            for (t12 in this._tiles) (i13 = this._tiles[t12]).current && !i13.active && (e18 = i13.coords, this._retainParent(e18.x, e18.y, e18.z, e18.z - 5) || this._retainChildren(e18.x, e18.y, e18.z, e18.z + 2));
            for (t12 in this._tiles) this._tiles[t12].retain || this._removeTile(t12);
          }
        }
      }, _removeTilesAtZoom: function(t12) {
        for (var e18 in this._tiles) this._tiles[e18].coords.z === t12 && this._removeTile(e18);
      }, _removeAllTiles: function() {
        for (var t12 in this._tiles) this._removeTile(t12);
      }, _invalidateAll: function() {
        for (var t12 in this._levels) T42(this._levels[t12].el), this._onRemoveLevel(Number(t12)), delete this._levels[t12];
        this._removeAllTiles(), this._tileZoom = void 0;
      }, _retainParent: function(t12, e18, i13, n18) {
        var t12 = Math.floor(t12 / 2), e18 = Math.floor(e18 / 2), i13 = i13 - 1, o16 = new p42(+t12, +e18), o16 = (o16.z = i13, this._tileCoordsToKey(o16)), o16 = this._tiles[o16];
        return o16 && o16.active ? o16.retain = true : (o16 && o16.loaded && (o16.retain = true), n18 < i13 && this._retainParent(t12, e18, i13, n18));
      }, _retainChildren: function(t12, e18, i13, n18) {
        for (var o16 = 2 * t12; o16 < 2 * t12 + 2; o16++) for (var s10 = 2 * e18; s10 < 2 * e18 + 2; s10++) {
          var r12 = new p42(o16, s10), r12 = (r12.z = i13 + 1, this._tileCoordsToKey(r12)), r12 = this._tiles[r12];
          r12 && r12.active ? r12.retain = true : (r12 && r12.loaded && (r12.retain = true), i13 + 1 < n18 && this._retainChildren(o16, s10, i13 + 1, n18));
        }
      }, _resetView: function(t12) {
        t12 = t12 && (t12.pinch || t12.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), t12, t12);
      }, _animateZoom: function(t12) {
        this._setView(t12.center, t12.zoom, true, t12.noUpdate);
      }, _clampZoom: function(t12) {
        var e18 = this.options;
        return void 0 !== e18.minNativeZoom && t12 < e18.minNativeZoom ? e18.minNativeZoom : void 0 !== e18.maxNativeZoom && e18.maxNativeZoom < t12 ? e18.maxNativeZoom : t12;
      }, _setView: function(t12, e18, i13, n18) {
        var o16 = Math.round(e18), o16 = void 0 !== this.options.maxZoom && o16 > this.options.maxZoom || void 0 !== this.options.minZoom && o16 < this.options.minZoom ? void 0 : this._clampZoom(o16), s10 = this.options.updateWhenZooming && o16 !== this._tileZoom;
        n18 && !s10 || (this._tileZoom = o16, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o16 && this._update(t12), i13 || this._pruneTiles(), this._noPrune = !!i13), this._setZoomTransforms(t12, e18);
      }, _setZoomTransforms: function(t12, e18) {
        for (var i13 in this._levels) this._setZoomTransform(this._levels[i13], t12, e18);
      }, _setZoomTransform: function(t12, e18, i13) {
        var n18 = this._map.getZoomScale(i13, t12.zoom), e18 = t12.origin.multiplyBy(n18).subtract(this._map._getNewPixelOrigin(e18, i13)).round();
        b42.any3d ? be(t12.el, e18, n18) : Z42(t12.el, e18);
      }, _resetGrid: function() {
        var t12 = this._map, e18 = t12.options.crs, i13 = this._tileSize = this.getTileSize(), n18 = this._tileZoom, o16 = this._map.getPixelWorldBounds(this._tileZoom);
        o16 && (this._globalTileRange = this._pxBoundsToTileRange(o16)), this._wrapX = e18.wrapLng && !this.options.noWrap && [Math.floor(t12.project([0, e18.wrapLng[0]], n18).x / i13.x), Math.ceil(t12.project([0, e18.wrapLng[1]], n18).x / i13.y)], this._wrapY = e18.wrapLat && !this.options.noWrap && [Math.floor(t12.project([e18.wrapLat[0], 0], n18).y / i13.x), Math.ceil(t12.project([e18.wrapLat[1], 0], n18).y / i13.y)];
      }, _onMoveEnd: function() {
        this._map && !this._map._animatingZoom && this._update();
      }, _getTiledPixelBounds: function(t12) {
        var e18 = this._map, i13 = e18._animatingZoom ? Math.max(e18._animateToZoom, e18.getZoom()) : e18.getZoom(), i13 = e18.getZoomScale(i13, this._tileZoom), t12 = e18.project(t12, this._tileZoom).floor(), e18 = e18.getSize().divideBy(2 * i13);
        return new f82(t12.subtract(e18), t12.add(e18));
      }, _update: function(t12) {
        var e18 = this._map;
        if (e18) {
          var i13 = this._clampZoom(e18.getZoom());
          if (void 0 === t12 && (t12 = e18.getCenter()), void 0 !== this._tileZoom) {
            var n18, e18 = this._getTiledPixelBounds(t12), o16 = this._pxBoundsToTileRange(e18), s10 = o16.getCenter(), r12 = [], e18 = this.options.keepBuffer, a8 = new f82(o16.getBottomLeft().subtract([e18, -e18]), o16.getTopRight().add([e18, -e18]));
            if (!(isFinite(o16.min.x) && isFinite(o16.min.y) && isFinite(o16.max.x) && isFinite(o16.max.y))) throw new Error("Attempted to load an infinite number of tiles");
            for (n18 in this._tiles) {
              var h10 = this._tiles[n18].coords;
              h10.z === this._tileZoom && a8.contains(new p42(h10.x, h10.y)) || (this._tiles[n18].current = false);
            }
            if (1 < Math.abs(i13 - this._tileZoom)) this._setView(t12, i13);
            else {
              for (var l12 = o16.min.y; l12 <= o16.max.y; l12++) for (var u72 = o16.min.x; u72 <= o16.max.x; u72++) {
                var c10, d62 = new p42(u72, l12);
                d62.z = this._tileZoom, this._isValidTile(d62) && ((c10 = this._tiles[this._tileCoordsToKey(d62)]) ? c10.current = true : r12.push(d62));
              }
              if (r12.sort(function(t13, e19) {
                return t13.distanceTo(s10) - e19.distanceTo(s10);
              }), 0 !== r12.length) {
                this._loading || (this._loading = true, this.fire("loading"));
                for (var _52 = document.createDocumentFragment(), u72 = 0; u72 < r12.length; u72++) this._addTile(r12[u72], _52);
                this._level.el.appendChild(_52);
              }
            }
          }
        }
      }, _isValidTile: function(t12) {
        var e18 = this._map.options.crs;
        if (!e18.infinite) {
          var i13 = this._globalTileRange;
          if (!e18.wrapLng && (t12.x < i13.min.x || t12.x > i13.max.x) || !e18.wrapLat && (t12.y < i13.min.y || t12.y > i13.max.y)) return false;
        }
        return !this.options.bounds || (e18 = this._tileCoordsToBounds(t12), g42(this.options.bounds).overlaps(e18));
      }, _keyToBounds: function(t12) {
        return this._tileCoordsToBounds(this._keyToTileCoords(t12));
      }, _tileCoordsToNwSe: function(t12) {
        var e18 = this._map, i13 = this.getTileSize(), n18 = t12.scaleBy(i13), i13 = n18.add(i13);
        return [e18.unproject(n18, t12.z), e18.unproject(i13, t12.z)];
      }, _tileCoordsToBounds: function(t12) {
        t12 = this._tileCoordsToNwSe(t12), t12 = new s9(t12[0], t12[1]);
        return t12 = this.options.noWrap ? t12 : this._map.wrapLatLngBounds(t12);
      }, _tileCoordsToKey: function(t12) {
        return t12.x + ":" + t12.y + ":" + t12.z;
      }, _keyToTileCoords: function(t12) {
        var t12 = t12.split(":"), e18 = new p42(+t12[0], +t12[1]);
        return e18.z = +t12[2], e18;
      }, _removeTile: function(t12) {
        var e18 = this._tiles[t12];
        e18 && (T42(e18.el), delete this._tiles[t12], this.fire("tileunload", { tile: e18.el, coords: this._keyToTileCoords(t12) }));
      }, _initTile: function(t12) {
        M42(t12, "leaflet-tile");
        var e18 = this.getTileSize();
        t12.style.width = e18.x + "px", t12.style.height = e18.y + "px", t12.onselectstart = u62, t12.onmousemove = u62, b42.ielt9 && this.options.opacity < 1 && C2(t12, this.options.opacity);
      }, _addTile: function(t12, e18) {
        var i13 = this._getTilePos(t12), n18 = this._tileCoordsToKey(t12), o16 = this.createTile(this._wrapCoords(t12), a72(this._tileReady, this, t12));
        this._initTile(o16), this.createTile.length < 2 && x52(a72(this._tileReady, this, t12, null, o16)), Z42(o16, i13), this._tiles[n18] = { el: o16, coords: t12, current: true }, e18.appendChild(o16), this.fire("tileloadstart", { tile: o16, coords: t12 });
      }, _tileReady: function(t12, e18, i13) {
        e18 && this.fire("tileerror", { error: e18, tile: i13, coords: t12 });
        var n18 = this._tileCoordsToKey(t12);
        (i13 = this._tiles[n18]) && (i13.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (C2(i13.el, 0), r112(this._fadeFrame), this._fadeFrame = x52(this._updateOpacity, this)) : (i13.active = true, this._pruneTiles()), e18 || (M42(i13.el, "leaflet-tile-loaded"), this.fire("tileload", { tile: i13.el, coords: t12 })), this._noTilesToLoad() && (this._loading = false, this.fire("load"), b42.ielt9 || !this._map._fadeAnimated ? x52(this._pruneTiles, this) : setTimeout(a72(this._pruneTiles, this), 250)));
      }, _getTilePos: function(t12) {
        return t12.scaleBy(this.getTileSize()).subtract(this._level.origin);
      }, _wrapCoords: function(t12) {
        var e18 = new p42(this._wrapX ? H2(t12.x, this._wrapX) : t12.x, this._wrapY ? H2(t12.y, this._wrapY) : t12.y);
        return e18.z = t12.z, e18;
      }, _pxBoundsToTileRange: function(t12) {
        var e18 = this.getTileSize();
        return new f82(t12.min.unscaleBy(e18).floor(), t12.max.unscaleBy(e18).ceil().subtract([1, 1]));
      }, _noTilesToLoad: function() {
        for (var t12 in this._tiles) if (!this._tiles[t12].loaded) return false;
        return true;
      } });
      var Di = Ni.extend({ options: { minZoom: 0, maxZoom: 18, subdomains: "abc", errorTileUrl: "", zoomOffset: 0, tms: false, zoomReverse: false, detectRetina: false, crossOrigin: false, referrerPolicy: false }, initialize: function(t12, e18) {
        this._url = t12, (e18 = c92(this, e18)).detectRetina && b42.retina && 0 < e18.maxZoom ? (e18.tileSize = Math.floor(e18.tileSize / 2), e18.zoomReverse ? (e18.zoomOffset--, e18.minZoom = Math.min(e18.maxZoom, e18.minZoom + 1)) : (e18.zoomOffset++, e18.maxZoom = Math.max(e18.minZoom, e18.maxZoom - 1)), e18.minZoom = Math.max(0, e18.minZoom)) : e18.zoomReverse ? e18.minZoom = Math.min(e18.maxZoom, e18.minZoom) : e18.maxZoom = Math.max(e18.minZoom, e18.maxZoom), "string" == typeof e18.subdomains && (e18.subdomains = e18.subdomains.split("")), this.on("tileunload", this._onTileRemove);
      }, setUrl: function(t12, e18) {
        return this._url === t12 && void 0 === e18 && (e18 = true), this._url = t12, e18 || this.redraw(), this;
      }, createTile: function(t12, e18) {
        var i13 = document.createElement("img");
        return S72(i13, "load", a72(this._tileOnLoad, this, e18, i13)), S72(i13, "error", a72(this._tileOnError, this, e18, i13)), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i13.crossOrigin = true === this.options.crossOrigin ? "" : this.options.crossOrigin), "string" == typeof this.options.referrerPolicy && (i13.referrerPolicy = this.options.referrerPolicy), i13.alt = "", i13.src = this.getTileUrl(t12), i13;
      }, getTileUrl: function(t12) {
        var e18 = { r: b42.retina ? "@2x" : "", s: this._getSubdomain(t12), x: t12.x, y: t12.y, z: this._getZoomForUrl() };
        return this._map && !this._map.options.crs.infinite && (t12 = this._globalTileRange.max.y - t12.y, this.options.tms && (e18.y = t12), e18["-y"] = t12), q32(this._url, l11(e18, this.options));
      }, _tileOnLoad: function(t12, e18) {
        b42.ielt9 ? setTimeout(a72(t12, this, null, e18), 0) : t12(null, e18);
      }, _tileOnError: function(t12, e18, i13) {
        var n18 = this.options.errorTileUrl;
        n18 && e18.getAttribute("src") !== n18 && (e18.src = n18), t12(i13, e18);
      }, _onTileRemove: function(t12) {
        t12.tile.onload = null;
      }, _getZoomForUrl: function() {
        var t12 = this._tileZoom, e18 = this.options.maxZoom;
        return (t12 = this.options.zoomReverse ? e18 - t12 : t12) + this.options.zoomOffset;
      }, _getSubdomain: function(t12) {
        t12 = Math.abs(t12.x + t12.y) % this.options.subdomains.length;
        return this.options.subdomains[t12];
      }, _abortLoading: function() {
        var t12, e18, i13;
        for (t12 in this._tiles) this._tiles[t12].coords.z !== this._tileZoom && ((i13 = this._tiles[t12].el).onload = u62, i13.onerror = u62, i13.complete || (i13.src = K32, e18 = this._tiles[t12].coords, T42(i13), delete this._tiles[t12], this.fire("tileabort", { tile: i13, coords: e18 })));
      }, _removeTile: function(t12) {
        var e18 = this._tiles[t12];
        if (e18) return e18.el.setAttribute("src", K32), Ni.prototype._removeTile.call(this, t12);
      }, _tileReady: function(t12, e18, i13) {
        if (this._map && (!i13 || i13.getAttribute("src") !== K32)) return Ni.prototype._tileReady.call(this, t12, e18, i13);
      } });
      function ji(t12, e18) {
        return new Di(t12, e18);
      }
      var Hi = Di.extend({ defaultWmsParams: { service: "WMS", request: "GetMap", layers: "", styles: "", format: "image/jpeg", transparent: false, version: "1.1.1" }, options: { crs: null, uppercase: false }, initialize: function(t12, e18) {
        this._url = t12;
        var i13, n18 = l11({}, this.defaultWmsParams);
        for (i13 in e18) i13 in this.options || (n18[i13] = e18[i13]);
        var t12 = (e18 = c92(this, e18)).detectRetina && b42.retina ? 2 : 1, o16 = this.getTileSize();
        n18.width = o16.x * t12, n18.height = o16.y * t12, this.wmsParams = n18;
      }, onAdd: function(t12) {
        this._crs = this.options.crs || t12.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
        var e18 = 1.3 <= this._wmsVersion ? "crs" : "srs";
        this.wmsParams[e18] = this._crs.code, Di.prototype.onAdd.call(this, t12);
      }, getTileUrl: function(t12) {
        var e18 = this._tileCoordsToNwSe(t12), i13 = this._crs, i13 = _42(i13.project(e18[0]), i13.project(e18[1])), e18 = i13.min, i13 = i13.max, e18 = (1.3 <= this._wmsVersion && this._crs === li ? [e18.y, e18.x, i13.y, i13.x] : [e18.x, e18.y, i13.x, i13.y]).join(","), i13 = Di.prototype.getTileUrl.call(this, t12);
        return i13 + U32(this.wmsParams, i13, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + e18;
      }, setParams: function(t12, e18) {
        return l11(this.wmsParams, t12), e18 || this.redraw(), this;
      } });
      Di.WMS = Hi, ji.wms = function(t12, e18) {
        return new Hi(t12, e18);
      };
      var Wi = o15.extend({ options: { padding: 0.1 }, initialize: function(t12) {
        c92(this, t12), h92(this), this._layers = this._layers || {};
      }, onAdd: function() {
        this._container || (this._initContainer(), M42(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
      }, onRemove: function() {
        this.off("update", this._updatePaths, this), this._destroyContainer();
      }, getEvents: function() {
        var t12 = { viewreset: this._reset, zoom: this._onZoom, moveend: this._update, zoomend: this._onZoomEnd };
        return this._zoomAnimated && (t12.zoomanim = this._onAnimZoom), t12;
      }, _onAnimZoom: function(t12) {
        this._updateTransform(t12.center, t12.zoom);
      }, _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      }, _updateTransform: function(t12, e18) {
        var i13 = this._map.getZoomScale(e18, this._zoom), n18 = this._map.getSize().multiplyBy(0.5 + this.options.padding), o16 = this._map.project(this._center, e18), n18 = n18.multiplyBy(-i13).add(o16).subtract(this._map._getNewPixelOrigin(t12, e18));
        b42.any3d ? be(this._container, n18, i13) : Z42(this._container, n18);
      }, _reset: function() {
        for (var t12 in this._update(), this._updateTransform(this._center, this._zoom), this._layers) this._layers[t12]._reset();
      }, _onZoomEnd: function() {
        for (var t12 in this._layers) this._layers[t12]._project();
      }, _updatePaths: function() {
        for (var t12 in this._layers) this._layers[t12]._update();
      }, _update: function() {
        var t12 = this.options.padding, e18 = this._map.getSize(), i13 = this._map.containerPointToLayerPoint(e18.multiplyBy(-t12)).round();
        this._bounds = new f82(i13, i13.add(e18.multiplyBy(1 + 2 * t12)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
      } }), Fi = Wi.extend({ options: { tolerance: 0 }, getEvents: function() {
        var t12 = Wi.prototype.getEvents.call(this);
        return t12.viewprereset = this._onViewPreReset, t12;
      }, _onViewPreReset: function() {
        this._postponeUpdatePaths = true;
      }, onAdd: function() {
        Wi.prototype.onAdd.call(this), this._draw();
      }, _initContainer: function() {
        var t12 = this._container = document.createElement("canvas");
        S72(t12, "mousemove", this._onMouseMove, this), S72(t12, "click dblclick mousedown mouseup contextmenu", this._onClick, this), S72(t12, "mouseout", this._handleMouseOut, this), t12._leaflet_disable_events = true, this._ctx = t12.getContext("2d");
      }, _destroyContainer: function() {
        r112(this._redrawRequest), delete this._ctx, T42(this._container), k42(this._container), delete this._container;
      }, _updatePaths: function() {
        if (!this._postponeUpdatePaths) {
          for (var t12 in this._redrawBounds = null, this._layers) this._layers[t12]._update();
          this._redraw();
        }
      }, _update: function() {
        var t12, e18, i13, n18;
        this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this), t12 = this._bounds, e18 = this._container, i13 = t12.getSize(), n18 = b42.retina ? 2 : 1, Z42(e18, t12.min), e18.width = n18 * i13.x, e18.height = n18 * i13.y, e18.style.width = i13.x + "px", e18.style.height = i13.y + "px", b42.retina && this._ctx.scale(2, 2), this._ctx.translate(-t12.min.x, -t12.min.y), this.fire("update"));
      }, _reset: function() {
        Wi.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = false, this._updatePaths());
      }, _initPath: function(t12) {
        this._updateDashArray(t12);
        t12 = (this._layers[h92(t12)] = t12)._order = { layer: t12, prev: this._drawLast, next: null };
        this._drawLast && (this._drawLast.next = t12), this._drawLast = t12, this._drawFirst = this._drawFirst || this._drawLast;
      }, _addPath: function(t12) {
        this._requestRedraw(t12);
      }, _removePath: function(t12) {
        var e18 = t12._order, i13 = e18.next, e18 = e18.prev;
        i13 ? i13.prev = e18 : this._drawLast = e18, e18 ? e18.next = i13 : this._drawFirst = i13, delete t12._order, delete this._layers[h92(t12)], this._requestRedraw(t12);
      }, _updatePath: function(t12) {
        this._extendRedrawBounds(t12), t12._project(), t12._update(), this._requestRedraw(t12);
      }, _updateStyle: function(t12) {
        this._updateDashArray(t12), this._requestRedraw(t12);
      }, _updateDashArray: function(t12) {
        if ("string" == typeof t12.options.dashArray) {
          for (var e18, i13 = t12.options.dashArray.split(/[, ]+/), n18 = [], o16 = 0; o16 < i13.length; o16++) {
            if (e18 = Number(i13[o16]), isNaN(e18)) return;
            n18.push(e18);
          }
          t12.options._dashArray = n18;
        } else t12.options._dashArray = t12.options.dashArray;
      }, _requestRedraw: function(t12) {
        this._map && (this._extendRedrawBounds(t12), this._redrawRequest = this._redrawRequest || x52(this._redraw, this));
      }, _extendRedrawBounds: function(t12) {
        var e18;
        t12._pxBounds && (e18 = (t12.options.weight || 0) + 1, this._redrawBounds = this._redrawBounds || new f82(), this._redrawBounds.extend(t12._pxBounds.min.subtract([e18, e18])), this._redrawBounds.extend(t12._pxBounds.max.add([e18, e18])));
      }, _redraw: function() {
        this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
      }, _clear: function() {
        var t12, e18 = this._redrawBounds;
        e18 ? (t12 = e18.getSize(), this._ctx.clearRect(e18.min.x, e18.min.y, t12.x, t12.y)) : (this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore());
      }, _draw: function() {
        var t12, e18, i13 = this._redrawBounds;
        this._ctx.save(), i13 && (e18 = i13.getSize(), this._ctx.beginPath(), this._ctx.rect(i13.min.x, i13.min.y, e18.x, e18.y), this._ctx.clip()), this._drawing = true;
        for (var n18 = this._drawFirst; n18; n18 = n18.next) t12 = n18.layer, (!i13 || t12._pxBounds && t12._pxBounds.intersects(i13)) && t12._updatePath();
        this._drawing = false, this._ctx.restore();
      }, _updatePoly: function(t12, e18) {
        if (this._drawing) {
          var i13, n18, o16, s10, r12 = t12._parts, a8 = r12.length, h10 = this._ctx;
          if (a8) {
            for (h10.beginPath(), i13 = 0; i13 < a8; i13++) {
              for (n18 = 0, o16 = r12[i13].length; n18 < o16; n18++) s10 = r12[i13][n18], h10[n18 ? "lineTo" : "moveTo"](s10.x, s10.y);
              e18 && h10.closePath();
            }
            this._fillStroke(h10, t12);
          }
        }
      }, _updateCircle: function(t12) {
        var e18, i13, n18, o16;
        this._drawing && !t12._empty() && (e18 = t12._point, i13 = this._ctx, n18 = Math.max(Math.round(t12._radius), 1), 1 != (o16 = (Math.max(Math.round(t12._radiusY), 1) || n18) / n18) && (i13.save(), i13.scale(1, o16)), i13.beginPath(), i13.arc(e18.x, e18.y / o16, n18, 0, 2 * Math.PI, false), 1 != o16 && i13.restore(), this._fillStroke(i13, t12));
      }, _fillStroke: function(t12, e18) {
        var i13 = e18.options;
        i13.fill && (t12.globalAlpha = i13.fillOpacity, t12.fillStyle = i13.fillColor || i13.color, t12.fill(i13.fillRule || "evenodd")), i13.stroke && 0 !== i13.weight && (t12.setLineDash && t12.setLineDash(e18.options && e18.options._dashArray || []), t12.globalAlpha = i13.opacity, t12.lineWidth = i13.weight, t12.strokeStyle = i13.color, t12.lineCap = i13.lineCap, t12.lineJoin = i13.lineJoin, t12.stroke());
      }, _onClick: function(t12) {
        for (var e18, i13, n18 = this._map.mouseEventToLayerPoint(t12), o16 = this._drawFirst; o16; o16 = o16.next) (e18 = o16.layer).options.interactive && e18._containsPoint(n18) && (("click" === t12.type || "preclick" === t12.type) && this._map._draggableMoved(e18) || (i13 = e18));
        this._fireEvent(!!i13 && [i13], t12);
      }, _onMouseMove: function(t12) {
        var e18;
        !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e18 = this._map.mouseEventToLayerPoint(t12), this._handleMouseHover(t12, e18));
      }, _handleMouseOut: function(t12) {
        var e18 = this._hoveredLayer;
        e18 && (z42(this._container, "leaflet-interactive"), this._fireEvent([e18], t12, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = false);
      }, _handleMouseHover: function(t12, e18) {
        if (!this._mouseHoverThrottled) {
          for (var i13, n18, o16 = this._drawFirst; o16; o16 = o16.next) (i13 = o16.layer).options.interactive && i13._containsPoint(e18) && (n18 = i13);
          n18 !== this._hoveredLayer && (this._handleMouseOut(t12), n18 && (M42(this._container, "leaflet-interactive"), this._fireEvent([n18], t12, "mouseover"), this._hoveredLayer = n18)), this._fireEvent(!!this._hoveredLayer && [this._hoveredLayer], t12), this._mouseHoverThrottled = true, setTimeout(a72(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        }
      }, _fireEvent: function(t12, e18, i13) {
        this._map._fireDOMEvent(e18, i13 || e18.type, t12);
      }, _bringToFront: function(t12) {
        var e18, i13, n18 = t12._order;
        n18 && (e18 = n18.next, i13 = n18.prev, e18 && ((e18.prev = i13) ? i13.next = e18 : e18 && (this._drawFirst = e18), n18.prev = this._drawLast, (this._drawLast.next = n18).next = null, this._drawLast = n18, this._requestRedraw(t12)));
      }, _bringToBack: function(t12) {
        var e18, i13, n18 = t12._order;
        n18 && (e18 = n18.next, (i13 = n18.prev) && ((i13.next = e18) ? e18.prev = i13 : i13 && (this._drawLast = i13), n18.prev = null, n18.next = this._drawFirst, this._drawFirst.prev = n18, this._drawFirst = n18, this._requestRedraw(t12)));
      } });
      function Ui(t12) {
        return b42.canvas ? new Fi(t12) : null;
      }
      var Vi = function() {
        try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(t12) {
            return document.createElement("<lvml:" + t12 + ' class="lvml">');
          };
        } catch (t12) {
        }
        return function(t12) {
          return document.createElement("<" + t12 + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }(), zt = { _initContainer: function() {
        this._container = P42("div", "leaflet-vml-container");
      }, _update: function() {
        this._map._animatingZoom || (Wi.prototype._update.call(this), this.fire("update"));
      }, _initPath: function(t12) {
        var e18 = t12._container = Vi("shape");
        M42(e18, "leaflet-vml-shape " + (this.options.className || "")), e18.coordsize = "1 1", t12._path = Vi("path"), e18.appendChild(t12._path), this._updateStyle(t12), this._layers[h92(t12)] = t12;
      }, _addPath: function(t12) {
        var e18 = t12._container;
        this._container.appendChild(e18), t12.options.interactive && t12.addInteractiveTarget(e18);
      }, _removePath: function(t12) {
        var e18 = t12._container;
        T42(e18), t12.removeInteractiveTarget(e18), delete this._layers[h92(t12)];
      }, _updateStyle: function(t12) {
        var e18 = t12._stroke, i13 = t12._fill, n18 = t12.options, o16 = t12._container;
        o16.stroked = !!n18.stroke, o16.filled = !!n18.fill, n18.stroke ? (e18 = e18 || (t12._stroke = Vi("stroke")), o16.appendChild(e18), e18.weight = n18.weight + "px", e18.color = n18.color, e18.opacity = n18.opacity, n18.dashArray ? e18.dashStyle = d52(n18.dashArray) ? n18.dashArray.join(" ") : n18.dashArray.replace(/( *, *)/g, " ") : e18.dashStyle = "", e18.endcap = n18.lineCap.replace("butt", "flat"), e18.joinstyle = n18.lineJoin) : e18 && (o16.removeChild(e18), t12._stroke = null), n18.fill ? (i13 = i13 || (t12._fill = Vi("fill")), o16.appendChild(i13), i13.color = n18.fillColor || n18.color, i13.opacity = n18.fillOpacity) : i13 && (o16.removeChild(i13), t12._fill = null);
      }, _updateCircle: function(t12) {
        var e18 = t12._point.round(), i13 = Math.round(t12._radius), n18 = Math.round(t12._radiusY || i13);
        this._setPath(t12, t12._empty() ? "M0 0" : "AL " + e18.x + "," + e18.y + " " + i13 + "," + n18 + " 0,23592600");
      }, _setPath: function(t12, e18) {
        t12._path.v = e18;
      }, _bringToFront: function(t12) {
        fe(t12._container);
      }, _bringToBack: function(t12) {
        ge(t12._container);
      } }, qi = b42.vml ? Vi : ct, Gi = Wi.extend({ _initContainer: function() {
        this._container = qi("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = qi("g"), this._container.appendChild(this._rootGroup);
      }, _destroyContainer: function() {
        T42(this._container), k42(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
      }, _update: function() {
        var t12, e18, i13;
        this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this), e18 = (t12 = this._bounds).getSize(), i13 = this._container, this._svgSize && this._svgSize.equals(e18) || (this._svgSize = e18, i13.setAttribute("width", e18.x), i13.setAttribute("height", e18.y)), Z42(i13, t12.min), i13.setAttribute("viewBox", [t12.min.x, t12.min.y, e18.x, e18.y].join(" ")), this.fire("update"));
      }, _initPath: function(t12) {
        var e18 = t12._path = qi("path");
        t12.options.className && M42(e18, t12.options.className), t12.options.interactive && M42(e18, "leaflet-interactive"), this._updateStyle(t12), this._layers[h92(t12)] = t12;
      }, _addPath: function(t12) {
        this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t12._path), t12.addInteractiveTarget(t12._path);
      }, _removePath: function(t12) {
        T42(t12._path), t12.removeInteractiveTarget(t12._path), delete this._layers[h92(t12)];
      }, _updatePath: function(t12) {
        t12._project(), t12._update();
      }, _updateStyle: function(t12) {
        var e18 = t12._path, t12 = t12.options;
        e18 && (t12.stroke ? (e18.setAttribute("stroke", t12.color), e18.setAttribute("stroke-opacity", t12.opacity), e18.setAttribute("stroke-width", t12.weight), e18.setAttribute("stroke-linecap", t12.lineCap), e18.setAttribute("stroke-linejoin", t12.lineJoin), t12.dashArray ? e18.setAttribute("stroke-dasharray", t12.dashArray) : e18.removeAttribute("stroke-dasharray"), t12.dashOffset ? e18.setAttribute("stroke-dashoffset", t12.dashOffset) : e18.removeAttribute("stroke-dashoffset")) : e18.setAttribute("stroke", "none"), t12.fill ? (e18.setAttribute("fill", t12.fillColor || t12.color), e18.setAttribute("fill-opacity", t12.fillOpacity), e18.setAttribute("fill-rule", t12.fillRule || "evenodd")) : e18.setAttribute("fill", "none"));
      }, _updatePoly: function(t12, e18) {
        this._setPath(t12, dt3(t12._parts, e18));
      }, _updateCircle: function(t12) {
        var e18 = t12._point, i13 = Math.max(Math.round(t12._radius), 1), n18 = "a" + i13 + "," + (Math.max(Math.round(t12._radiusY), 1) || i13) + " 0 1,0 ", e18 = t12._empty() ? "M0 0" : "M" + (e18.x - i13) + "," + e18.y + n18 + 2 * i13 + ",0 " + n18 + 2 * -i13 + ",0 ";
        this._setPath(t12, e18);
      }, _setPath: function(t12, e18) {
        t12._path.setAttribute("d", e18);
      }, _bringToFront: function(t12) {
        fe(t12._path);
      }, _bringToBack: function(t12) {
        ge(t12._path);
      } });
      function Ki(t12) {
        return b42.svg || b42.vml ? new Gi(t12) : null;
      }
      b42.vml && Gi.include(zt), A2.include({ getRenderer: function(t12) {
        t12 = (t12 = t12.options.renderer || this._getPaneRenderer(t12.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer());
        return this.hasLayer(t12) || this.addLayer(t12), t12;
      }, _getPaneRenderer: function(t12) {
        var e18;
        return "overlayPane" !== t12 && void 0 !== t12 && (void 0 === (e18 = this._paneRenderers[t12]) && (e18 = this._createRenderer({ pane: t12 }), this._paneRenderers[t12] = e18), e18);
      }, _createRenderer: function(t12) {
        return this.options.preferCanvas && Ui(t12) || Ki(t12);
      } });
      var Yi = xi.extend({ initialize: function(t12, e18) {
        xi.prototype.initialize.call(this, this._boundsToLatLngs(t12), e18);
      }, setBounds: function(t12) {
        return this.setLatLngs(this._boundsToLatLngs(t12));
      }, _boundsToLatLngs: function(t12) {
        return [(t12 = g42(t12)).getSouthWest(), t12.getNorthWest(), t12.getNorthEast(), t12.getSouthEast()];
      } });
      Gi.create = qi, Gi.pointsToPath = dt3, wi.geometryToLayer = bi, wi.coordsToLatLng = Li, wi.coordsToLatLngs = Ti, wi.latLngToCoords = Mi, wi.latLngsToCoords = zi, wi.getFeature = Ci, wi.asFeature = Zi, A2.mergeOptions({ boxZoom: true });
      var _t2 = n17.extend({ initialize: function(t12) {
        this._map = t12, this._container = t12._container, this._pane = t12._panes.overlayPane, this._resetStateTimeout = 0, t12.on("unload", this._destroy, this);
      }, addHooks: function() {
        S72(this._container, "mousedown", this._onMouseDown, this);
      }, removeHooks: function() {
        k42(this._container, "mousedown", this._onMouseDown, this);
      }, moved: function() {
        return this._moved;
      }, _destroy: function() {
        T42(this._pane), delete this._pane;
      }, _resetState: function() {
        this._resetStateTimeout = 0, this._moved = false;
      }, _clearDeferredResetState: function() {
        0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
      }, _onMouseDown: function(t12) {
        if (!t12.shiftKey || 1 !== t12.which && 1 !== t12.button) return false;
        this._clearDeferredResetState(), this._resetState(), re(), Le(), this._startPoint = this._map.mouseEventToContainerPoint(t12), S72(document, { contextmenu: Re32, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this);
      }, _onMouseMove: function(t12) {
        this._moved || (this._moved = true, this._box = P42("div", "leaflet-zoom-box", this._container), M42(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t12);
        var t12 = new f82(this._point, this._startPoint), e18 = t12.getSize();
        Z42(this._box, t12.min), this._box.style.width = e18.x + "px", this._box.style.height = e18.y + "px";
      }, _finish: function() {
        this._moved && (T42(this._box), z42(this._container, "leaflet-crosshair")), ae(), Te4(), k42(document, { contextmenu: Re32, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this);
      }, _onMouseUp: function(t12) {
        1 !== t12.which && 1 !== t12.button || (this._finish(), this._moved && (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(a72(this._resetState, this), 0), t12 = new s9(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(t12).fire("boxzoomend", { boxZoomBounds: t12 })));
      }, _onKeyDown: function(t12) {
        27 === t12.keyCode && (this._finish(), this._clearDeferredResetState(), this._resetState());
      } }), Ct = (A2.addInitHook("addHandler", "boxZoom", _t2), A2.mergeOptions({ doubleClickZoom: true }), n17.extend({ addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      }, removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      }, _onDoubleClick: function(t12) {
        var e18 = this._map, i13 = e18.getZoom(), n18 = e18.options.zoomDelta, i13 = t12.originalEvent.shiftKey ? i13 - n18 : i13 + n18;
        "center" === e18.options.doubleClickZoom ? e18.setZoom(i13) : e18.setZoomAround(t12.containerPoint, i13);
      } })), Zt2 = (A2.addInitHook("addHandler", "doubleClickZoom", Ct), A2.mergeOptions({ dragging: true, inertia: true, inertiaDeceleration: 3400, inertiaMaxSpeed: 1 / 0, easeLinearity: 0.2, worldCopyJump: false, maxBoundsViscosity: 0 }), n17.extend({ addHooks: function() {
        var t12;
        this._draggable || (t12 = this._map, this._draggable = new Xe(t12._mapPane, t12._container), this._draggable.on({ dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t12.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t12.on("zoomend", this._onZoomEnd, this), t12.whenReady(this._onZoomEnd, this))), M42(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
      }, removeHooks: function() {
        z42(this._map._container, "leaflet-grab"), z42(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
      }, moved: function() {
        return this._draggable && this._draggable._moved;
      }, moving: function() {
        return this._draggable && this._draggable._moving;
      }, _onDragStart: function() {
        var t12, e18 = this._map;
        e18._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t12 = g42(this._map.options.maxBounds), this._offsetLimit = _42(this._map.latLngToContainerPoint(t12.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t12.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null, e18.fire("movestart").fire("dragstart"), e18.options.inertia && (this._positions = [], this._times = []);
      }, _onDrag: function(t12) {
        var e18, i13;
        this._map.options.inertia && (e18 = this._lastTime = +/* @__PURE__ */ new Date(), i13 = this._lastPos = this._draggable._absPos || this._draggable._newPos, this._positions.push(i13), this._times.push(e18), this._prunePositions(e18)), this._map.fire("move", t12).fire("drag", t12);
      }, _prunePositions: function(t12) {
        for (; 1 < this._positions.length && 50 < t12 - this._times[0]; ) this._positions.shift(), this._times.shift();
      }, _onZoomEnd: function() {
        var t12 = this._map.getSize().divideBy(2), e18 = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = e18.subtract(t12).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      }, _viscousLimit: function(t12, e18) {
        return t12 - (t12 - e18) * this._viscosity;
      }, _onPreDragLimit: function() {
        var t12, e18;
        this._viscosity && this._offsetLimit && (t12 = this._draggable._newPos.subtract(this._draggable._startPos), e18 = this._offsetLimit, t12.x < e18.min.x && (t12.x = this._viscousLimit(t12.x, e18.min.x)), t12.y < e18.min.y && (t12.y = this._viscousLimit(t12.y, e18.min.y)), t12.x > e18.max.x && (t12.x = this._viscousLimit(t12.x, e18.max.x)), t12.y > e18.max.y && (t12.y = this._viscousLimit(t12.y, e18.max.y)), this._draggable._newPos = this._draggable._startPos.add(t12));
      }, _onPreDragWrap: function() {
        var t12 = this._worldWidth, e18 = Math.round(t12 / 2), i13 = this._initialWorldOffset, n18 = this._draggable._newPos.x, o16 = (n18 - e18 + i13) % t12 + e18 - i13, n18 = (n18 + e18 + i13) % t12 - e18 - i13, t12 = Math.abs(o16 + i13) < Math.abs(n18 + i13) ? o16 : n18;
        this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = t12;
      }, _onDragEnd: function(t12) {
        var e18, i13, n18, o16, s10 = this._map, r12 = s10.options, a8 = !r12.inertia || t12.noInertia || this._times.length < 2;
        s10.fire("dragend", t12), !a8 && (this._prunePositions(+/* @__PURE__ */ new Date()), t12 = this._lastPos.subtract(this._positions[0]), a8 = (this._lastTime - this._times[0]) / 1e3, e18 = r12.easeLinearity, a8 = (t12 = t12.multiplyBy(e18 / a8)).distanceTo([0, 0]), i13 = Math.min(r12.inertiaMaxSpeed, a8), t12 = t12.multiplyBy(i13 / a8), n18 = i13 / (r12.inertiaDeceleration * e18), (o16 = t12.multiplyBy(-n18 / 2).round()).x || o16.y) ? (o16 = s10._limitOffset(o16, s10.options.maxBounds), x52(function() {
          s10.panBy(o16, { duration: n18, easeLinearity: e18, noMoveStart: true, animate: true });
        })) : s10.fire("moveend");
      } })), St = (A2.addInitHook("addHandler", "dragging", Zt2), A2.mergeOptions({ keyboard: true, keyboardPanDelta: 80 }), n17.extend({ keyCodes: { left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 54, 173] }, initialize: function(t12) {
        this._map = t12, this._setPanDelta(t12.options.keyboardPanDelta), this._setZoomDelta(t12.options.zoomDelta);
      }, addHooks: function() {
        var t12 = this._map._container;
        t12.tabIndex <= 0 && (t12.tabIndex = "0"), S72(t12, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this);
      }, removeHooks: function() {
        this._removeHooks(), k42(this._map._container, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this);
      }, _onMouseDown: function() {
        var t12, e18, i13;
        this._focused || (i13 = document.body, t12 = document.documentElement, e18 = i13.scrollTop || t12.scrollTop, i13 = i13.scrollLeft || t12.scrollLeft, this._map._container.focus(), window.scrollTo(i13, e18));
      }, _onFocus: function() {
        this._focused = true, this._map.fire("focus");
      }, _onBlur: function() {
        this._focused = false, this._map.fire("blur");
      }, _setPanDelta: function(t12) {
        for (var e18 = this._panKeys = {}, i13 = this.keyCodes, n18 = 0, o16 = i13.left.length; n18 < o16; n18++) e18[i13.left[n18]] = [-1 * t12, 0];
        for (n18 = 0, o16 = i13.right.length; n18 < o16; n18++) e18[i13.right[n18]] = [t12, 0];
        for (n18 = 0, o16 = i13.down.length; n18 < o16; n18++) e18[i13.down[n18]] = [0, t12];
        for (n18 = 0, o16 = i13.up.length; n18 < o16; n18++) e18[i13.up[n18]] = [0, -1 * t12];
      }, _setZoomDelta: function(t12) {
        for (var e18 = this._zoomKeys = {}, i13 = this.keyCodes, n18 = 0, o16 = i13.zoomIn.length; n18 < o16; n18++) e18[i13.zoomIn[n18]] = t12;
        for (n18 = 0, o16 = i13.zoomOut.length; n18 < o16; n18++) e18[i13.zoomOut[n18]] = -t12;
      }, _addHooks: function() {
        S72(document, "keydown", this._onKeyDown, this);
      }, _removeHooks: function() {
        k42(document, "keydown", this._onKeyDown, this);
      }, _onKeyDown: function(t12) {
        if (!(t12.altKey || t12.ctrlKey || t12.metaKey)) {
          var e18, i13, n18 = t12.keyCode, o16 = this._map;
          if (n18 in this._panKeys) o16._panAnim && o16._panAnim._inProgress || (i13 = this._panKeys[n18], t12.shiftKey && (i13 = m42(i13).multiplyBy(3)), o16.options.maxBounds && (i13 = o16._limitOffset(m42(i13), o16.options.maxBounds)), o16.options.worldCopyJump ? (e18 = o16.wrapLatLng(o16.unproject(o16.project(o16.getCenter()).add(i13))), o16.panTo(e18)) : o16.panBy(i13));
          else if (n18 in this._zoomKeys) o16.setZoom(o16.getZoom() + (t12.shiftKey ? 3 : 1) * this._zoomKeys[n18]);
          else {
            if (27 !== n18 || !o16._popup || !o16._popup.options.closeOnEscapeKey) return;
            o16.closePopup();
          }
          Re32(t12);
        }
      } })), Et = (A2.addInitHook("addHandler", "keyboard", St), A2.mergeOptions({ scrollWheelZoom: true, wheelDebounceTime: 40, wheelPxPerZoomLevel: 60 }), n17.extend({ addHooks: function() {
        S72(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
      }, removeHooks: function() {
        k42(this._map._container, "wheel", this._onWheelScroll, this);
      }, _onWheelScroll: function(t12) {
        var e18 = He(t12), i13 = this._map.options.wheelDebounceTime, e18 = (this._delta += e18, this._lastMousePos = this._map.mouseEventToContainerPoint(t12), this._startTime || (this._startTime = +/* @__PURE__ */ new Date()), Math.max(i13 - (+/* @__PURE__ */ new Date() - this._startTime), 0));
        clearTimeout(this._timer), this._timer = setTimeout(a72(this._performZoom, this), e18), Re32(t12);
      }, _performZoom: function() {
        var t12 = this._map, e18 = t12.getZoom(), i13 = this._map.options.zoomSnap || 0, n18 = (t12._stop(), this._delta / (4 * this._map.options.wheelPxPerZoomLevel)), n18 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n18)))) / Math.LN2, i13 = i13 ? Math.ceil(n18 / i13) * i13 : n18, n18 = t12._limitZoom(e18 + (0 < this._delta ? i13 : -i13)) - e18;
        this._delta = 0, this._startTime = null, n18 && ("center" === t12.options.scrollWheelZoom ? t12.setZoom(e18 + n18) : t12.setZoomAround(this._lastMousePos, e18 + n18));
      } })), kt = (A2.addInitHook("addHandler", "scrollWheelZoom", Et), A2.mergeOptions({ tapHold: b42.touchNative && b42.safari && b42.mobile, tapTolerance: 15 }), n17.extend({ addHooks: function() {
        S72(this._map._container, "touchstart", this._onDown, this);
      }, removeHooks: function() {
        k42(this._map._container, "touchstart", this._onDown, this);
      }, _onDown: function(t12) {
        var e18;
        clearTimeout(this._holdTimeout), 1 === t12.touches.length && (e18 = t12.touches[0], this._startPos = this._newPos = new p42(e18.clientX, e18.clientY), this._holdTimeout = setTimeout(a72(function() {
          this._cancel(), this._isTapValid() && (S72(document, "touchend", O32), S72(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", e18));
        }, this), 600), S72(document, "touchend touchcancel contextmenu", this._cancel, this), S72(document, "touchmove", this._onMove, this));
      }, _cancelClickPrevent: function t12() {
        k42(document, "touchend", O32), k42(document, "touchend touchcancel", t12);
      }, _cancel: function() {
        clearTimeout(this._holdTimeout), k42(document, "touchend touchcancel contextmenu", this._cancel, this), k42(document, "touchmove", this._onMove, this);
      }, _onMove: function(t12) {
        t12 = t12.touches[0];
        this._newPos = new p42(t12.clientX, t12.clientY);
      }, _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      }, _simulateEvent: function(t12, e18) {
        t12 = new MouseEvent(t12, { bubbles: true, cancelable: true, view: window, screenX: e18.screenX, screenY: e18.screenY, clientX: e18.clientX, clientY: e18.clientY });
        t12._simulated = true, e18.target.dispatchEvent(t12);
      } })), Ot = (A2.addInitHook("addHandler", "tapHold", kt), A2.mergeOptions({ touchZoom: b42.touch, bounceAtZoomLimits: true }), n17.extend({ addHooks: function() {
        M42(this._map._container, "leaflet-touch-zoom"), S72(this._map._container, "touchstart", this._onTouchStart, this);
      }, removeHooks: function() {
        z42(this._map._container, "leaflet-touch-zoom"), k42(this._map._container, "touchstart", this._onTouchStart, this);
      }, _onTouchStart: function(t12) {
        var e18, i13, n18 = this._map;
        !t12.touches || 2 !== t12.touches.length || n18._animatingZoom || this._zooming || (e18 = n18.mouseEventToContainerPoint(t12.touches[0]), i13 = n18.mouseEventToContainerPoint(t12.touches[1]), this._centerPoint = n18.getSize()._divideBy(2), this._startLatLng = n18.containerPointToLatLng(this._centerPoint), "center" !== n18.options.touchZoom && (this._pinchStartLatLng = n18.containerPointToLatLng(e18.add(i13)._divideBy(2))), this._startDist = e18.distanceTo(i13), this._startZoom = n18.getZoom(), this._moved = false, this._zooming = true, n18._stop(), S72(document, "touchmove", this._onTouchMove, this), S72(document, "touchend touchcancel", this._onTouchEnd, this), O32(t12));
      }, _onTouchMove: function(t12) {
        if (t12.touches && 2 === t12.touches.length && this._zooming) {
          var e18 = this._map, i13 = e18.mouseEventToContainerPoint(t12.touches[0]), n18 = e18.mouseEventToContainerPoint(t12.touches[1]), o16 = i13.distanceTo(n18) / this._startDist;
          if (this._zoom = e18.getScaleZoom(o16, this._startZoom), !e18.options.bounceAtZoomLimits && (this._zoom < e18.getMinZoom() && o16 < 1 || this._zoom > e18.getMaxZoom() && 1 < o16) && (this._zoom = e18._limitZoom(this._zoom)), "center" === e18.options.touchZoom) {
            if (this._center = this._startLatLng, 1 == o16) return;
          } else {
            i13 = i13._add(n18)._divideBy(2)._subtract(this._centerPoint);
            if (1 == o16 && 0 === i13.x && 0 === i13.y) return;
            this._center = e18.unproject(e18.project(this._pinchStartLatLng, this._zoom).subtract(i13), this._zoom);
          }
          this._moved || (e18._moveStart(true, false), this._moved = true), r112(this._animRequest);
          n18 = a72(e18._move, e18, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = x52(n18, this, true), O32(t12);
        }
      }, _onTouchEnd: function() {
        this._moved && this._zooming ? (this._zooming = false, r112(this._animRequest), k42(document, "touchmove", this._onTouchMove, this), k42(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = false;
      } })), Xi = (A2.addInitHook("addHandler", "touchZoom", Ot), A2.BoxZoom = _t2, A2.DoubleClickZoom = Ct, A2.Drag = Zt2, A2.Keyboard = St, A2.ScrollWheelZoom = Et, A2.TapHold = kt, A2.TouchZoom = Ot, t11.Bounds = f82, t11.Browser = b42, t11.CRS = ot, t11.Canvas = Fi, t11.Circle = vi, t11.CircleMarker = gi, t11.Class = et35, t11.Control = B42, t11.DivIcon = Ri, t11.DivOverlay = Ai, t11.DomEvent = mt2, t11.DomUtil = pt, t11.Draggable = Xe, t11.Evented = it, t11.FeatureGroup = ci, t11.GeoJSON = wi, t11.GridLayer = Ni, t11.Handler = n17, t11.Icon = di, t11.ImageOverlay = Ei, t11.LatLng = v42, t11.LatLngBounds = s9, t11.Layer = o15, t11.LayerGroup = ui, t11.LineUtil = vt, t11.Map = A2, t11.Marker = mi, t11.Mixin = ft, t11.Path = fi, t11.Point = p42, t11.PolyUtil = gt2, t11.Polygon = xi, t11.Polyline = yi, t11.Popup = Bi, t11.PosAnimation = Fe, t11.Projection = wt2, t11.Rectangle = Yi, t11.Renderer = Wi, t11.SVG = Gi, t11.SVGOverlay = Oi, t11.TileLayer = Di, t11.Tooltip = Ii, t11.Transformation = at, t11.Util = tt, t11.VideoOverlay = ki, t11.bind = a72, t11.bounds = _42, t11.canvas = Ui, t11.circle = function(t12, e18, i13) {
        return new vi(t12, e18, i13);
      }, t11.circleMarker = function(t12, e18) {
        return new gi(t12, e18);
      }, t11.control = Ue, t11.divIcon = function(t12) {
        return new Ri(t12);
      }, t11.extend = l11, t11.featureGroup = function(t12, e18) {
        return new ci(t12, e18);
      }, t11.geoJSON = Si, t11.geoJson = Mt, t11.gridLayer = function(t12) {
        return new Ni(t12);
      }, t11.icon = function(t12) {
        return new di(t12);
      }, t11.imageOverlay = function(t12, e18, i13) {
        return new Ei(t12, e18, i13);
      }, t11.latLng = w42, t11.latLngBounds = g42, t11.layerGroup = function(t12, e18) {
        return new ui(t12, e18);
      }, t11.map = function(t12, e18) {
        return new A2(t12, e18);
      }, t11.marker = function(t12, e18) {
        return new mi(t12, e18);
      }, t11.point = m42, t11.polygon = function(t12, e18) {
        return new xi(t12, e18);
      }, t11.polyline = function(t12, e18) {
        return new yi(t12, e18);
      }, t11.popup = function(t12, e18) {
        return new Bi(t12, e18);
      }, t11.rectangle = function(t12, e18) {
        return new Yi(t12, e18);
      }, t11.setOptions = c92, t11.stamp = h92, t11.svg = Ki, t11.svgOverlay = function(t12, e18, i13) {
        return new Oi(t12, e18, i13);
      }, t11.tileLayer = ji, t11.tooltip = function(t12, e18) {
        return new Ii(t12, e18);
      }, t11.transformation = ht3, t11.version = "1.9.4", t11.videoOverlay = function(t12, e18, i13) {
        return new ki(t12, e18, i13);
      }, window.L);
      t11.noConflict = function() {
        return window.L = Xi, this;
      }, window.L = t11;
    });
  }
});
var __create26 = Object.create;
var __defProp26 = Object.defineProperty;
var __getOwnPropDesc26 = Object.getOwnPropertyDescriptor;
var __knownSymbol26 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError26 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp26 = (obj, key, value) => key in obj ? __defProp26(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name26 = (target, value) => __defProp26(target, "name", { value, configurable: true });
var __decoratorStart26 = (base) => [, , , __create26(base?.[__knownSymbol26("metadata")] ?? null)];
var __decoratorStrings26 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn26 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError26("Function expected") : fn;
var __decoratorContext26 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings26[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError26("Already initialized") : fns.push(__expectFn26(fn || null)) });
var __decoratorMetadata26 = (array, target) => __defNormalProp26(target, __knownSymbol26("metadata"), array[3]);
var __runInitializers26 = (array, flags, self2, value) => {
  for (var i322 = 0, fns = array[flags >> 1], n522 = fns && fns.length; i322 < n522; i322++) flags & 1 ? fns[i322].call(self2) : value = fns[i322].call(self2, value);
  return value;
};
var __decorateElement26 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k222 = flags & 7, s222 = !!(flags & 8), p222 = !!(flags & 16);
  var j222 = k222 > 3 ? array.length + 1 : k222 ? s222 ? 1 : 2 : 0, key = __decoratorStrings26[k222 + 5];
  var initializers = k222 > 3 && (array[j222 - 1] = []), extraInitializers = array[j222] || (array[j222] = []);
  var desc = k222 && (!p222 && !s222 && (target = target.prototype), k222 < 5 && (k222 > 3 || !p222) && __getOwnPropDesc26(k222 < 4 ? target : { get [name]() {
    return __privateGet26(this, extra);
  }, set [name](x222) {
    return __privateSet26(this, extra, x222);
  } }, name));
  k222 ? p222 && k222 < 4 && __name26(extra, (k222 > 2 ? "set " : k222 > 1 ? "get " : "") + name) : __name26(target, name);
  for (var i322 = decorators.length - 1; i322 >= 0; i322--) {
    ctx = __decoratorContext26(k222, name, done = {}, array[3], extraInitializers);
    if (k222) {
      ctx.static = s222, ctx.private = p222, access = ctx.access = { has: p222 ? (x222) => __privateIn26(target, x222) : (x222) => name in x222 };
      if (k222 ^ 3) access.get = p222 ? (x222) => (k222 ^ 1 ? __privateGet26 : __privateMethod26)(x222, target, k222 ^ 4 ? extra : desc.get) : (x222) => x222[name];
      if (k222 > 2) access.set = p222 ? (x222, y222) => __privateSet26(x222, target, y222, k222 ^ 4 ? extra : desc.set) : (x222, y222) => x222[name] = y222;
    }
    it = (0, decorators[i322])(k222 ? k222 < 4 ? p222 ? extra : desc[key] : k222 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k222 ^ 4 || it === void 0) __expectFn26(it) && (k222 > 4 ? initializers.unshift(it) : k222 ? p222 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError26("Object expected");
    else __expectFn26(fn = it.get) && (desc.get = fn), __expectFn26(fn = it.set) && (desc.set = fn), __expectFn26(fn = it.init) && initializers.unshift(fn);
  }
  return k222 || __decoratorMetadata26(array, target), desc && __defProp26(target, name, desc), p222 ? k222 ^ 4 ? extra : desc : target;
};
var __publicField7 = (obj, key, value) => __defNormalProp26(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck26 = (obj, member, msg) => member.has(obj) || __typeError26("Cannot " + msg);
var __privateIn26 = (member, obj) => Object(obj) !== obj ? __typeError26('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet26 = (obj, member, getter) => (__accessCheck26(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd25 = (obj, member, value) => member.has(obj) ? __typeError26("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet26 = (obj, member, value, setter) => (__accessCheck26(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod26 = (obj, member, method) => (__accessCheck26(obj, member, "access private method"), method);
var t10 = globalThis;
var e11 = t10.ShadowRoot && (void 0 === t10.ShadyCSS || t10.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s7 = Symbol();
var o11 = /* @__PURE__ */ new WeakMap();
var n10 = class {
  constructor(t222, e422, o422) {
    if (this._$cssResult$ = true, o422 !== s7) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t222, this.t = e422;
  }
  get styleSheet() {
    let t222 = this.o;
    const s222 = this.t;
    if (e11 && void 0 === t222) {
      const e422 = void 0 !== s222 && 1 === s222.length;
      e422 && (t222 = o11.get(s222)), void 0 === t222 && ((this.o = t222 = new CSSStyleSheet()).replaceSync(this.cssText), e422 && o11.set(s222, t222));
    }
    return t222;
  }
  toString() {
    return this.cssText;
  }
};
var r11 = (t222) => new n10("string" == typeof t222 ? t222 : t222 + "", void 0, s7);
var S8 = (s222, o422) => {
  if (e11) s222.adoptedStyleSheets = o422.map((t222) => t222 instanceof CSSStyleSheet ? t222 : t222.styleSheet);
  else for (const e422 of o422) {
    const o522 = document.createElement("style"), n522 = t10.litNonce;
    void 0 !== n522 && o522.setAttribute("nonce", n522), o522.textContent = e422.cssText, s222.appendChild(o522);
  }
};
var c9 = e11 ? (t222) => t222 : (t222) => t222 instanceof CSSStyleSheet ? ((t322) => {
  let e422 = "";
  for (const s222 of t322.cssRules) e422 += s222.cssText;
  return r11(e422);
})(t222) : t222;
var { is: i27, defineProperty: e27, getOwnPropertyDescriptor: r27, getOwnPropertyNames: h9, getOwnPropertySymbols: o27, getPrototypeOf: n27 } = Object;
var a7 = globalThis;
var c27 = a7.trustedTypes;
var l7 = c27 ? c27.emptyScript : "";
var p7 = a7.reactiveElementPolyfillSupport;
var d7 = (t222, s222) => t222;
var u7 = { toAttribute(t222, s222) {
  switch (s222) {
    case Boolean:
      t222 = t222 ? l7 : null;
      break;
    case Object:
    case Array:
      t222 = null == t222 ? t222 : JSON.stringify(t222);
  }
  return t222;
}, fromAttribute(t222, s222) {
  let i322 = t222;
  switch (s222) {
    case Boolean:
      i322 = null !== t222;
      break;
    case Number:
      i322 = null === t222 ? null : Number(t222);
      break;
    case Object:
    case Array:
      try {
        i322 = JSON.parse(t222);
      } catch (t322) {
        i322 = null;
      }
  }
  return i322;
} };
var f9 = (t222, s222) => !i27(t222, s222);
var y7 = { attribute: true, type: String, converter: u7, reflect: false, hasChanged: f9 };
Symbol.metadata ??= Symbol("metadata"), a7.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b7 = class extends HTMLElement {
  static addInitializer(t222) {
    this._$Ei(), (this.l ??= []).push(t222);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t222, s222 = y7) {
    if (s222.state && (s222.attribute = false), this._$Ei(), this.elementProperties.set(t222, s222), !s222.noAccessor) {
      const i322 = Symbol(), r422 = this.getPropertyDescriptor(t222, i322, s222);
      void 0 !== r422 && e27(this.prototype, t222, r422);
    }
  }
  static getPropertyDescriptor(t222, s222, i322) {
    const { get: e422, set: h422 } = r27(this.prototype, t222) ?? { get() {
      return this[s222];
    }, set(t322) {
      this[s222] = t322;
    } };
    return { get() {
      return e422?.call(this);
    }, set(s322) {
      const r422 = e422?.call(this);
      h422.call(this, s322), this.requestUpdate(t222, r422, i322);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t222) {
    return this.elementProperties.get(t222) ?? y7;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d7("elementProperties"))) return;
    const t222 = n27(this);
    t222.finalize(), void 0 !== t222.l && (this.l = [...t222.l]), this.elementProperties = new Map(t222.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d7("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d7("properties"))) {
      const t322 = this.properties, s222 = [...h9(t322), ...o27(t322)];
      for (const i322 of s222) this.createProperty(i322, t322[i322]);
    }
    const t222 = this[Symbol.metadata];
    if (null !== t222) {
      const s222 = litPropertyMetadata.get(t222);
      if (void 0 !== s222) for (const [t322, i322] of s222) this.elementProperties.set(t322, i322);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t322, s222] of this.elementProperties) {
      const i322 = this._$Eu(t322, s222);
      void 0 !== i322 && this._$Eh.set(i322, t322);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s222) {
    const i322 = [];
    if (Array.isArray(s222)) {
      const e422 = new Set(s222.flat(1 / 0).reverse());
      for (const s322 of e422) i322.unshift(c9(s322));
    } else void 0 !== s222 && i322.push(c9(s222));
    return i322;
  }
  static _$Eu(t222, s222) {
    const i322 = s222.attribute;
    return false === i322 ? void 0 : "string" == typeof i322 ? i322 : "string" == typeof t222 ? t222.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t222) => this.enableUpdating = t222), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t222) => t222(this));
  }
  addController(t222) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t222), void 0 !== this.renderRoot && this.isConnected && t222.hostConnected?.();
  }
  removeController(t222) {
    this._$EO?.delete(t222);
  }
  _$E_() {
    const t222 = /* @__PURE__ */ new Map(), s222 = this.constructor.elementProperties;
    for (const i322 of s222.keys()) this.hasOwnProperty(i322) && (t222.set(i322, this[i322]), delete this[i322]);
    t222.size > 0 && (this._$Ep = t222);
  }
  createRenderRoot() {
    const t222 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S8(t222, this.constructor.elementStyles), t222;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t222) => t222.hostConnected?.());
  }
  enableUpdating(t222) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t222) => t222.hostDisconnected?.());
  }
  attributeChangedCallback(t222, s222, i322) {
    this._$AK(t222, i322);
  }
  _$EC(t222, s222) {
    const i322 = this.constructor.elementProperties.get(t222), e422 = this.constructor._$Eu(t222, i322);
    if (void 0 !== e422 && true === i322.reflect) {
      const r422 = (void 0 !== i322.converter?.toAttribute ? i322.converter : u7).toAttribute(s222, i322.type);
      this._$Em = t222, null == r422 ? this.removeAttribute(e422) : this.setAttribute(e422, r422), this._$Em = null;
    }
  }
  _$AK(t222, s222) {
    const i322 = this.constructor, e422 = i322._$Eh.get(t222);
    if (void 0 !== e422 && this._$Em !== e422) {
      const t322 = i322.getPropertyOptions(e422), r422 = "function" == typeof t322.converter ? { fromAttribute: t322.converter } : void 0 !== t322.converter?.fromAttribute ? t322.converter : u7;
      this._$Em = e422, this[e422] = r422.fromAttribute(s222, t322.type), this._$Em = null;
    }
  }
  requestUpdate(t222, s222, i322) {
    if (void 0 !== t222) {
      if (i322 ??= this.constructor.getPropertyOptions(t222), !(i322.hasChanged ?? f9)(this[t222], s222)) return;
      this.P(t222, s222, i322);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t222, s222, i322) {
    this._$AL.has(t222) || this._$AL.set(t222, s222), true === i322.reflect && this._$Em !== t222 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t222);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t322) {
      Promise.reject(t322);
    }
    const t222 = this.scheduleUpdate();
    return null != t222 && await t222, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t422, s322] of this._$Ep) this[t422] = s322;
        this._$Ep = void 0;
      }
      const t322 = this.constructor.elementProperties;
      if (t322.size > 0) for (const [s322, i322] of t322) true !== i322.wrapped || this._$AL.has(s322) || void 0 === this[s322] || this.P(s322, this[s322], i322);
    }
    let t222 = false;
    const s222 = this._$AL;
    try {
      t222 = this.shouldUpdate(s222), t222 ? (this.willUpdate(s222), this._$EO?.forEach((t322) => t322.hostUpdate?.()), this.update(s222)) : this._$EU();
    } catch (s322) {
      throw t222 = false, this._$EU(), s322;
    }
    t222 && this._$AE(s222);
  }
  willUpdate(t222) {
  }
  _$AE(t222) {
    this._$EO?.forEach((t322) => t322.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t222)), this.updated(t222);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t222) {
    return true;
  }
  update(t222) {
    this._$Ej &&= this._$Ej.forEach((t322) => this._$EC(t322, this[t322])), this._$EU();
  }
  updated(t222) {
  }
  firstUpdated(t222) {
  }
};
b7.elementStyles = [], b7.shadowRootOptions = { mode: "open" }, b7[d7("elementProperties")] = /* @__PURE__ */ new Map(), b7[d7("finalized")] = /* @__PURE__ */ new Map(), p7?.({ ReactiveElement: b7 }), (a7.reactiveElementVersions ??= []).push("2.0.4");
var n37 = globalThis;
var c37 = n37.trustedTypes;
var h27 = c37 ? c37.createPolicy("lit-html", { createHTML: (t222) => t222 }) : void 0;
var f27 = "$lit$";
var v7 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m7 = "?" + v7;
var _7 = `<${m7}>`;
var w7 = document;
var lt7 = () => w7.createComment("");
var st7 = (t222) => null === t222 || "object" != typeof t222 && "function" != typeof t222;
var g7 = Array.isArray;
var $7 = (t222) => g7(t222) || "function" == typeof t222?.[Symbol.iterator];
var x7 = "[ 	\n\f\r]";
var T7 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E7 = /-->/g;
var k7 = />/g;
var O7 = RegExp(`>|${x7}(?:([^\\s"'>=/]+)(${x7}*=${x7}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S27 = /'/g;
var j7 = /"/g;
var M7 = /^(?:script|style|textarea|title)$/i;
var P7 = (t222) => (i322, ...s222) => ({ _$litType$: t222, strings: i322, values: s222 });
var ke8 = P7(1);
var Oe8 = P7(2);
var Se8 = P7(3);
var R7 = Symbol.for("lit-noChange");
var D7 = Symbol.for("lit-nothing");
var V7 = /* @__PURE__ */ new WeakMap();
var I7 = w7.createTreeWalker(w7, 129);
function N7(t222, i322) {
  if (!g7(t222) || !t222.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h27 ? h27.createHTML(i322) : i322;
}
var U7 = (t222, i322) => {
  const s222 = t222.length - 1, e422 = [];
  let h422, o422 = 2 === i322 ? "<svg>" : 3 === i322 ? "<math>" : "", n522 = T7;
  for (let i422 = 0; i422 < s222; i422++) {
    const s322 = t222[i422];
    let r422, l222, c422 = -1, a222 = 0;
    for (; a222 < s322.length && (n522.lastIndex = a222, l222 = n522.exec(s322), null !== l222); ) a222 = n522.lastIndex, n522 === T7 ? "!--" === l222[1] ? n522 = E7 : void 0 !== l222[1] ? n522 = k7 : void 0 !== l222[2] ? (M7.test(l222[2]) && (h422 = RegExp("</" + l222[2], "g")), n522 = O7) : void 0 !== l222[3] && (n522 = O7) : n522 === O7 ? ">" === l222[0] ? (n522 = h422 ?? T7, c422 = -1) : void 0 === l222[1] ? c422 = -2 : (c422 = n522.lastIndex - l222[2].length, r422 = l222[1], n522 = void 0 === l222[3] ? O7 : '"' === l222[3] ? j7 : S27) : n522 === j7 || n522 === S27 ? n522 = O7 : n522 === E7 || n522 === k7 ? n522 = T7 : (n522 = O7, h422 = void 0);
    const u222 = n522 === O7 && t222[i422 + 1].startsWith("/>") ? " " : "";
    o422 += n522 === T7 ? s322 + _7 : c422 >= 0 ? (e422.push(r422), s322.slice(0, c422) + f27 + s322.slice(c422) + v7 + u222) : s322 + v7 + (-2 === c422 ? i422 : u222);
  }
  return [N7(t222, o422 + (t222[s222] || "<?>") + (2 === i322 ? "</svg>" : 3 === i322 ? "</math>" : "")), e422];
};
var B7 = class _B7 {
  constructor({ strings: t222, _$litType$: i322 }, s222) {
    let e422;
    this.parts = [];
    let h422 = 0, o422 = 0;
    const n522 = t222.length - 1, r422 = this.parts, [l222, a222] = U7(t222, i322);
    if (this.el = _B7.createElement(l222, s222), I7.currentNode = this.el.content, 2 === i322 || 3 === i322) {
      const t322 = this.el.content.firstChild;
      t322.replaceWith(...t322.childNodes);
    }
    for (; null !== (e422 = I7.nextNode()) && r422.length < n522; ) {
      if (1 === e422.nodeType) {
        if (e422.hasAttributes()) for (const t322 of e422.getAttributeNames()) if (t322.endsWith(f27)) {
          const i422 = a222[o422++], s322 = e422.getAttribute(t322).split(v7), n622 = /([.?@])?(.*)/.exec(i422);
          r422.push({ type: 1, index: h422, name: n622[2], strings: s322, ctor: "." === n622[1] ? Y7 : "?" === n622[1] ? Z7 : "@" === n622[1] ? q7 : G7 }), e422.removeAttribute(t322);
        } else t322.startsWith(v7) && (r422.push({ type: 6, index: h422 }), e422.removeAttribute(t322));
        if (M7.test(e422.tagName)) {
          const t322 = e422.textContent.split(v7), i422 = t322.length - 1;
          if (i422 > 0) {
            e422.textContent = c37 ? c37.emptyScript : "";
            for (let s322 = 0; s322 < i422; s322++) e422.append(t322[s322], lt7()), I7.nextNode(), r422.push({ type: 2, index: ++h422 });
            e422.append(t322[i422], lt7());
          }
        }
      } else if (8 === e422.nodeType) if (e422.data === m7) r422.push({ type: 2, index: h422 });
      else {
        let t322 = -1;
        for (; -1 !== (t322 = e422.data.indexOf(v7, t322 + 1)); ) r422.push({ type: 7, index: h422 }), t322 += v7.length - 1;
      }
      h422++;
    }
  }
  static createElement(t222, i322) {
    const s222 = w7.createElement("template");
    return s222.innerHTML = t222, s222;
  }
};
function z7(t222, i322, s222 = t222, e422) {
  if (i322 === R7) return i322;
  let h422 = void 0 !== e422 ? s222.o?.[e422] : s222.l;
  const o422 = st7(i322) ? void 0 : i322._$litDirective$;
  return h422?.constructor !== o422 && (h422?._$AO?.(false), void 0 === o422 ? h422 = void 0 : (h422 = new o422(t222), h422._$AT(t222, s222, e422)), void 0 !== e422 ? (s222.o ??= [])[e422] = h422 : s222.l = h422), void 0 !== h422 && (i322 = z7(t222, h422._$AS(t222, i322.values), h422, e422)), i322;
}
var F7 = class {
  constructor(t222, i322) {
    this._$AV = [], this._$AN = void 0, this._$AD = t222, this._$AM = i322;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t222) {
    const { el: { content: i322 }, parts: s222 } = this._$AD, e422 = (t222?.creationScope ?? w7).importNode(i322, true);
    I7.currentNode = e422;
    let h422 = I7.nextNode(), o422 = 0, n522 = 0, r422 = s222[0];
    for (; void 0 !== r422; ) {
      if (o422 === r422.index) {
        let i422;
        2 === r422.type ? i422 = new et8(h422, h422.nextSibling, this, t222) : 1 === r422.type ? i422 = new r422.ctor(h422, r422.name, r422.strings, this, t222) : 6 === r422.type && (i422 = new K7(h422, this, t222)), this._$AV.push(i422), r422 = s222[++n522];
      }
      o422 !== r422?.index && (h422 = I7.nextNode(), o422++);
    }
    return I7.currentNode = w7, e422;
  }
  p(t222) {
    let i322 = 0;
    for (const s222 of this._$AV) void 0 !== s222 && (void 0 !== s222.strings ? (s222._$AI(t222, s222, i322), i322 += s222.strings.length - 2) : s222._$AI(t222[i322])), i322++;
  }
};
var et8 = class _et7 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t222, i322, s222, e422) {
    this.type = 2, this._$AH = D7, this._$AN = void 0, this._$AA = t222, this._$AB = i322, this._$AM = s222, this.options = e422, this.v = e422?.isConnected ?? true;
  }
  get parentNode() {
    let t222 = this._$AA.parentNode;
    const i322 = this._$AM;
    return void 0 !== i322 && 11 === t222?.nodeType && (t222 = i322.parentNode), t222;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t222, i322 = this) {
    t222 = z7(this, t222, i322), st7(t222) ? t222 === D7 || null == t222 || "" === t222 ? (this._$AH !== D7 && this._$AR(), this._$AH = D7) : t222 !== this._$AH && t222 !== R7 && this._(t222) : void 0 !== t222._$litType$ ? this.$(t222) : void 0 !== t222.nodeType ? this.T(t222) : $7(t222) ? this.k(t222) : this._(t222);
  }
  O(t222) {
    return this._$AA.parentNode.insertBefore(t222, this._$AB);
  }
  T(t222) {
    this._$AH !== t222 && (this._$AR(), this._$AH = this.O(t222));
  }
  _(t222) {
    this._$AH !== D7 && st7(this._$AH) ? this._$AA.nextSibling.data = t222 : this.T(w7.createTextNode(t222)), this._$AH = t222;
  }
  $(t222) {
    const { values: i322, _$litType$: s222 } = t222, e422 = "number" == typeof s222 ? this._$AC(t222) : (void 0 === s222.el && (s222.el = B7.createElement(N7(s222.h, s222.h[0]), this.options)), s222);
    if (this._$AH?._$AD === e422) this._$AH.p(i322);
    else {
      const t322 = new F7(e422, this), s322 = t322.u(this.options);
      t322.p(i322), this.T(s322), this._$AH = t322;
    }
  }
  _$AC(t222) {
    let i322 = V7.get(t222.strings);
    return void 0 === i322 && V7.set(t222.strings, i322 = new B7(t222)), i322;
  }
  k(t222) {
    g7(this._$AH) || (this._$AH = [], this._$AR());
    const i322 = this._$AH;
    let s222, e422 = 0;
    for (const h422 of t222) e422 === i322.length ? i322.push(s222 = new _et7(this.O(lt7()), this.O(lt7()), this, this.options)) : s222 = i322[e422], s222._$AI(h422), e422++;
    e422 < i322.length && (this._$AR(s222 && s222._$AB.nextSibling, e422), i322.length = e422);
  }
  _$AR(t222 = this._$AA.nextSibling, i322) {
    for (this._$AP?.(false, true, i322); t222 && t222 !== this._$AB; ) {
      const i422 = t222.nextSibling;
      t222.remove(), t222 = i422;
    }
  }
  setConnected(t222) {
    void 0 === this._$AM && (this.v = t222, this._$AP?.(t222));
  }
};
var G7 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t222, i322, s222, e422, h422) {
    this.type = 1, this._$AH = D7, this._$AN = void 0, this.element = t222, this.name = i322, this._$AM = e422, this.options = h422, s222.length > 2 || "" !== s222[0] || "" !== s222[1] ? (this._$AH = Array(s222.length - 1).fill(new String()), this.strings = s222) : this._$AH = D7;
  }
  _$AI(t222, i322 = this, s222, e422) {
    const h422 = this.strings;
    let o422 = false;
    if (void 0 === h422) t222 = z7(this, t222, i322, 0), o422 = !st7(t222) || t222 !== this._$AH && t222 !== R7, o422 && (this._$AH = t222);
    else {
      const e522 = t222;
      let n522, r422;
      for (t222 = h422[0], n522 = 0; n522 < h422.length - 1; n522++) r422 = z7(this, e522[s222 + n522], i322, n522), r422 === R7 && (r422 = this._$AH[n522]), o422 ||= !st7(r422) || r422 !== this._$AH[n522], r422 === D7 ? t222 = D7 : t222 !== D7 && (t222 += (r422 ?? "") + h422[n522 + 1]), this._$AH[n522] = r422;
    }
    o422 && !e422 && this.j(t222);
  }
  j(t222) {
    t222 === D7 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t222 ?? "");
  }
};
var Y7 = class extends G7 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t222) {
    this.element[this.name] = t222 === D7 ? void 0 : t222;
  }
};
var Z7 = class extends G7 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t222) {
    this.element.toggleAttribute(this.name, !!t222 && t222 !== D7);
  }
};
var q7 = class extends G7 {
  constructor(t222, i322, s222, e422, h422) {
    super(t222, i322, s222, e422, h422), this.type = 5;
  }
  _$AI(t222, i322 = this) {
    if ((t222 = z7(this, t222, i322, 0) ?? D7) === R7) return;
    const s222 = this._$AH, e422 = t222 === D7 && s222 !== D7 || t222.capture !== s222.capture || t222.once !== s222.once || t222.passive !== s222.passive, h422 = t222 !== D7 && (s222 === D7 || e422);
    e422 && this.element.removeEventListener(this.name, this, s222), h422 && this.element.addEventListener(this.name, this, t222), this._$AH = t222;
  }
  handleEvent(t222) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t222) : this._$AH.handleEvent(t222);
  }
};
var K7 = class {
  constructor(t222, i322, s222) {
    this.element = t222, this.type = 6, this._$AN = void 0, this._$AM = i322, this.options = s222;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t222) {
    z7(this, t222);
  }
};
var Re7 = n37.litHtmlPolyfillSupport;
Re7?.(B7, et8), (n37.litHtmlVersions ??= []).push("3.2.0");
var Q7 = (t222, i322, s222) => {
  const e422 = s222?.renderBefore ?? i322;
  let h422 = e422._$litPart$;
  if (void 0 === h422) {
    const t322 = s222?.renderBefore ?? null;
    e422._$litPart$ = h422 = new et8(i322.insertBefore(lt7(), t322), t322, void 0, s222 ?? {});
  }
  return h422._$AI(t222), h422;
};
var h37 = class extends b7 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t222 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t222.firstChild, t222;
  }
  update(t222) {
    const e422 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t222), this.o = Q7(e422, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R7;
  }
};
h37._$litElement$ = true, h37["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h37 });
var f37 = globalThis.litElementPolyfillSupport;
f37?.({ LitElement: h37 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var o37 = { attribute: true, type: String, converter: u7, reflect: false, hasChanged: f9 };
var r37 = (t222 = o37, e422, r422) => {
  const { kind: n522, metadata: i322 } = r422;
  let s222 = globalThis.litPropertyMetadata.get(i322);
  if (void 0 === s222 && globalThis.litPropertyMetadata.set(i322, s222 = /* @__PURE__ */ new Map()), s222.set(r422.name, t222), "accessor" === n522) {
    const { name: o422 } = r422;
    return { set(r522) {
      const n622 = e422.get.call(this);
      e422.set.call(this, r522), this.requestUpdate(o422, n622, t222);
    }, init(e522) {
      return void 0 !== e522 && this.P(o422, void 0, t222), e522;
    } };
  }
  if ("setter" === n522) {
    const { name: o422 } = r422;
    return function(r522) {
      const n622 = this[o422];
      e422.call(this, r522), this.requestUpdate(o422, n622, t222);
    };
  }
  throw Error("Unsupported decorator location: " + n522);
};
function n47(t222) {
  return (e422, o422) => "object" == typeof o422 ? r37(t222, e422, o422) : ((t322, e522, o522) => {
    const r422 = e522.hasOwnProperty(o522);
    return e522.constructor.createProperty(o522, r422 ? { ...t322, wrapped: true } : t322), r422 ? Object.getOwnPropertyDescriptor(e522, o522) : void 0;
  })(t222, e422, o422);
}
var appliedClassMixins6 = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied6(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins6.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin6(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied6(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins6.set(mixedClass, mixin);
    return mixedClass;
  };
}
var version6 = "3.0.0";
var versions6 = window.scopedElementsVersions || (window.scopedElementsVersions = []);
if (!versions6.includes(version6)) {
  versions6.push(version6);
}
var ScopedElementsMixinImplementation7 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @type {ScopedElementsMap=}
     */
    static scopedElements;
    static get scopedElementsVersion() {
      return version6;
    }
    /** @type {CustomElementRegistry=} */
    static __registry;
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry=}
     */
    get registry() {
      return (
        /** @type {typeof ScopedElementsHost} */
        this.constructor.__registry
      );
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry22) {
      this.constructor.__registry = registry22;
    }
    /**
     * @param {ShadowRootInit} options
     * @returns {ShadowRoot}
     */
    attachShadow(options) {
      const { scopedElements } = (
        /** @type {typeof ScopedElementsHost} */
        this.constructor
      );
      const shouldCreateRegistry = !this.registry || // @ts-ignore
      this.registry === this.constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = new CustomElementRegistry();
        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {
          this.registry.define(tagName, klass);
        }
      }
      return super.attachShadow({
        ...options,
        // The polyfill currently expects the registry to be passed as `customElements`
        customElements: this.registry,
        // But the proposal has moved forward, and renamed it to `registry`
        // For backwards compatibility, we pass it as both
        registry: this.registry
      });
    }
  }
);
var ScopedElementsMixin7 = dedupeMixin6(ScopedElementsMixinImplementation7);
var ScopedElementsMixinImplementation26 = (superclass) => (
  /** @type {ScopedElementsHost} */
  class ScopedElementsHost extends ScopedElementsMixin7(superclass) {
    createRenderRoot() {
      const { shadowRootOptions, elementStyles } = (
        /** @type {TypeofLitElement} */
        this.constructor
      );
      const shadowRoot = this.attachShadow(shadowRootOptions);
      this.renderOptions.creationScope = shadowRoot;
      S8(shadowRoot, elementStyles);
      this.renderOptions.renderBefore ??= shadowRoot.firstChild;
      return shadowRoot;
    }
  }
);
var ScopedElementsMixin26 = dedupeMixin6(ScopedElementsMixinImplementation26);
var _lang_dec6;
var _contentEditable_dec6;
var _a7;
var _init7;
var _contentEditable6;
var _lang6;
var LitElementWw6 = class extends (_a7 = ScopedElementsMixin26(h37), _contentEditable_dec6 = [n47({ type: String, attribute: true, reflect: true })], _lang_dec6 = [n47({ type: String, attribute: true, reflect: true })], _a7) {
  constructor() {
    super(...arguments);
    __publicField7(this, "options");
    __publicField7(this, "actions", {});
    __privateAdd25(this, _contentEditable6, __runInitializers26(_init7, 8, this)), __runInitializers26(_init7, 11, this);
    __privateAdd25(this, _lang6, __runInitializers26(_init7, 12, this)), __runInitializers26(_init7, 15, this);
    __publicField7(this, "_inTransaction", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.getAttributeNames().forEach((k222) => this.setAttribute(k222, this.getAttribute(k222)));
  }
};
_init7 = __decoratorStart26(_a7);
_contentEditable6 = /* @__PURE__ */ new WeakMap();
_lang6 = /* @__PURE__ */ new WeakMap();
__decorateElement26(_init7, 4, "contentEditable", _contentEditable_dec6, LitElementWw6, _contentEditable6);
__decorateElement26(_init7, 4, "lang", _lang_dec6, LitElementWw6, _lang6);
__decoratorMetadata26(_init7, LitElementWw6);
__publicField7(LitElementWw6, "shadowRootOptions", { ...h37.shadowRootOptions });
__publicField7(LitElementWw6, "options", {});
__publicField7(LitElementWw6, "actions", {});
var t26 = globalThis;
var e36 = t26.ShadowRoot && (void 0 === t26.ShadyCSS || t26.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s26 = Symbol();
var o45 = /* @__PURE__ */ new WeakMap();
var n55 = class {
  constructor(t11, e17, o15) {
    if (this._$cssResult$ = true, o15 !== s26) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t11, this.t = e17;
  }
  get styleSheet() {
    let t11 = this.o;
    const s9 = this.t;
    if (e36 && void 0 === t11) {
      const e17 = void 0 !== s9 && 1 === s9.length;
      e17 && (t11 = o45.get(s9)), void 0 === t11 && ((this.o = t11 = new CSSStyleSheet()).replaceSync(this.cssText), e17 && o45.set(s9, t11));
    }
    return t11;
  }
  toString() {
    return this.cssText;
  }
};
var r45 = (t11) => new n55("string" == typeof t11 ? t11 : t11 + "", void 0, s26);
var i7 = (t11, ...e17) => {
  const o15 = 1 === t11.length ? t11[0] : e17.reduce((e18, s9, o16) => e18 + ((t12) => {
    if (true === t12._$cssResult$) return t12.cssText;
    if ("number" == typeof t12) return t12;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t12 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s9) + t11[o16 + 1], t11[0]);
  return new n55(o15, t11, s26);
};
var S36 = (s9, o15) => {
  if (e36) s9.adoptedStyleSheets = o15.map((t11) => t11 instanceof CSSStyleSheet ? t11 : t11.styleSheet);
  else for (const e17 of o15) {
    const o16 = document.createElement("style"), n17 = t26.litNonce;
    void 0 !== n17 && o16.setAttribute("nonce", n17), o16.textContent = e17.cssText, s9.appendChild(o16);
  }
};
var c46 = e36 ? (t11) => t11 : (t11) => t11 instanceof CSSStyleSheet ? ((t12) => {
  let e17 = "";
  for (const s9 of t12.cssRules) e17 += s9.cssText;
  return r45(e17);
})(t11) : t11;
var { is: i36, defineProperty: e45, getOwnPropertyDescriptor: r55, getOwnPropertyNames: h46, getOwnPropertySymbols: o54, getPrototypeOf: n62 } = Object;
var a26 = globalThis;
var c52 = a26.trustedTypes;
var l26 = c52 ? c52.emptyScript : "";
var p26 = a26.reactiveElementPolyfillSupport;
var d26 = (t11, s9) => t11;
var u26 = { toAttribute(t11, s9) {
  switch (s9) {
    case Boolean:
      t11 = t11 ? l26 : null;
      break;
    case Object:
    case Array:
      t11 = null == t11 ? t11 : JSON.stringify(t11);
  }
  return t11;
}, fromAttribute(t11, s9) {
  let i12 = t11;
  switch (s9) {
    case Boolean:
      i12 = null !== t11;
      break;
    case Number:
      i12 = null === t11 ? null : Number(t11);
      break;
    case Object:
    case Array:
      try {
        i12 = JSON.parse(t11);
      } catch (t12) {
        i12 = null;
      }
  }
  return i12;
} };
var f46 = (t11, s9) => !i36(t11, s9);
var y26 = { attribute: true, type: String, converter: u26, reflect: false, hasChanged: f46 };
Symbol.metadata ??= Symbol("metadata"), a26.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b26 = class extends HTMLElement {
  static addInitializer(t11) {
    this._$Ei(), (this.l ??= []).push(t11);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t11, s9 = y26) {
    if (s9.state && (s9.attribute = false), this._$Ei(), this.elementProperties.set(t11, s9), !s9.noAccessor) {
      const i12 = Symbol(), r112 = this.getPropertyDescriptor(t11, i12, s9);
      void 0 !== r112 && e45(this.prototype, t11, r112);
    }
  }
  static getPropertyDescriptor(t11, s9, i12) {
    const { get: e17, set: h92 } = r55(this.prototype, t11) ?? { get() {
      return this[s9];
    }, set(t12) {
      this[s9] = t12;
    } };
    return { get() {
      return e17?.call(this);
    }, set(s10) {
      const r112 = e17?.call(this);
      h92.call(this, s10), this.requestUpdate(t11, r112, i12);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t11) {
    return this.elementProperties.get(t11) ?? y26;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d26("elementProperties"))) return;
    const t11 = n62(this);
    t11.finalize(), void 0 !== t11.l && (this.l = [...t11.l]), this.elementProperties = new Map(t11.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d26("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d26("properties"))) {
      const t12 = this.properties, s9 = [...h46(t12), ...o54(t12)];
      for (const i12 of s9) this.createProperty(i12, t12[i12]);
    }
    const t11 = this[Symbol.metadata];
    if (null !== t11) {
      const s9 = litPropertyMetadata.get(t11);
      if (void 0 !== s9) for (const [t12, i12] of s9) this.elementProperties.set(t12, i12);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t12, s9] of this.elementProperties) {
      const i12 = this._$Eu(t12, s9);
      void 0 !== i12 && this._$Eh.set(i12, t12);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s9) {
    const i12 = [];
    if (Array.isArray(s9)) {
      const e17 = new Set(s9.flat(1 / 0).reverse());
      for (const s10 of e17) i12.unshift(c46(s10));
    } else void 0 !== s9 && i12.push(c46(s9));
    return i12;
  }
  static _$Eu(t11, s9) {
    const i12 = s9.attribute;
    return false === i12 ? void 0 : "string" == typeof i12 ? i12 : "string" == typeof t11 ? t11.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t11) => this.enableUpdating = t11), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t11) => t11(this));
  }
  addController(t11) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t11), void 0 !== this.renderRoot && this.isConnected && t11.hostConnected?.();
  }
  removeController(t11) {
    this._$EO?.delete(t11);
  }
  _$E_() {
    const t11 = /* @__PURE__ */ new Map(), s9 = this.constructor.elementProperties;
    for (const i12 of s9.keys()) this.hasOwnProperty(i12) && (t11.set(i12, this[i12]), delete this[i12]);
    t11.size > 0 && (this._$Ep = t11);
  }
  createRenderRoot() {
    const t11 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S36(t11, this.constructor.elementStyles), t11;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t11) => t11.hostConnected?.());
  }
  enableUpdating(t11) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t11) => t11.hostDisconnected?.());
  }
  attributeChangedCallback(t11, s9, i12) {
    this._$AK(t11, i12);
  }
  _$EC(t11, s9) {
    const i12 = this.constructor.elementProperties.get(t11), e17 = this.constructor._$Eu(t11, i12);
    if (void 0 !== e17 && true === i12.reflect) {
      const r112 = (void 0 !== i12.converter?.toAttribute ? i12.converter : u26).toAttribute(s9, i12.type);
      this._$Em = t11, null == r112 ? this.removeAttribute(e17) : this.setAttribute(e17, r112), this._$Em = null;
    }
  }
  _$AK(t11, s9) {
    const i12 = this.constructor, e17 = i12._$Eh.get(t11);
    if (void 0 !== e17 && this._$Em !== e17) {
      const t12 = i12.getPropertyOptions(e17), r112 = "function" == typeof t12.converter ? { fromAttribute: t12.converter } : void 0 !== t12.converter?.fromAttribute ? t12.converter : u26;
      this._$Em = e17, this[e17] = r112.fromAttribute(s9, t12.type), this._$Em = null;
    }
  }
  requestUpdate(t11, s9, i12) {
    if (void 0 !== t11) {
      if (i12 ??= this.constructor.getPropertyOptions(t11), !(i12.hasChanged ?? f46)(this[t11], s9)) return;
      this.P(t11, s9, i12);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t11, s9, i12) {
    this._$AL.has(t11) || this._$AL.set(t11, s9), true === i12.reflect && this._$Em !== t11 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t11);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t12) {
      Promise.reject(t12);
    }
    const t11 = this.scheduleUpdate();
    return null != t11 && await t11, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t13, s10] of this._$Ep) this[t13] = s10;
        this._$Ep = void 0;
      }
      const t12 = this.constructor.elementProperties;
      if (t12.size > 0) for (const [s10, i12] of t12) true !== i12.wrapped || this._$AL.has(s10) || void 0 === this[s10] || this.P(s10, this[s10], i12);
    }
    let t11 = false;
    const s9 = this._$AL;
    try {
      t11 = this.shouldUpdate(s9), t11 ? (this.willUpdate(s9), this._$EO?.forEach((t12) => t12.hostUpdate?.()), this.update(s9)) : this._$EU();
    } catch (s10) {
      throw t11 = false, this._$EU(), s10;
    }
    t11 && this._$AE(s9);
  }
  willUpdate(t11) {
  }
  _$AE(t11) {
    this._$EO?.forEach((t12) => t12.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t11)), this.updated(t11);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t11) {
    return true;
  }
  update(t11) {
    this._$Ej &&= this._$Ej.forEach((t12) => this._$EC(t12, this[t12])), this._$EU();
  }
  updated(t11) {
  }
  firstUpdated(t11) {
  }
};
b26.elementStyles = [], b26.shadowRootOptions = { mode: "open" }, b26[d26("elementProperties")] = /* @__PURE__ */ new Map(), b26[d26("finalized")] = /* @__PURE__ */ new Map(), p26?.({ ReactiveElement: b26 }), (a26.reactiveElementVersions ??= []).push("2.0.4");
var n72 = globalThis;
var c62 = n72.trustedTypes;
var h52 = c62 ? c62.createPolicy("lit-html", { createHTML: (t11) => t11 }) : void 0;
var f52 = "$lit$";
var v26 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m26 = "?" + v26;
var _26 = `<${m26}>`;
var w26 = document;
var lt26 = () => w26.createComment("");
var st26 = (t11) => null === t11 || "object" != typeof t11 && "function" != typeof t11;
var g26 = Array.isArray;
var $26 = (t11) => g26(t11) || "function" == typeof t11?.[Symbol.iterator];
var x26 = "[ 	\n\f\r]";
var T26 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E26 = /-->/g;
var k26 = />/g;
var O26 = RegExp(`>|${x26}(?:([^\\s"'>=/]+)(${x26}*=${x26}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S42 = /'/g;
var j26 = /"/g;
var M26 = /^(?:script|style|textarea|title)$/i;
var P26 = (t11) => (i12, ...s9) => ({ _$litType$: t11, strings: i12, values: s9 });
var ke26 = P26(1);
var Oe26 = P26(2);
var Se26 = P26(3);
var R26 = Symbol.for("lit-noChange");
var D26 = Symbol.for("lit-nothing");
var V26 = /* @__PURE__ */ new WeakMap();
var I26 = w26.createTreeWalker(w26, 129);
function N26(t11, i12) {
  if (!g26(t11) || !t11.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h52 ? h52.createHTML(i12) : i12;
}
var U26 = (t11, i12) => {
  const s9 = t11.length - 1, e17 = [];
  let h92, o15 = 2 === i12 ? "<svg>" : 3 === i12 ? "<math>" : "", n17 = T26;
  for (let i13 = 0; i13 < s9; i13++) {
    const s10 = t11[i13];
    let r112, l11, c92 = -1, a72 = 0;
    for (; a72 < s10.length && (n17.lastIndex = a72, l11 = n17.exec(s10), null !== l11); ) a72 = n17.lastIndex, n17 === T26 ? "!--" === l11[1] ? n17 = E26 : void 0 !== l11[1] ? n17 = k26 : void 0 !== l11[2] ? (M26.test(l11[2]) && (h92 = RegExp("</" + l11[2], "g")), n17 = O26) : void 0 !== l11[3] && (n17 = O26) : n17 === O26 ? ">" === l11[0] ? (n17 = h92 ?? T26, c92 = -1) : void 0 === l11[1] ? c92 = -2 : (c92 = n17.lastIndex - l11[2].length, r112 = l11[1], n17 = void 0 === l11[3] ? O26 : '"' === l11[3] ? j26 : S42) : n17 === j26 || n17 === S42 ? n17 = O26 : n17 === E26 || n17 === k26 ? n17 = T26 : (n17 = O26, h92 = void 0);
    const u62 = n17 === O26 && t11[i13 + 1].startsWith("/>") ? " " : "";
    o15 += n17 === T26 ? s10 + _26 : c92 >= 0 ? (e17.push(r112), s10.slice(0, c92) + f52 + s10.slice(c92) + v26 + u62) : s10 + v26 + (-2 === c92 ? i13 : u62);
  }
  return [N26(t11, o15 + (t11[s9] || "<?>") + (2 === i12 ? "</svg>" : 3 === i12 ? "</math>" : "")), e17];
};
var B26 = class _B26 {
  constructor({ strings: t11, _$litType$: i12 }, s9) {
    let e17;
    this.parts = [];
    let h92 = 0, o15 = 0;
    const n17 = t11.length - 1, r112 = this.parts, [l11, a72] = U26(t11, i12);
    if (this.el = _B26.createElement(l11, s9), I26.currentNode = this.el.content, 2 === i12 || 3 === i12) {
      const t12 = this.el.content.firstChild;
      t12.replaceWith(...t12.childNodes);
    }
    for (; null !== (e17 = I26.nextNode()) && r112.length < n17; ) {
      if (1 === e17.nodeType) {
        if (e17.hasAttributes()) for (const t12 of e17.getAttributeNames()) if (t12.endsWith(f52)) {
          const i13 = a72[o15++], s10 = e17.getAttribute(t12).split(v26), n18 = /([.?@])?(.*)/.exec(i13);
          r112.push({ type: 1, index: h92, name: n18[2], strings: s10, ctor: "." === n18[1] ? Y26 : "?" === n18[1] ? Z26 : "@" === n18[1] ? q26 : G26 }), e17.removeAttribute(t12);
        } else t12.startsWith(v26) && (r112.push({ type: 6, index: h92 }), e17.removeAttribute(t12));
        if (M26.test(e17.tagName)) {
          const t12 = e17.textContent.split(v26), i13 = t12.length - 1;
          if (i13 > 0) {
            e17.textContent = c62 ? c62.emptyScript : "";
            for (let s10 = 0; s10 < i13; s10++) e17.append(t12[s10], lt26()), I26.nextNode(), r112.push({ type: 2, index: ++h92 });
            e17.append(t12[i13], lt26());
          }
        }
      } else if (8 === e17.nodeType) if (e17.data === m26) r112.push({ type: 2, index: h92 });
      else {
        let t12 = -1;
        for (; -1 !== (t12 = e17.data.indexOf(v26, t12 + 1)); ) r112.push({ type: 7, index: h92 }), t12 += v26.length - 1;
      }
      h92++;
    }
  }
  static createElement(t11, i12) {
    const s9 = w26.createElement("template");
    return s9.innerHTML = t11, s9;
  }
};
function z26(t11, i12, s9 = t11, e17) {
  if (i12 === R26) return i12;
  let h92 = void 0 !== e17 ? s9.o?.[e17] : s9.l;
  const o15 = st26(i12) ? void 0 : i12._$litDirective$;
  return h92?.constructor !== o15 && (h92?._$AO?.(false), void 0 === o15 ? h92 = void 0 : (h92 = new o15(t11), h92._$AT(t11, s9, e17)), void 0 !== e17 ? (s9.o ??= [])[e17] = h92 : s9.l = h92), void 0 !== h92 && (i12 = z26(t11, h92._$AS(t11, i12.values), h92, e17)), i12;
}
var F26 = class {
  constructor(t11, i12) {
    this._$AV = [], this._$AN = void 0, this._$AD = t11, this._$AM = i12;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t11) {
    const { el: { content: i12 }, parts: s9 } = this._$AD, e17 = (t11?.creationScope ?? w26).importNode(i12, true);
    I26.currentNode = e17;
    let h92 = I26.nextNode(), o15 = 0, n17 = 0, r112 = s9[0];
    for (; void 0 !== r112; ) {
      if (o15 === r112.index) {
        let i13;
        2 === r112.type ? i13 = new et26(h92, h92.nextSibling, this, t11) : 1 === r112.type ? i13 = new r112.ctor(h92, r112.name, r112.strings, this, t11) : 6 === r112.type && (i13 = new K26(h92, this, t11)), this._$AV.push(i13), r112 = s9[++n17];
      }
      o15 !== r112?.index && (h92 = I26.nextNode(), o15++);
    }
    return I26.currentNode = w26, e17;
  }
  p(t11) {
    let i12 = 0;
    for (const s9 of this._$AV) void 0 !== s9 && (void 0 !== s9.strings ? (s9._$AI(t11, s9, i12), i12 += s9.strings.length - 2) : s9._$AI(t11[i12])), i12++;
  }
};
var et26 = class _et26 {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t11, i12, s9, e17) {
    this.type = 2, this._$AH = D26, this._$AN = void 0, this._$AA = t11, this._$AB = i12, this._$AM = s9, this.options = e17, this.v = e17?.isConnected ?? true;
  }
  get parentNode() {
    let t11 = this._$AA.parentNode;
    const i12 = this._$AM;
    return void 0 !== i12 && 11 === t11?.nodeType && (t11 = i12.parentNode), t11;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t11, i12 = this) {
    t11 = z26(this, t11, i12), st26(t11) ? t11 === D26 || null == t11 || "" === t11 ? (this._$AH !== D26 && this._$AR(), this._$AH = D26) : t11 !== this._$AH && t11 !== R26 && this._(t11) : void 0 !== t11._$litType$ ? this.$(t11) : void 0 !== t11.nodeType ? this.T(t11) : $26(t11) ? this.k(t11) : this._(t11);
  }
  O(t11) {
    return this._$AA.parentNode.insertBefore(t11, this._$AB);
  }
  T(t11) {
    this._$AH !== t11 && (this._$AR(), this._$AH = this.O(t11));
  }
  _(t11) {
    this._$AH !== D26 && st26(this._$AH) ? this._$AA.nextSibling.data = t11 : this.T(w26.createTextNode(t11)), this._$AH = t11;
  }
  $(t11) {
    const { values: i12, _$litType$: s9 } = t11, e17 = "number" == typeof s9 ? this._$AC(t11) : (void 0 === s9.el && (s9.el = B26.createElement(N26(s9.h, s9.h[0]), this.options)), s9);
    if (this._$AH?._$AD === e17) this._$AH.p(i12);
    else {
      const t12 = new F26(e17, this), s10 = t12.u(this.options);
      t12.p(i12), this.T(s10), this._$AH = t12;
    }
  }
  _$AC(t11) {
    let i12 = V26.get(t11.strings);
    return void 0 === i12 && V26.set(t11.strings, i12 = new B26(t11)), i12;
  }
  k(t11) {
    g26(this._$AH) || (this._$AH = [], this._$AR());
    const i12 = this._$AH;
    let s9, e17 = 0;
    for (const h92 of t11) e17 === i12.length ? i12.push(s9 = new _et26(this.O(lt26()), this.O(lt26()), this, this.options)) : s9 = i12[e17], s9._$AI(h92), e17++;
    e17 < i12.length && (this._$AR(s9 && s9._$AB.nextSibling, e17), i12.length = e17);
  }
  _$AR(t11 = this._$AA.nextSibling, i12) {
    for (this._$AP?.(false, true, i12); t11 && t11 !== this._$AB; ) {
      const i13 = t11.nextSibling;
      t11.remove(), t11 = i13;
    }
  }
  setConnected(t11) {
    void 0 === this._$AM && (this.v = t11, this._$AP?.(t11));
  }
};
var G26 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t11, i12, s9, e17, h92) {
    this.type = 1, this._$AH = D26, this._$AN = void 0, this.element = t11, this.name = i12, this._$AM = e17, this.options = h92, s9.length > 2 || "" !== s9[0] || "" !== s9[1] ? (this._$AH = Array(s9.length - 1).fill(new String()), this.strings = s9) : this._$AH = D26;
  }
  _$AI(t11, i12 = this, s9, e17) {
    const h92 = this.strings;
    let o15 = false;
    if (void 0 === h92) t11 = z26(this, t11, i12, 0), o15 = !st26(t11) || t11 !== this._$AH && t11 !== R26, o15 && (this._$AH = t11);
    else {
      const e18 = t11;
      let n17, r112;
      for (t11 = h92[0], n17 = 0; n17 < h92.length - 1; n17++) r112 = z26(this, e18[s9 + n17], i12, n17), r112 === R26 && (r112 = this._$AH[n17]), o15 ||= !st26(r112) || r112 !== this._$AH[n17], r112 === D26 ? t11 = D26 : t11 !== D26 && (t11 += (r112 ?? "") + h92[n17 + 1]), this._$AH[n17] = r112;
    }
    o15 && !e17 && this.j(t11);
  }
  j(t11) {
    t11 === D26 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t11 ?? "");
  }
};
var Y26 = class extends G26 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t11) {
    this.element[this.name] = t11 === D26 ? void 0 : t11;
  }
};
var Z26 = class extends G26 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t11) {
    this.element.toggleAttribute(this.name, !!t11 && t11 !== D26);
  }
};
var q26 = class extends G26 {
  constructor(t11, i12, s9, e17, h92) {
    super(t11, i12, s9, e17, h92), this.type = 5;
  }
  _$AI(t11, i12 = this) {
    if ((t11 = z26(this, t11, i12, 0) ?? D26) === R26) return;
    const s9 = this._$AH, e17 = t11 === D26 && s9 !== D26 || t11.capture !== s9.capture || t11.once !== s9.once || t11.passive !== s9.passive, h92 = t11 !== D26 && (s9 === D26 || e17);
    e17 && this.element.removeEventListener(this.name, this, s9), h92 && this.element.addEventListener(this.name, this, t11), this._$AH = t11;
  }
  handleEvent(t11) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t11) : this._$AH.handleEvent(t11);
  }
};
var K26 = class {
  constructor(t11, i12, s9) {
    this.element = t11, this.type = 6, this._$AN = void 0, this._$AM = i12, this.options = s9;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t11) {
    z26(this, t11);
  }
};
var Re26 = n72.litHtmlPolyfillSupport;
Re26?.(B26, et26), (n72.litHtmlVersions ??= []).push("3.2.0");
var Q26 = (t11, i12, s9) => {
  const e17 = s9?.renderBefore ?? i12;
  let h92 = e17._$litPart$;
  if (void 0 === h92) {
    const t12 = s9?.renderBefore ?? null;
    e17._$litPart$ = h92 = new et26(i12.insertBefore(lt26(), t12), t12, void 0, s9 ?? {});
  }
  return h92._$AI(t11), h92;
};
var h62 = class extends b26 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t11 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t11.firstChild, t11;
  }
  update(t11) {
    const e17 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t11), this.o = Q26(e17, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R26;
  }
};
h62._$litElement$ = true, h62["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h62 });
var f62 = globalThis.litElementPolyfillSupport;
f62?.({ LitElement: h62 });
(globalThis.litElementVersions ??= []).push("4.1.0");
var t36 = (t11) => (e17, o15) => {
  void 0 !== o15 ? o15.addInitializer(() => {
    customElements.define(t11, e17);
  }) : customElements.define(t11, e17);
};
var o63 = { attribute: true, type: String, converter: u26, reflect: false, hasChanged: f46 };
var r63 = (t11 = o63, e17, r112) => {
  const { kind: n17, metadata: i12 } = r112;
  let s9 = globalThis.litPropertyMetadata.get(i12);
  if (void 0 === s9 && globalThis.litPropertyMetadata.set(i12, s9 = /* @__PURE__ */ new Map()), s9.set(r112.name, t11), "accessor" === n17) {
    const { name: o15 } = r112;
    return { set(r12) {
      const n18 = e17.get.call(this);
      e17.set.call(this, r12), this.requestUpdate(o15, n18, t11);
    }, init(e18) {
      return void 0 !== e18 && this.P(o15, void 0, t11), e18;
    } };
  }
  if ("setter" === n17) {
    const { name: o15 } = r112;
    return function(r12) {
      const n18 = this[o15];
      e17.call(this, r12), this.requestUpdate(o15, n18, t11);
    };
  }
  throw Error("Unsupported decorator location: " + n17);
};
function n82(t11) {
  return (e17, o15) => "object" == typeof o15 ? r63(t11, e17, o15) : ((t12, e18, o16) => {
    const r112 = e18.hasOwnProperty(o16);
    return e18.constructor.createProperty(o16, r112 ? { ...t12, wrapped: true } : t12), r112 ? Object.getOwnPropertyDescriptor(e18, o16) : void 0;
  })(t11, e17, o15);
}
var e56 = (e17, t11, c92) => (c92.configurable = true, c92.enumerable = true, Reflect.decorate && "object" != typeof t11 && Object.defineProperty(e17, t11, c92), c92);
function e65(e17, r112) {
  return (n17, s9, i12) => {
    const o15 = (t11) => t11.renderRoot?.querySelector(e17) ?? null;
    if (r112) {
      const { get: e18, set: r12 } = "object" == typeof s9 ? n17 : i12 ?? (() => {
        const t11 = Symbol();
        return { get() {
          return this[t11];
        }, set(e19) {
          this[t11] = e19;
        } };
      })();
      return e56(n17, s9, { get() {
        let t11 = e18.call(this);
        return void 0 === t11 && (t11 = o15(this), (null !== t11 || this.hasUpdated) && r12.call(this, t11)), t11;
      } });
    }
    return e56(n17, s9, { get() {
      return o15(this);
    } });
  };
}
var t46 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e72 = (t11) => (...e17) => ({ _$litDirective$: t11, values: e17 });
var i42 = class {
  constructor(t11) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t11, e17, i12) {
    this.t = t11, this._$AM = e17, this.i = i12;
  }
  _$AS(t11, e17) {
    return this.update(t11, e17);
  }
  update(t11, e17) {
    return this.render(...e17);
  }
};
var ee4 = "important";
var ie4 = " !" + ee4;
var se4 = e72(class extends i42 {
  constructor(e17) {
    if (super(e17), e17.type !== t46.ATTRIBUTE || "style" !== e17.name || e17.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t11) {
    return Object.keys(t11).reduce((e17, r112) => {
      const s9 = t11[r112];
      return null == s9 ? e17 : e17 + `${r112 = r112.includes("-") ? r112 : r112.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s9};`;
    }, "");
  }
  update(t11, [e17]) {
    const { style: r112 } = t11.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(e17)), this.render(e17);
    for (const t12 of this.ft) null == e17[t12] && (this.ft.delete(t12), t12.includes("-") ? r112.removeProperty(t12) : r112[t12] = null);
    for (const t12 in e17) {
      const s9 = e17[t12];
      if (null != s9) {
        this.ft.add(t12);
        const e18 = "string" == typeof s9 && s9.endsWith(ie4);
        t12.includes("-") || e18 ? r112.setProperty(t12, e18 ? s9.slice(0, -11) : s9, e18 ? ee4 : "") : r112[t12] = s9;
      }
    }
    return R26;
  }
});
var style = i7`
    .toolbox > * {
        margin-bottom: 1em;
    }

    .position {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
    }

    .position sl-input {
        width: calc(50% - 10px);
    }

    .button-group-toolbar sl-button-group:not(:last-of-type) {
        margin-right: var(--sl-spacing-x-small);
    }

    .marker-icon {
        width: 20px !important;
        height: 20px !important;
    }

    .marker-icon::before {
        content: '';
        position: absolute;
        inset: 0;

        border-bottom-left-radius: 50%;
        border-top-left-radius: 50%;
        border-top-right-radius: 50%;

        rotate: 45deg;
    }

    .marker-icon::after {
        content: '';
        position: absolute;
        inset: 6px;
        border-radius: 50%;
        background-color: white;
    }

    .marker-icon.marker-icon-red::before {
        background-color: red;
    }

    .marker-icon.marker-icon-green::before {
        background-color: green;
    }

    .marker-icon.marker-icon-blue::before {
        background-color: blue;
    }

    .marker-icon.marker-icon-yellow::before {
        background-color: yellow;
    }

    .mouse-marker-icon {
        width: 1.5em;
        height: 1.5em;
        background-color: blue;
    }

    sl-button::part(base) {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    sl-dialog {
        z-index: 2000;
    }
    sl-button {
        margin-block: 5px;
        width: 100%;
    }
`;
var leafletStyles = i7`
    .leaflet-pane,
    .leaflet-tile,
    .leaflet-marker-icon,
    .leaflet-marker-shadow,
    .leaflet-tile-container,
    .leaflet-pane > svg,
    .leaflet-pane > canvas,
    .leaflet-zoom-box,
    .leaflet-image-layer,
    .leaflet-layer {
        position: absolute;
        left: 0;
        top: 0;
    }
    .leaflet-container {
        overflow: hidden;
    }
    .leaflet-tile,
    .leaflet-marker-icon,
    .leaflet-marker-shadow {
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
        -webkit-user-drag: none;
    }
    /* Prevents IE11 from highlighting tiles in blue */
    .leaflet-tile::selection {
        background: transparent;
    }
    /* Safari renders non-retina tile on retina better with this, but Chrome is worse */
    .leaflet-safari .leaflet-tile {
        image-rendering: -webkit-optimize-contrast;
    }
    /* hack that prevents hw layers "stretching" when loading new tiles */
    .leaflet-safari .leaflet-tile-container {
        width: 1600px;
        height: 1600px;
        -webkit-transform-origin: 0 0;
    }
    .leaflet-marker-icon,
    .leaflet-marker-shadow {
        display: block;
    }
    /* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */
    /* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */
    .leaflet-container .leaflet-overlay-pane svg {
        max-width: none !important;
        max-height: none !important;
    }
    .leaflet-container .leaflet-marker-pane img,
    .leaflet-container .leaflet-shadow-pane img,
    .leaflet-container .leaflet-tile-pane img,
    .leaflet-container img.leaflet-image-layer,
    .leaflet-container .leaflet-tile {
        max-width: none !important;
        max-height: none !important;
        width: auto;
        padding: 0;
    }

    .leaflet-container img.leaflet-tile {
        /* See: https://bugs.chromium.org/p/chromium/issues/detail?id=600120 */
        mix-blend-mode: plus-lighter;
    }

    .leaflet-container.leaflet-touch-zoom {
        -ms-touch-action: pan-x pan-y;
        touch-action: pan-x pan-y;
    }
    .leaflet-container.leaflet-touch-drag {
        -ms-touch-action: pinch-zoom;

        /* Fallback for FF which doesn't support pinch-zoom */
        touch-action: none;
        touch-action: pinch-zoom;
    }
    .leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {
        -ms-touch-action: none;
        touch-action: none;
    }
    .leaflet-container {
        -webkit-tap-highlight-color: transparent;
    }
    .leaflet-container a {
        -webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);
    }
    .leaflet-tile {
        filter: inherit;
        visibility: hidden;
    }
    .leaflet-tile-loaded {
        visibility: inherit;
    }
    .leaflet-zoom-box {
        width: 0;
        height: 0;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 800;
    }
    /* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */
    .leaflet-overlay-pane svg {
        -moz-user-select: none;
    }

    .leaflet-pane {
        z-index: 400;
    }

    .leaflet-tile-pane {
        z-index: 200;
    }
    .leaflet-overlay-pane {
        z-index: 400;
    }
    .leaflet-shadow-pane {
        z-index: 500;
    }
    .leaflet-marker-pane {
        z-index: 600;
    }
    .leaflet-tooltip-pane {
        z-index: 650;
    }
    .leaflet-popup-pane {
        z-index: 700;
    }

    .leaflet-map-pane canvas {
        z-index: 100;
    }
    .leaflet-map-pane svg {
        z-index: 200;
    }

    .leaflet-vml-shape {
        width: 1px;
        height: 1px;
    }
    .lvml {
        behavior: url(#default#VML);
        display: inline-block;
        position: absolute;
    }

    /* control positioning */

    .leaflet-control {
        position: relative;
        z-index: 800;
        pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
        pointer-events: auto;
    }
    .leaflet-top,
    .leaflet-bottom {
        position: absolute;
        z-index: 1000;
        pointer-events: none;
    }
    .leaflet-top {
        top: 0;
    }
    .leaflet-right {
        right: 0;
    }
    .leaflet-bottom {
        bottom: 0;
    }
    .leaflet-left {
        left: 0;
    }
    .leaflet-control {
        float: left;
        clear: both;
    }
    .leaflet-right .leaflet-control {
        float: right;
    }
    .leaflet-top .leaflet-control {
        margin-top: 10px;
    }
    .leaflet-bottom .leaflet-control {
        margin-bottom: 10px;
    }
    .leaflet-left .leaflet-control {
        margin-left: 10px;
    }
    .leaflet-right .leaflet-control {
        margin-right: 10px;
    }

    /* zoom and fade animations */

    .leaflet-fade-anim .leaflet-popup {
        opacity: 0;
        -webkit-transition: opacity 0.2s linear;
        -moz-transition: opacity 0.2s linear;
        transition: opacity 0.2s linear;
    }
    .leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
        opacity: 1;
    }
    .leaflet-zoom-animated {
        -webkit-transform-origin: 0 0;
        -ms-transform-origin: 0 0;
        transform-origin: 0 0;
    }
    svg.leaflet-zoom-animated {
        will-change: transform;
    }

    .leaflet-zoom-anim .leaflet-zoom-animated {
        -webkit-transition: -webkit-transform 0.25s cubic-bezier(0, 0, 0.25, 1);
        -moz-transition: -moz-transform 0.25s cubic-bezier(0, 0, 0.25, 1);
        transition: transform 0.25s cubic-bezier(0, 0, 0.25, 1);
    }
    .leaflet-zoom-anim .leaflet-tile,
    .leaflet-pan-anim .leaflet-tile {
        -webkit-transition: none;
        -moz-transition: none;
        transition: none;
    }

    .leaflet-zoom-anim .leaflet-zoom-hide {
        visibility: hidden;
    }

    /* cursors */

    .leaflet-interactive {
        cursor: pointer;
    }
    .leaflet-grab {
        cursor: -webkit-grab;
        cursor: -moz-grab;
        cursor: grab;
    }
    .leaflet-crosshair,
    .leaflet-crosshair .leaflet-interactive {
        cursor: crosshair;
    }
    .leaflet-popup-pane,
    .leaflet-control {
        cursor: auto;
    }
    .leaflet-dragging .leaflet-grab,
    .leaflet-dragging .leaflet-grab .leaflet-interactive,
    .leaflet-dragging .leaflet-marker-draggable {
        cursor: move;
        cursor: -webkit-grabbing;
        cursor: -moz-grabbing;
        cursor: grabbing;
    }

    /* marker & overlays interactivity */
    .leaflet-marker-icon,
    .leaflet-marker-shadow,
    .leaflet-image-layer,
    .leaflet-pane > svg path,
    .leaflet-tile-container {
        pointer-events: none;
    }

    .leaflet-marker-icon.leaflet-interactive,
    .leaflet-image-layer.leaflet-interactive,
    .leaflet-pane > svg path.leaflet-interactive,
    svg.leaflet-image-layer.leaflet-interactive path {
        pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
        pointer-events: auto;
    }

    /* visual tweaks */

    .leaflet-container {
        background: #ddd;
        outline-offset: 1px;
    }
    .leaflet-container a {
        color: #0078a8;
    }
    .leaflet-zoom-box {
        border: 2px dotted #38f;
        background: rgba(255, 255, 255, 0.5);
    }

    /* general typography */
    .leaflet-container {
        font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;
        font-size: 12px;
        font-size: 0.75rem;
        line-height: 1.5;
    }

    /* general toolbar styles */

    .leaflet-bar {
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
        border-radius: 4px;
    }
    .leaflet-bar a {
        background-color: #fff;
        border-bottom: 1px solid #ccc;
        width: 26px;
        height: 26px;
        line-height: 26px;
        display: block;
        text-align: center;
        text-decoration: none;
        color: black;
    }
    .leaflet-bar a,
    .leaflet-control-layers-toggle {
        background-position: 50% 50%;
        background-repeat: no-repeat;
        display: block;
    }
    .leaflet-bar a:hover,
    .leaflet-bar a:focus {
        background-color: #f4f4f4;
    }
    .leaflet-bar a:first-child {
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
    }
    .leaflet-bar a:last-child {
        border-bottom-left-radius: 4px;
        border-bottom-right-radius: 4px;
        border-bottom: none;
    }
    .leaflet-bar a.leaflet-disabled {
        cursor: default;
        background-color: #f4f4f4;
        color: #bbb;
    }

    .leaflet-touch .leaflet-bar a {
        width: 30px;
        height: 30px;
        line-height: 30px;
    }
    .leaflet-touch .leaflet-bar a:first-child {
        border-top-left-radius: 2px;
        border-top-right-radius: 2px;
    }
    .leaflet-touch .leaflet-bar a:last-child {
        border-bottom-left-radius: 2px;
        border-bottom-right-radius: 2px;
    }

    /* zoom control */

    .leaflet-control-zoom-in,
    .leaflet-control-zoom-out {
        font: bold 18px 'Lucida Console', Monaco, monospace;
        text-indent: 1px;
    }

    .leaflet-touch .leaflet-control-zoom-in,
    .leaflet-touch .leaflet-control-zoom-out {
        font-size: 22px;
    }

    /* layers control */

    .leaflet-control-layers {
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);
        background: #fff;
        border-radius: 5px;
    }
    .leaflet-control-layers-toggle {
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAQAAAADQ4RFAAACf0lEQVR4AY1UM3gkARTePdvdoTxXKc+qTl3aU5U6b2Kbkz3Gtq3Zw6ziLGNPzrYx7946Tr6/ee/XeCQ4D3ykPtL5tHno4n0d/h3+xfuWHGLX81cn7r0iTNzjr7LrlxCqPtkbTQEHeqOrTy4Yyt3VCi/IOB0v7rVC7q45Q3Gr5K6jt+3Gl5nCoDD4MtO+j96Wu8atmhGqcNGHObuf8OM/x3AMx38+4Z2sPqzCxRFK2aF2e5Jol56XTLyggAMTL56XOMoS1W4pOyjUcGGQdZxU6qRh7B9Zp+PfpOFlqt0zyDZckPi1ttmIp03jX8gyJ8a/PG2yutpS/Vol7peZIbZcKBAEEheEIAgFbDkz5H6Zrkm2hVWGiXKiF4Ycw0RWKdtC16Q7qe3X4iOMxruonzegJzWaXFrU9utOSsLUmrc0YjeWYjCW4PDMADElpJSSQ0vQvA1Tm6/JlKnqFs1EGyZiFCqnRZTEJJJiKRYzVYzJck2Rm6P4iH+cmSY0YzimYa8l0EtTODFWhcMIMVqdsI2uiTvKmTisIDHJ3od5GILVhBCarCfVRmo4uTjkhrhzkiBV7SsaqS+TzrzM1qpGGUFt28pIySQHR6h7F6KSwGWm97ay+Z+ZqMcEjEWebE7wxCSQwpkhJqoZA5ivCdZDjJepuJ9IQjGGUmuXJdBFUygxVqVsxFsLMbDe8ZbDYVCGKxs+W080max1hFCarCfV+C1KATwcnvE9gRRuMP2prdbWGowm1KB1y+zwMMENkM755cJ2yPDtqhTI6ED1M/82yIDtC/4j4BijjeObflpO9I9MwXTCsSX8jWAFeHr05WoLTJ5G8IQVS/7vwR6ohirYM7f6HzYpogfS3R2OAAAAAElFTkSuQmCC');
        width: 36px;
        height: 36px;
    }
    .leaflet-retina .leaflet-control-layers-toggle {
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAQAAABvcdNgAAAEsklEQVR4AWL4TydIhpZK1kpWOlg0w3ZXP6D2soBtG42jeI6ZmQTHzAxiTbSJsYLjO9HhP+WOmcuhciVnmHVQcJnp7DFvScowZorad/+V/fVzMdMT2g9Cv9guXGv/7pYOrXh2U+RRR3dSd9JRx6bIFc/ekqHI29JC6pJ5ZEh1yWkhkbcFeSjxgx3L2m1cb1C7bceyxA+CNjT/Ifff+/kDk2u/w/33/IeCMOSaWZ4glosqT3DNnNZQ7Cs58/3Ce5HL78iZH/vKVIaYlqzfdLu8Vi7dnvUbEza5Idt36tquZFldl6N5Z/POLof0XLK61mZCmJSWjVF9tEjUluu74IUXvgttuVIHE7YxSkaYhJZam7yiM9Pv82JYfl9nptxZaxMJE4YSPty+vF0+Y2up9d3wwijfjZbabqm/3bZ9ecKHsiGmRflnn1MW4pjHf9oLufyn2z3y1D6n8g8TZhxyzipLNPnAUpsOiuWimg52psrTZYnOWYNDTMuWBWa0tJb4rgq1UvmutpaYEbZlwU3CLJm/ayYjHW5/h7xWLn9Hh1vepDkyf7dE7MtT5LR4e7yYpHrkhOUpEfssBLq2pPhAqoSWKUkk7EDqkmK6RrCEzqDjhNDWNE+XSMvkJRDWlZTmCW0l0PHQGRZY5t1L83kT0Y3l2SItk5JAWHl2dCOBm+fPu3fo5/3v61RMCO9Jx2EEYYhb0rmNQMX/vm7gqOEJLcXTGw3CAuRNeyaPWwjR8PRqKQ1PDA/dpv+on9Shox52WFnx0KY8onHayrJzm87i5h9xGw/tfkev0jGsQizqezUKjk12hBMKJ4kbCqGPVNXudyyrShovGw5CgxsRICxF6aRmSjlBnHRzg7Gx8fKqEubI2rahQYdR1YgDIRQO7JvQyD52hoIQx0mxa0ODtW2Iozn1le2iIRdzwWewedyZzewidueOGqlsn1MvcnQpuVwLGG3/IR1hIKxCjelIDZ8ldqWz25jWAsnldEnK0Zxro19TGVb2ffIZEsIO89EIEDvKMPrzmBOQcKQ+rroye6NgRRxqR4U8EAkz0CL6uSGOm6KQCdWjvjRiSP1BPalCRS5iQYiEIvxuBMJEWgzSoHADcVMuN7IuqqTeyUPq22qFimFtxDyBBJEwNyt6TM88blFHao/6tWWhuuOM4SAK4EI4QmFHA+SEyWlp4EQoJ13cYGzMu7yszEIBOm2rVmHUNqwAIQabISNMRstmdhNWcFLsSm+0tjJH1MdRxO5Nx0WDMhCtgD6OKgZeljJqJKc9po8juskR9XN0Y1lZ3mWjLR9JCO1jRDMd0fpYC2VnvjBSEFg7wBENc0R9HFlb0xvF1+TBEpF68d+DHR6IOWVv2BECtxo46hOFUBd/APU57WIoEwJhIi2CdpyZX0m93BZicktMj1AS9dClteUFAUNUIEygRZCtik5zSxI9MubTBH1GOiHsiLJ3OCoSZkILa9PxiN0EbvhsAo8tdAf9Seepd36lGWHmtNANTv5Jd0z4QYyeo/UEJqxKRpg5LZx6btLPsOaEmdMyxYdlc8LMaJnikDlhclqmPiQnTEpLUIZEwkRagjYkEibQErwhkTAKCLQEbUgkzJQWc/0PstHHcfEdQ+UAAAAASUVORK5CYII=');
        background-size: 26px 26px;
    }
    .leaflet-touch .leaflet-control-layers-toggle {
        width: 44px;
        height: 44px;
    }
    .leaflet-control-layers .leaflet-control-layers-list,
    .leaflet-control-layers-expanded .leaflet-control-layers-toggle {
        display: none;
    }
    .leaflet-control-layers-expanded .leaflet-control-layers-list {
        display: block;
        position: relative;
    }
    .leaflet-control-layers-expanded {
        padding: 6px 10px 6px 6px;
        color: #333;
        background: #fff;
    }
    .leaflet-control-layers-scrollbar {
        overflow-y: scroll;
        overflow-x: hidden;
        padding-right: 5px;
    }
    .leaflet-control-layers-selector {
        margin-top: 2px;
        position: relative;
        top: 1px;
    }
    .leaflet-control-layers label {
        display: block;
        font-size: 13px;
        font-size: 1.08333em;
    }
    .leaflet-control-layers-separator {
        height: 0;
        border-top: 1px solid #ddd;
        margin: 5px -10px 5px -6px;
    }

    /* Default icon URLs */
    .leaflet-default-icon-path {
        /* used only in path-guessing heuristic, see L.Icon.Default */
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=');
    }

    /* attribution and scale controls */

    .leaflet-container .leaflet-control-attribution {
        background: #fff;
        background: rgba(255, 255, 255, 0.8);
        margin: 0;
    }
    .leaflet-control-attribution,
    .leaflet-control-scale-line {
        padding: 0 5px;
        color: #333;
        line-height: 1.4;
    }
    .leaflet-control-attribution a {
        text-decoration: none;
    }
    .leaflet-control-attribution a:hover,
    .leaflet-control-attribution a:focus {
        text-decoration: underline;
    }
    .leaflet-attribution-flag {
        display: inline !important;
        vertical-align: baseline !important;
        width: 1em;
        height: 0.6669em;
    }
    .leaflet-left .leaflet-control-scale {
        margin-left: 5px;
    }
    .leaflet-bottom .leaflet-control-scale {
        margin-bottom: 5px;
    }
    .leaflet-control-scale-line {
        border: 2px solid #777;
        border-top: none;
        line-height: 1.1;
        padding: 2px 5px 1px;
        white-space: nowrap;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        background: rgba(255, 255, 255, 0.8);
        text-shadow: 1px 1px #fff;
    }
    .leaflet-control-scale-line:not(:first-child) {
        border-top: 2px solid #777;
        border-bottom: none;
        margin-top: -2px;
    }
    .leaflet-control-scale-line:not(:first-child):not(:last-child) {
        border-bottom: 2px solid #777;
    }

    .leaflet-touch .leaflet-control-attribution,
    .leaflet-touch .leaflet-control-layers,
    .leaflet-touch .leaflet-bar {
        box-shadow: none;
    }
    .leaflet-touch .leaflet-control-layers,
    .leaflet-touch .leaflet-bar {
        border: 2px solid rgba(0, 0, 0, 0.2);
        background-clip: padding-box;
    }

    /* popup */

    .leaflet-popup {
        position: absolute;
        text-align: center;
        margin-bottom: 20px;
    }
    .leaflet-popup-content-wrapper {
        padding: 1px;
        text-align: left;
        border-radius: 12px;
    }
    .leaflet-popup-content {
        margin: 13px 24px 13px 20px;
        line-height: 1.3;
        font-size: 13px;
        font-size: 1.08333em;
        min-height: 1px;
    }
    .leaflet-popup-content p {
        margin: 17px 0;
        margin: 1.3em 0;
    }
    .leaflet-popup-tip-container {
        width: 40px;
        height: 20px;
        position: absolute;
        left: 50%;
        margin-top: -1px;
        margin-left: -20px;
        overflow: hidden;
        pointer-events: none;
    }
    .leaflet-popup-tip {
        width: 17px;
        height: 17px;
        padding: 1px;

        margin: -10px auto 0;
        pointer-events: auto;

        -webkit-transform: rotate(45deg);
        -moz-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        transform: rotate(45deg);
    }
    .leaflet-popup-content-wrapper,
    .leaflet-popup-tip {
        background: white;
        color: #333;
        box-shadow: 0 3px 14px rgba(0, 0, 0, 0.4);
    }
    .leaflet-container a.leaflet-popup-close-button {
        position: absolute;
        top: 0;
        right: 0;
        border: none;
        text-align: center;
        width: 24px;
        height: 24px;
        font: 16px/24px Tahoma, Verdana, sans-serif;
        color: #757575;
        text-decoration: none;
        background: transparent;
    }
    .leaflet-container a.leaflet-popup-close-button:hover,
    .leaflet-container a.leaflet-popup-close-button:focus {
        color: #585858;
    }
    .leaflet-popup-scrolled {
        overflow: auto;
    }

    .leaflet-oldie .leaflet-popup-content-wrapper {
        -ms-zoom: 1;
    }
    .leaflet-oldie .leaflet-popup-tip {
        width: 24px;
        margin: 0 auto;

        -ms-filter: 'progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)';
        filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
    }

    .leaflet-oldie .leaflet-control-zoom,
    .leaflet-oldie .leaflet-control-layers,
    .leaflet-oldie .leaflet-popup-content-wrapper,
    .leaflet-oldie .leaflet-popup-tip {
        border: 1px solid #999;
    }

    /* div icon */

    .leaflet-div-icon {
        background: #fff;
        border: 1px solid #666;
    }

    /* Tooltip */
    /* Base styles for the element that has a tooltip */
    .leaflet-tooltip {
        position: absolute;
        padding: 6px;
        background-color: #fff;
        border: 1px solid #fff;
        border-radius: 3px;
        color: #222;
        white-space: nowrap;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        pointer-events: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }
    .leaflet-tooltip.leaflet-interactive {
        cursor: pointer;
        pointer-events: auto;
    }
    .leaflet-tooltip-top:before,
    .leaflet-tooltip-bottom:before,
    .leaflet-tooltip-left:before,
    .leaflet-tooltip-right:before {
        position: absolute;
        pointer-events: none;
        border: 6px solid transparent;
        background: transparent;
        content: '';
    }

    /* Directions */

    .leaflet-tooltip-bottom {
        margin-top: 6px;
    }
    .leaflet-tooltip-top {
        margin-top: -6px;
    }
    .leaflet-tooltip-bottom:before,
    .leaflet-tooltip-top:before {
        left: 50%;
        margin-left: -6px;
    }
    .leaflet-tooltip-top:before {
        bottom: 0;
        margin-bottom: -12px;
        border-top-color: #fff;
    }
    .leaflet-tooltip-bottom:before {
        top: 0;
        margin-top: -12px;
        margin-left: -6px;
        border-bottom-color: #fff;
    }
    .leaflet-tooltip-left {
        margin-left: -6px;
    }
    .leaflet-tooltip-right {
        margin-left: 6px;
    }
    .leaflet-tooltip-left:before,
    .leaflet-tooltip-right:before {
        top: 50%;
        margin-top: -6px;
    }
    .leaflet-tooltip-left:before {
        right: 0;
        margin-right: -12px;
        border-left-color: #fff;
    }
    .leaflet-tooltip-right:before {
        left: 0;
        margin-left: -12px;
        border-right-color: #fff;
    }

    /* Printing */

    @media print {
        /* Prevent printers from removing background-images of controls. */
        .leaflet-control {
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
    }
`;
var L2 = __toESM(require_leaflet_src());
var icons5 = {
  RED: L2.divIcon({
    className: "marker-icon marker-icon-red",
    iconAnchor: [10, 20],
    iconSize: [20, 20]
  }),
  BLUE: L2.divIcon({
    className: "marker-icon marker-icon-blue",
    iconAnchor: [10, 20],
    iconSize: [20, 20]
  }),
  GREEN: L2.divIcon({
    className: "marker-icon marker-icon-green",
    iconAnchor: [10, 20],
    iconSize: [20, 20]
  }),
  YELLOW: L2.divIcon({
    className: "marker-icon marker-icon-yellow",
    iconAnchor: [10, 20],
    iconSize: [20, 20]
  })
};
var faLocationCrosshairs = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M256 0c17.7 0 32 14.3 32 32V66.7C368.4 80.1 431.9 143.6 445.3 224H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H445.3C431.9 368.4 368.4 431.9 288 445.3V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V445.3C143.6 431.9 80.1 368.4 66.7 288H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H66.7C80.1 143.6 143.6 80.1 224 66.7V32c0-17.7 14.3-32 32-32zM128 256a128 128 0 1 0 256 0 128 128 0 1 0 -256 0zm128-80a80 80 0 1 1 0 160 80 80 0 1 1 0-160z"
    />
</svg>`;
var faArrowPointer = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 320 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M0 55.2V426c0 12.2 9.9 22 22 22c6.3 0 12.4-2.7 16.6-7.5L121.2 346l58.1 116.3c7.9 15.8 27.1 22.2 42.9 14.3s22.2-27.1 14.3-42.9L179.8 320H297.9c12.2 0 22.1-9.9 22.1-22.1c0-6.3-2.7-12.3-7.4-16.5L38.6 37.9C34.3 34.1 28.9 32 23.2 32C10.4 32 0 42.4 0 55.2z"
    />
</svg>`;
var faMagnifyingGlassLocation = ke26`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="1em"
    viewBox="0 0 512 512"
>
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM288 176c0-44.2-35.8-80-80-80s-80 35.8-80 80c0 48.8 46.5 111.6 68.6 138.6c6 7.3 16.8 7.3 22.7 0c22.1-27 68.6-89.8 68.6-138.6zm-112 0a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"
    />
</svg>`;
var faMapLocationDot = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 576 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M408 120c0 54.6-73.1 151.9-105.2 192c-7.7 9.6-22 9.6-29.6 0C241.1 271.9 168 174.6 168 120C168 53.7 221.7 0 288 0s120 53.7 120 120zm8 80.4c3.5-6.9 6.7-13.8 9.6-20.6c.5-1.2 1-2.5 1.5-3.7l116-46.4C558.9 123.4 576 135 576 152V422.8c0 9.8-6 18.6-15.1 22.3L416 503V200.4zM137.6 138.3c2.4 14.1 7.2 28.3 12.8 41.5c2.9 6.8 6.1 13.7 9.6 20.6V451.8L32.9 502.7C17.1 509 0 497.4 0 480.4V209.6c0-9.8 6-18.6 15.1-22.3l122.6-49zM327.8 332c13.9-17.4 35.7-45.7 56.2-77V504.3L192 449.4V255c20.5 31.3 42.3 59.6 56.2 77c20.5 25.6 59.1 25.6 79.6 0zM288 152a40 40 0 1 0 0-80 40 40 0 1 0 0 80z"
    />
</svg>`;
var faLocationDot = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M215.7 499.2C267 435 384 279.4 384 192C384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2c12.3 15.3 35.1 15.3 47.4 0zM192 128a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"
    />
</svg>`;
var faStreetView = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M320 64A64 64 0 1 0 192 64a64 64 0 1 0 128 0zm-96 96c-35.3 0-64 28.7-64 64v48c0 17.7 14.3 32 32 32h1.8l11.1 99.5c1.8 16.2 15.5 28.5 31.8 28.5h38.7c16.3 0 30-12.3 31.8-28.5L318.2 304H320c17.7 0 32-14.3 32-32V224c0-35.3-28.7-64-64-64H224zM132.3 394.2c13-2.4 21.7-14.9 19.3-27.9s-14.9-21.7-27.9-19.3c-32.4 5.9-60.9 14.2-82 24.8c-10.5 5.3-20.3 11.7-27.8 19.6C6.4 399.5 0 410.5 0 424c0 21.4 15.5 36.1 29.1 45c14.7 9.6 34.3 17.3 56.4 23.4C130.2 504.7 190.4 512 256 512s125.8-7.3 170.4-19.6c22.1-6.1 41.8-13.8 56.4-23.4c13.7-8.9 29.1-23.6 29.1-45c0-13.5-6.4-24.5-14-32.6c-7.5-7.9-17.3-14.3-27.8-19.6c-21-10.6-49.5-18.9-82-24.8c-13-2.4-25.5 6.3-27.9 19.3s6.3 25.5 19.3 27.9c30.2 5.5 53.7 12.8 69 20.5c3.2 1.6 5.8 3.1 7.9 4.5c3.6 2.4 3.6 7.2 0 9.6c-8.8 5.7-23.1 11.8-43 17.3C374.3 457 318.5 464 256 464s-118.3-7-157.7-17.9c-19.9-5.5-34.2-11.6-43-17.3c-3.6-2.4-3.6-7.2 0-9.6c2.1-1.4 4.8-2.9 7.9-4.5c15.3-7.7 38.8-14.9 69-20.5z"
    />
</svg>`;
var faBorderTopLeft = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M0 448c0 17.7 14.3 32 32 32s32-14.3 32-32l0-336c0-8.8 7.2-16 16-16l336 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32C35.8 32 0 67.8 0 112L0 448zm160 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm192 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm-96 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm192 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM416 288a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm0 32a32 32 0 1 0 0 64 32 32 0 1 0 0-64zm0-128a32 32 0 1 0 0-64 32 32 0 1 0 0 64z"
    />
</svg>`;
var faBorderBottomRight = ke26`<svg
    xmlns="http://www.w3.org/2000/svg"
    height="1em"
    viewBox="0 0 448 512"
    style="rotate:180deg"
>
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M0 448c0 17.7 14.3 32 32 32s32-14.3 32-32l0-336c0-8.8 7.2-16 16-16l336 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32C35.8 32 0 67.8 0 112L0 448zm160 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm192 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm-96 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm192 0a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM416 288a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm0 32a32 32 0 1 0 0 64 32 32 0 1 0 0-64zm0-128a32 32 0 1 0 0-64 32 32 0 1 0 0 64z"
    />
</svg>`;
var faMagnifyingGlassPlus = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM184 296c0 13.3 10.7 24 24 24s24-10.7 24-24V232h64c13.3 0 24-10.7 24-24s-10.7-24-24-24H232V120c0-13.3-10.7-24-24-24s-24 10.7-24 24v64H120c-13.3 0-24 10.7-24 24s10.7 24 24 24h64v64z"
    />
</svg>`;
var faMagnifyingGlassMinus = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM136 184c-13.3 0-24 10.7-24 24s10.7 24 24 24H280c13.3 0 24-10.7 24-24s-10.7-24-24-24H136z"
    />
</svg>`;
var faCompress = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V64zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32H96v64c0 17.7 14.3 32 32 32s32-14.3 32-32V352c0-17.7-14.3-32-32-32H32zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H352V64zM320 320c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32s32-14.3 32-32V384h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H320z"
    />
</svg>`;
var faBan = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z"
    />
</svg>`;
var faEye = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 576 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"
    />
</svg>`;
var faEyeSlashed = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 640 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c8.4-19.3 10.6-41.4 4.8-63.3c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zM373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5L373 389.9z"
    />
</svg>`;
var faDrawPolygon = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M96 151.4V360.6c9.7 5.6 17.8 13.7 23.4 23.4H328.6c0-.1 .1-.2 .1-.3l-4.5-7.9-32-56 0 0c-1.4 .1-2.8 .1-4.2 .1c-35.3 0-64-28.7-64-64s28.7-64 64-64c1.4 0 2.8 0 4.2 .1l0 0 32-56 4.5-7.9-.1-.3H119.4c-5.6 9.7-13.7 17.8-23.4 23.4zM384.3 352c35.2 .2 63.7 28.7 63.7 64c0 35.3-28.7 64-64 64c-23.7 0-44.4-12.9-55.4-32H119.4c-11.1 19.1-31.7 32-55.4 32c-35.3 0-64-28.7-64-64c0-23.7 12.9-44.4 32-55.4V151.4C12.9 140.4 0 119.7 0 96C0 60.7 28.7 32 64 32c23.7 0 44.4 12.9 55.4 32H328.6c11.1-19.1 31.7-32 55.4-32c35.3 0 64 28.7 64 64c0 35.3-28.5 63.8-63.7 64l-4.5 7.9-32 56-2.3 4c4.2 8.5 6.5 18 6.5 28.1s-2.3 19.6-6.5 28.1l2.3 4 32 56 4.5 7.9z"
    />
</svg>`;
var faVectorSquare = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M368 80h32v32H368V80zM352 32c-17.7 0-32 14.3-32 32H128c0-17.7-14.3-32-32-32H32C14.3 32 0 46.3 0 64v64c0 17.7 14.3 32 32 32V352c-17.7 0-32 14.3-32 32v64c0 17.7 14.3 32 32 32H96c17.7 0 32-14.3 32-32H320c0 17.7 14.3 32 32 32h64c17.7 0 32-14.3 32-32V384c0-17.7-14.3-32-32-32V160c17.7 0 32-14.3 32-32V64c0-17.7-14.3-32-32-32H352zM96 160c17.7 0 32-14.3 32-32H320c0 17.7 14.3 32 32 32V352c-17.7 0-32 14.3-32 32H128c0-17.7-14.3-32-32-32V160zM48 400H80v32H48V400zm320 32V400h32v32H368zM48 112V80H80v32H48z"
    />
</svg>`;
var faCircle = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path d="M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z" />
</svg>`;
var faSlash = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 640 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M5.1 9.2C13.3-1.2 28.4-3.1 38.8 5.1l592 464c10.4 8.2 12.3 23.3 4.1 33.7s-23.3 12.3-33.7 4.1L9.2 42.9C-1.2 34.7-3.1 19.6 5.1 9.2z"
    />
</svg>`;
var faSquarePlus = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M64 80c-8.8 0-16 7.2-16 16V416c0 8.8 7.2 16 16 16H384c8.8 0 16-7.2 16-16V96c0-8.8-7.2-16-16-16H64zM0 96C0 60.7 28.7 32 64 32H384c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96zM200 344V280H136c-13.3 0-24-10.7-24-24s10.7-24 24-24h64V168c0-13.3 10.7-24 24-24s24 10.7 24 24v64h64c13.3 0 24 10.7 24 24s-10.7 24-24 24H248v64c0 13.3-10.7 24-24 24s-24-10.7-24-24z"
    />
</svg>`;
var faSquareMinus = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M64 80c-8.8 0-16 7.2-16 16V416c0 8.8 7.2 16 16 16H384c8.8 0 16-7.2 16-16V96c0-8.8-7.2-16-16-16H64zM0 96C0 60.7 28.7 32 64 32H384c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96zM152 232H296c13.3 0 24 10.7 24 24s-10.7 24-24 24H152c-13.3 0-24-10.7-24-24s10.7-24 24-24z"
    />
</svg>`;
var faTrash = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"
    />
</svg>`;
var faExpand = ke26`<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
    <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
    <path
        d="M32 32C14.3 32 0 46.3 0 64v96c0 17.7 14.3 32 32 32s32-14.3 32-32V96h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H64V352zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V64c0-17.7-14.3-32-32-32H320zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H320c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V352z"
    />
</svg>`;
var t53 = window;
var e82 = t53.ShadowRoot && (void 0 === t53.ShadyCSS || t53.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s32 = Symbol();
var n92 = /* @__PURE__ */ new WeakMap();
var o72 = class {
  constructor(t11, e17, n17) {
    if (this._$cssResult$ = true, n17 !== s32) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t11, this.t = e17;
  }
  get styleSheet() {
    let t11 = this.o;
    const s9 = this.t;
    if (e82 && void 0 === t11) {
      const e17 = void 0 !== s9 && 1 === s9.length;
      e17 && (t11 = n92.get(s9)), void 0 === t11 && ((this.o = t11 = new CSSStyleSheet()).replaceSync(this.cssText), e17 && n92.set(s9, t11));
    }
    return t11;
  }
  toString() {
    return this.cssText;
  }
};
var r72 = (t11) => new o72("string" == typeof t11 ? t11 : t11 + "", void 0, s32);
var i52 = (t11, ...e17) => {
  const n17 = 1 === t11.length ? t11[0] : e17.reduce((e18, s9, n18) => e18 + ((t12) => {
    if (true === t12._$cssResult$) return t12.cssText;
    if ("number" == typeof t12) return t12;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t12 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s9) + t11[n18 + 1], t11[0]);
  return new o72(n17, t11, s32);
};
var S52 = (s9, n17) => {
  e82 ? s9.adoptedStyleSheets = n17.map((t11) => t11 instanceof CSSStyleSheet ? t11 : t11.styleSheet) : n17.forEach((e17) => {
    const n18 = document.createElement("style"), o15 = t53.litNonce;
    void 0 !== o15 && n18.setAttribute("nonce", o15), n18.textContent = e17.cssText, s9.appendChild(n18);
  });
};
var c72 = e82 ? (t11) => t11 : (t11) => t11 instanceof CSSStyleSheet ? ((t12) => {
  let e17 = "";
  for (const s9 of t12.cssRules) e17 += s9.cssText;
  return r72(e17);
})(t11) : t11;
var s42;
var e92 = window;
var r82 = e92.trustedTypes;
var h72 = r82 ? r82.emptyScript : "";
var o82 = e92.reactiveElementPolyfillSupport;
var n102 = { toAttribute(t11, i12) {
  switch (i12) {
    case Boolean:
      t11 = t11 ? h72 : null;
      break;
    case Object:
    case Array:
      t11 = null == t11 ? t11 : JSON.stringify(t11);
  }
  return t11;
}, fromAttribute(t11, i12) {
  let s9 = t11;
  switch (i12) {
    case Boolean:
      s9 = null !== t11;
      break;
    case Number:
      s9 = null === t11 ? null : Number(t11);
      break;
    case Object:
    case Array:
      try {
        s9 = JSON.parse(t11);
      } catch (t12) {
        s9 = null;
      }
  }
  return s9;
} };
var a32 = (t11, i12) => i12 !== t11 && (i12 == i12 || t11 == t11);
var l32 = { attribute: true, type: String, converter: n102, reflect: false, hasChanged: a32 };
var d32 = "finalized";
var u32 = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this._$Eu();
  }
  static addInitializer(t11) {
    var i12;
    this.finalize(), (null !== (i12 = this.h) && void 0 !== i12 ? i12 : this.h = []).push(t11);
  }
  static get observedAttributes() {
    this.finalize();
    const t11 = [];
    return this.elementProperties.forEach((i12, s9) => {
      const e17 = this._$Ep(s9, i12);
      void 0 !== e17 && (this._$Ev.set(e17, s9), t11.push(e17));
    }), t11;
  }
  static createProperty(t11, i12 = l32) {
    if (i12.state && (i12.attribute = false), this.finalize(), this.elementProperties.set(t11, i12), !i12.noAccessor && !this.prototype.hasOwnProperty(t11)) {
      const s9 = "symbol" == typeof t11 ? Symbol() : "__" + t11, e17 = this.getPropertyDescriptor(t11, s9, i12);
      void 0 !== e17 && Object.defineProperty(this.prototype, t11, e17);
    }
  }
  static getPropertyDescriptor(t11, i12, s9) {
    return { get() {
      return this[i12];
    }, set(e17) {
      const r112 = this[t11];
      this[i12] = e17, this.requestUpdate(t11, r112, s9);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t11) {
    return this.elementProperties.get(t11) || l32;
  }
  static finalize() {
    if (this.hasOwnProperty(d32)) return false;
    this[d32] = true;
    const t11 = Object.getPrototypeOf(this);
    if (t11.finalize(), void 0 !== t11.h && (this.h = [...t11.h]), this.elementProperties = new Map(t11.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t12 = this.properties, i12 = [...Object.getOwnPropertyNames(t12), ...Object.getOwnPropertySymbols(t12)];
      for (const s9 of i12) this.createProperty(s9, t12[s9]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i12) {
    const s9 = [];
    if (Array.isArray(i12)) {
      const e17 = new Set(i12.flat(1 / 0).reverse());
      for (const i13 of e17) s9.unshift(c72(i13));
    } else void 0 !== i12 && s9.push(c72(i12));
    return s9;
  }
  static _$Ep(t11, i12) {
    const s9 = i12.attribute;
    return false === s9 ? void 0 : "string" == typeof s9 ? s9 : "string" == typeof t11 ? t11.toLowerCase() : void 0;
  }
  _$Eu() {
    var t11;
    this._$E_ = new Promise((t12) => this.enableUpdating = t12), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t11 = this.constructor.h) || void 0 === t11 || t11.forEach((t12) => t12(this));
  }
  addController(t11) {
    var i12, s9;
    (null !== (i12 = this._$ES) && void 0 !== i12 ? i12 : this._$ES = []).push(t11), void 0 !== this.renderRoot && this.isConnected && (null === (s9 = t11.hostConnected) || void 0 === s9 || s9.call(t11));
  }
  removeController(t11) {
    var i12;
    null === (i12 = this._$ES) || void 0 === i12 || i12.splice(this._$ES.indexOf(t11) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t11, i12) => {
      this.hasOwnProperty(i12) && (this._$Ei.set(i12, this[i12]), delete this[i12]);
    });
  }
  createRenderRoot() {
    var t11;
    const s9 = null !== (t11 = this.shadowRoot) && void 0 !== t11 ? t11 : this.attachShadow(this.constructor.shadowRootOptions);
    return S52(s9, this.constructor.elementStyles), s9;
  }
  connectedCallback() {
    var t11;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t11 = this._$ES) || void 0 === t11 || t11.forEach((t12) => {
      var i12;
      return null === (i12 = t12.hostConnected) || void 0 === i12 ? void 0 : i12.call(t12);
    });
  }
  enableUpdating(t11) {
  }
  disconnectedCallback() {
    var t11;
    null === (t11 = this._$ES) || void 0 === t11 || t11.forEach((t12) => {
      var i12;
      return null === (i12 = t12.hostDisconnected) || void 0 === i12 ? void 0 : i12.call(t12);
    });
  }
  attributeChangedCallback(t11, i12, s9) {
    this._$AK(t11, s9);
  }
  _$EO(t11, i12, s9 = l32) {
    var e17;
    const r112 = this.constructor._$Ep(t11, s9);
    if (void 0 !== r112 && true === s9.reflect) {
      const h92 = (void 0 !== (null === (e17 = s9.converter) || void 0 === e17 ? void 0 : e17.toAttribute) ? s9.converter : n102).toAttribute(i12, s9.type);
      this._$El = t11, null == h92 ? this.removeAttribute(r112) : this.setAttribute(r112, h92), this._$El = null;
    }
  }
  _$AK(t11, i12) {
    var s9;
    const e17 = this.constructor, r112 = e17._$Ev.get(t11);
    if (void 0 !== r112 && this._$El !== r112) {
      const t12 = e17.getPropertyOptions(r112), h92 = "function" == typeof t12.converter ? { fromAttribute: t12.converter } : void 0 !== (null === (s9 = t12.converter) || void 0 === s9 ? void 0 : s9.fromAttribute) ? t12.converter : n102;
      this._$El = r112, this[r112] = h92.fromAttribute(i12, t12.type), this._$El = null;
    }
  }
  requestUpdate(t11, i12, s9) {
    let e17 = true;
    void 0 !== t11 && (((s9 = s9 || this.constructor.getPropertyOptions(t11)).hasChanged || a32)(this[t11], i12) ? (this._$AL.has(t11) || this._$AL.set(t11, i12), true === s9.reflect && this._$El !== t11 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t11, s9))) : e17 = false), !this.isUpdatePending && e17 && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = true;
    try {
      await this._$E_;
    } catch (t12) {
      Promise.reject(t12);
    }
    const t11 = this.scheduleUpdate();
    return null != t11 && await t11, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t11;
    if (!this.isUpdatePending) return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((t12, i13) => this[i13] = t12), this._$Ei = void 0);
    let i12 = false;
    const s9 = this._$AL;
    try {
      i12 = this.shouldUpdate(s9), i12 ? (this.willUpdate(s9), null === (t11 = this._$ES) || void 0 === t11 || t11.forEach((t12) => {
        var i13;
        return null === (i13 = t12.hostUpdate) || void 0 === i13 ? void 0 : i13.call(t12);
      }), this.update(s9)) : this._$Ek();
    } catch (t12) {
      throw i12 = false, this._$Ek(), t12;
    }
    i12 && this._$AE(s9);
  }
  willUpdate(t11) {
  }
  _$AE(t11) {
    var i12;
    null === (i12 = this._$ES) || void 0 === i12 || i12.forEach((t12) => {
      var i13;
      return null === (i13 = t12.hostUpdated) || void 0 === i13 ? void 0 : i13.call(t12);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t11)), this.updated(t11);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t11) {
    return true;
  }
  update(t11) {
    void 0 !== this._$EC && (this._$EC.forEach((t12, i12) => this._$EO(i12, this[i12], t12)), this._$EC = void 0), this._$Ek();
  }
  updated(t11) {
  }
  firstUpdated(t11) {
  }
};
u32[d32] = true, u32.elementProperties = /* @__PURE__ */ new Map(), u32.elementStyles = [], u32.shadowRootOptions = { mode: "open" }, null == o82 || o82({ ReactiveElement: u32 }), (null !== (s42 = e92.reactiveElementVersions) && void 0 !== s42 ? s42 : e92.reactiveElementVersions = []).push("1.6.3");
var t63;
var i62 = window;
var s52 = i62.trustedTypes;
var e102 = s52 ? s52.createPolicy("lit-html", { createHTML: (t11) => t11 }) : void 0;
var o92 = "$lit$";
var n11 = `lit$${(Math.random() + "").slice(9)}$`;
var l42 = "?" + n11;
var h82 = `<${l42}>`;
var r92 = document;
var u42 = () => r92.createComment("");
var d42 = (t11) => null === t11 || "object" != typeof t11 && "function" != typeof t11;
var c82 = Array.isArray;
var v32 = (t11) => c82(t11) || "function" == typeof (null == t11 ? void 0 : t11[Symbol.iterator]);
var a42 = "[ 	\n\f\r]";
var f72 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var _32 = /-->/g;
var m32 = />/g;
var p32 = RegExp(`>|${a42}(?:([^\\s"'>=/]+)(${a42}*=${a42}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var g32 = /'/g;
var $32 = /"/g;
var y32 = /^(?:script|style|textarea|title)$/i;
var w32 = (t11) => (i12, ...s9) => ({ _$litType$: t11, strings: i12, values: s9 });
var x42 = w32(1);
var b32 = w32(2);
var T32 = Symbol.for("lit-noChange");
var A = Symbol.for("lit-nothing");
var E32 = /* @__PURE__ */ new WeakMap();
var C = r92.createTreeWalker(r92, 129, null, false);
function P32(t11, i12) {
  if (!Array.isArray(t11) || !t11.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== e102 ? e102.createHTML(i12) : i12;
}
var V32 = (t11, i12) => {
  const s9 = t11.length - 1, e17 = [];
  let l11, r112 = 2 === i12 ? "<svg>" : "", u62 = f72;
  for (let i13 = 0; i13 < s9; i13++) {
    const s10 = t11[i13];
    let d52, c92, v42 = -1, a72 = 0;
    for (; a72 < s10.length && (u62.lastIndex = a72, c92 = u62.exec(s10), null !== c92); ) a72 = u62.lastIndex, u62 === f72 ? "!--" === c92[1] ? u62 = _32 : void 0 !== c92[1] ? u62 = m32 : void 0 !== c92[2] ? (y32.test(c92[2]) && (l11 = RegExp("</" + c92[2], "g")), u62 = p32) : void 0 !== c92[3] && (u62 = p32) : u62 === p32 ? ">" === c92[0] ? (u62 = null != l11 ? l11 : f72, v42 = -1) : void 0 === c92[1] ? v42 = -2 : (v42 = u62.lastIndex - c92[2].length, d52 = c92[1], u62 = void 0 === c92[3] ? p32 : '"' === c92[3] ? $32 : g32) : u62 === $32 || u62 === g32 ? u62 = p32 : u62 === _32 || u62 === m32 ? u62 = f72 : (u62 = p32, l11 = void 0);
    const w42 = u62 === p32 && t11[i13 + 1].startsWith("/>") ? " " : "";
    r112 += u62 === f72 ? s10 + h82 : v42 >= 0 ? (e17.push(d52), s10.slice(0, v42) + o92 + s10.slice(v42) + n11 + w42) : s10 + n11 + (-2 === v42 ? (e17.push(void 0), i13) : w42);
  }
  return [P32(t11, r112 + (t11[s9] || "<?>") + (2 === i12 ? "</svg>" : "")), e17];
};
var N32 = class _N {
  constructor({ strings: t11, _$litType$: i12 }, e17) {
    let h92;
    this.parts = [];
    let r112 = 0, d52 = 0;
    const c92 = t11.length - 1, v42 = this.parts, [a72, f82] = V32(t11, i12);
    if (this.el = _N.createElement(a72, e17), C.currentNode = this.el.content, 2 === i12) {
      const t12 = this.el.content, i13 = t12.firstChild;
      i13.remove(), t12.append(...i13.childNodes);
    }
    for (; null !== (h92 = C.nextNode()) && v42.length < c92; ) {
      if (1 === h92.nodeType) {
        if (h92.hasAttributes()) {
          const t12 = [];
          for (const i13 of h92.getAttributeNames()) if (i13.endsWith(o92) || i13.startsWith(n11)) {
            const s9 = f82[d52++];
            if (t12.push(i13), void 0 !== s9) {
              const t13 = h92.getAttribute(s9.toLowerCase() + o92).split(n11), i14 = /([.?@])?(.*)/.exec(s9);
              v42.push({ type: 1, index: r112, name: i14[2], strings: t13, ctor: "." === i14[1] ? H : "?" === i14[1] ? L3 : "@" === i14[1] ? z32 : k32 });
            } else v42.push({ type: 6, index: r112 });
          }
          for (const i13 of t12) h92.removeAttribute(i13);
        }
        if (y32.test(h92.tagName)) {
          const t12 = h92.textContent.split(n11), i13 = t12.length - 1;
          if (i13 > 0) {
            h92.textContent = s52 ? s52.emptyScript : "";
            for (let s9 = 0; s9 < i13; s9++) h92.append(t12[s9], u42()), C.nextNode(), v42.push({ type: 2, index: ++r112 });
            h92.append(t12[i13], u42());
          }
        }
      } else if (8 === h92.nodeType) if (h92.data === l42) v42.push({ type: 2, index: r112 });
      else {
        let t12 = -1;
        for (; -1 !== (t12 = h92.data.indexOf(n11, t12 + 1)); ) v42.push({ type: 7, index: r112 }), t12 += n11.length - 1;
      }
      r112++;
    }
  }
  static createElement(t11, i12) {
    const s9 = r92.createElement("template");
    return s9.innerHTML = t11, s9;
  }
};
function S62(t11, i12, s9 = t11, e17) {
  var o15, n17, l11, h92;
  if (i12 === T32) return i12;
  let r112 = void 0 !== e17 ? null === (o15 = s9._$Co) || void 0 === o15 ? void 0 : o15[e17] : s9._$Cl;
  const u62 = d42(i12) ? void 0 : i12._$litDirective$;
  return (null == r112 ? void 0 : r112.constructor) !== u62 && (null === (n17 = null == r112 ? void 0 : r112._$AO) || void 0 === n17 || n17.call(r112, false), void 0 === u62 ? r112 = void 0 : (r112 = new u62(t11), r112._$AT(t11, s9, e17)), void 0 !== e17 ? (null !== (l11 = (h92 = s9)._$Co) && void 0 !== l11 ? l11 : h92._$Co = [])[e17] = r112 : s9._$Cl = r112), void 0 !== r112 && (i12 = S62(t11, r112._$AS(t11, i12.values), r112, e17)), i12;
}
var M32 = class {
  constructor(t11, i12) {
    this._$AV = [], this._$AN = void 0, this._$AD = t11, this._$AM = i12;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t11) {
    var i12;
    const { el: { content: s9 }, parts: e17 } = this._$AD, o15 = (null !== (i12 = null == t11 ? void 0 : t11.creationScope) && void 0 !== i12 ? i12 : r92).importNode(s9, true);
    C.currentNode = o15;
    let n17 = C.nextNode(), l11 = 0, h92 = 0, u62 = e17[0];
    for (; void 0 !== u62; ) {
      if (l11 === u62.index) {
        let i13;
        2 === u62.type ? i13 = new R32(n17, n17.nextSibling, this, t11) : 1 === u62.type ? i13 = new u62.ctor(n17, u62.name, u62.strings, this, t11) : 6 === u62.type && (i13 = new Z32(n17, this, t11)), this._$AV.push(i13), u62 = e17[++h92];
      }
      l11 !== (null == u62 ? void 0 : u62.index) && (n17 = C.nextNode(), l11++);
    }
    return C.currentNode = r92, o15;
  }
  v(t11) {
    let i12 = 0;
    for (const s9 of this._$AV) void 0 !== s9 && (void 0 !== s9.strings ? (s9._$AI(t11, s9, i12), i12 += s9.strings.length - 2) : s9._$AI(t11[i12])), i12++;
  }
};
var R32 = class _R {
  constructor(t11, i12, s9, e17) {
    var o15;
    this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t11, this._$AB = i12, this._$AM = s9, this.options = e17, this._$Cp = null === (o15 = null == e17 ? void 0 : e17.isConnected) || void 0 === o15 || o15;
  }
  get _$AU() {
    var t11, i12;
    return null !== (i12 = null === (t11 = this._$AM) || void 0 === t11 ? void 0 : t11._$AU) && void 0 !== i12 ? i12 : this._$Cp;
  }
  get parentNode() {
    let t11 = this._$AA.parentNode;
    const i12 = this._$AM;
    return void 0 !== i12 && 11 === (null == t11 ? void 0 : t11.nodeType) && (t11 = i12.parentNode), t11;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t11, i12 = this) {
    t11 = S62(this, t11, i12), d42(t11) ? t11 === A || null == t11 || "" === t11 ? (this._$AH !== A && this._$AR(), this._$AH = A) : t11 !== this._$AH && t11 !== T32 && this._(t11) : void 0 !== t11._$litType$ ? this.g(t11) : void 0 !== t11.nodeType ? this.$(t11) : v32(t11) ? this.T(t11) : this._(t11);
  }
  k(t11) {
    return this._$AA.parentNode.insertBefore(t11, this._$AB);
  }
  $(t11) {
    this._$AH !== t11 && (this._$AR(), this._$AH = this.k(t11));
  }
  _(t11) {
    this._$AH !== A && d42(this._$AH) ? this._$AA.nextSibling.data = t11 : this.$(r92.createTextNode(t11)), this._$AH = t11;
  }
  g(t11) {
    var i12;
    const { values: s9, _$litType$: e17 } = t11, o15 = "number" == typeof e17 ? this._$AC(t11) : (void 0 === e17.el && (e17.el = N32.createElement(P32(e17.h, e17.h[0]), this.options)), e17);
    if ((null === (i12 = this._$AH) || void 0 === i12 ? void 0 : i12._$AD) === o15) this._$AH.v(s9);
    else {
      const t12 = new M32(o15, this), i13 = t12.u(this.options);
      t12.v(s9), this.$(i13), this._$AH = t12;
    }
  }
  _$AC(t11) {
    let i12 = E32.get(t11.strings);
    return void 0 === i12 && E32.set(t11.strings, i12 = new N32(t11)), i12;
  }
  T(t11) {
    c82(this._$AH) || (this._$AH = [], this._$AR());
    const i12 = this._$AH;
    let s9, e17 = 0;
    for (const o15 of t11) e17 === i12.length ? i12.push(s9 = new _R(this.k(u42()), this.k(u42()), this, this.options)) : s9 = i12[e17], s9._$AI(o15), e17++;
    e17 < i12.length && (this._$AR(s9 && s9._$AB.nextSibling, e17), i12.length = e17);
  }
  _$AR(t11 = this._$AA.nextSibling, i12) {
    var s9;
    for (null === (s9 = this._$AP) || void 0 === s9 || s9.call(this, false, true, i12); t11 && t11 !== this._$AB; ) {
      const i13 = t11.nextSibling;
      t11.remove(), t11 = i13;
    }
  }
  setConnected(t11) {
    var i12;
    void 0 === this._$AM && (this._$Cp = t11, null === (i12 = this._$AP) || void 0 === i12 || i12.call(this, t11));
  }
};
var k32 = class {
  constructor(t11, i12, s9, e17, o15) {
    this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t11, this.name = i12, this._$AM = e17, this.options = o15, s9.length > 2 || "" !== s9[0] || "" !== s9[1] ? (this._$AH = Array(s9.length - 1).fill(new String()), this.strings = s9) : this._$AH = A;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t11, i12 = this, s9, e17) {
    const o15 = this.strings;
    let n17 = false;
    if (void 0 === o15) t11 = S62(this, t11, i12, 0), n17 = !d42(t11) || t11 !== this._$AH && t11 !== T32, n17 && (this._$AH = t11);
    else {
      const e18 = t11;
      let l11, h92;
      for (t11 = o15[0], l11 = 0; l11 < o15.length - 1; l11++) h92 = S62(this, e18[s9 + l11], i12, l11), h92 === T32 && (h92 = this._$AH[l11]), n17 || (n17 = !d42(h92) || h92 !== this._$AH[l11]), h92 === A ? t11 = A : t11 !== A && (t11 += (null != h92 ? h92 : "") + o15[l11 + 1]), this._$AH[l11] = h92;
    }
    n17 && !e17 && this.j(t11);
  }
  j(t11) {
    t11 === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t11 ? t11 : "");
  }
};
var H = class extends k32 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t11) {
    this.element[this.name] = t11 === A ? void 0 : t11;
  }
};
var I32 = s52 ? s52.emptyScript : "";
var L3 = class extends k32 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t11) {
    t11 && t11 !== A ? this.element.setAttribute(this.name, I32) : this.element.removeAttribute(this.name);
  }
};
var z32 = class extends k32 {
  constructor(t11, i12, s9, e17, o15) {
    super(t11, i12, s9, e17, o15), this.type = 5;
  }
  _$AI(t11, i12 = this) {
    var s9;
    if ((t11 = null !== (s9 = S62(this, t11, i12, 0)) && void 0 !== s9 ? s9 : A) === T32) return;
    const e17 = this._$AH, o15 = t11 === A && e17 !== A || t11.capture !== e17.capture || t11.once !== e17.once || t11.passive !== e17.passive, n17 = t11 !== A && (e17 === A || o15);
    o15 && this.element.removeEventListener(this.name, this, e17), n17 && this.element.addEventListener(this.name, this, t11), this._$AH = t11;
  }
  handleEvent(t11) {
    var i12, s9;
    "function" == typeof this._$AH ? this._$AH.call(null !== (s9 = null === (i12 = this.options) || void 0 === i12 ? void 0 : i12.host) && void 0 !== s9 ? s9 : this.element, t11) : this._$AH.handleEvent(t11);
  }
};
var Z32 = class {
  constructor(t11, i12, s9) {
    this.element = t11, this.type = 6, this._$AN = void 0, this._$AM = i12, this.options = s9;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t11) {
    S62(this, t11);
  }
};
var j32 = { O: o92, P: n11, A: l42, C: 1, M: V32, L: M32, R: v32, D: S62, I: R32, V: k32, H: L3, N: z32, U: H, F: Z32 };
var B32 = i62.litHtmlPolyfillSupport;
null == B32 || B32(N32, R32), (null !== (t63 = i62.litHtmlVersions) && void 0 !== t63 ? t63 : i62.litHtmlVersions = []).push("2.8.0");
var D32 = (t11, i12, s9) => {
  var e17, o15;
  const n17 = null !== (e17 = null == s9 ? void 0 : s9.renderBefore) && void 0 !== e17 ? e17 : i12;
  let l11 = n17._$litPart$;
  if (void 0 === l11) {
    const t12 = null !== (o15 = null == s9 ? void 0 : s9.renderBefore) && void 0 !== o15 ? o15 : null;
    n17._$litPart$ = l11 = new R32(i12.insertBefore(u42(), t12), t12, void 0, null != s9 ? s9 : {});
  }
  return l11._$AI(t11), l11;
};
var l52;
var o102;
var s62 = class extends u32 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t11, e17;
    const i12 = super.createRenderRoot();
    return null !== (t11 = (e17 = this.renderOptions).renderBefore) && void 0 !== t11 || (e17.renderBefore = i12.firstChild), i12;
  }
  update(t11) {
    const i12 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t11), this._$Do = D32(i12, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t11;
    super.connectedCallback(), null === (t11 = this._$Do) || void 0 === t11 || t11.setConnected(true);
  }
  disconnectedCallback() {
    var t11;
    super.disconnectedCallback(), null === (t11 = this._$Do) || void 0 === t11 || t11.setConnected(false);
  }
  render() {
    return T32;
  }
};
s62.finalized = true, s62._$litElement$ = true, null === (l52 = globalThis.litElementHydrateSupport) || void 0 === l52 || l52.call(globalThis, { LitElement: s62 });
var n12 = globalThis.litElementPolyfillSupport;
null == n12 || n12({ LitElement: s62 });
(null !== (o102 = globalThis.litElementVersions) && void 0 !== o102 ? o102 : globalThis.litElementVersions = []).push("3.3.3");
var component_styles_default5 = i52`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
var spinner_styles_default4 = i52`
  ${component_styles_default5}

  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.01em, 2.75em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.01em, 2.75em;
    }
  }
`;
var connectedElements4 = /* @__PURE__ */ new Set();
var documentElementObserver4 = new MutationObserver(update4);
var translations4 = /* @__PURE__ */ new Map();
var documentDirection4 = document.documentElement.dir || "ltr";
var documentLanguage4 = document.documentElement.lang || navigator.language;
var fallback4;
documentElementObserver4.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation4(...translation22) {
  translation22.map((t11) => {
    const code = t11.$code.toLowerCase();
    if (translations4.has(code)) {
      translations4.set(code, Object.assign(Object.assign({}, translations4.get(code)), t11));
    } else {
      translations4.set(code, t11);
    }
    if (!fallback4) {
      fallback4 = t11;
    }
  });
  update4();
}
function update4() {
  documentDirection4 = document.documentElement.dir || "ltr";
  documentLanguage4 = document.documentElement.lang || navigator.language;
  [...connectedElements4.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController5 = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements4.add(this.host);
  }
  hostDisconnected() {
    connectedElements4.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection4}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage4}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a42, _b;
    const locale = new Intl.Locale(lang);
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a42 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a42 === void 0 ? void 0 : _a42.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations4.get(`${language}-${region}`);
    const secondary = translations4.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a42;
    const { primary, secondary } = this.getTranslationData((_a42 = options.lang) !== null && _a42 !== void 0 ? _a42 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback4 && fallback4[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback4 && fallback4[key]) {
      term = fallback4[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};
var LocalizeController24 = class extends LocalizeController5 {
};
var __defProp35 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDesc35 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp35 = (obj, key, value) => key in obj ? __defProp35(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a72, b42) => {
  for (var prop in b42 || (b42 = {}))
    if (__hasOwnProp22.call(b42, prop))
      __defNormalProp35(a72, prop, b42[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b42)) {
      if (__propIsEnum5.call(b42, prop))
        __defNormalProp35(a72, prop, b42[prop]);
    }
  return a72;
};
var __spreadProps5 = (a72, b42) => __defProps5(a72, __getOwnPropDescs5(b42));
var __decorateClass5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc35(target, key) : target;
  for (var i12 = decorators.length - 1, decorator; i12 >= 0; i12--)
    if (decorator = decorators[i12])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp35(target, key, result);
  return result;
};
var i72 = (i12, e17) => "method" === e17.kind && e17.descriptor && !("value" in e17.descriptor) ? { ...e17, finisher(n17) {
  n17.createProperty(e17.key, i12);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e17.key, initializer() {
  "function" == typeof e17.initializer && (this[e17.key] = e17.initializer.call(this));
}, finisher(n17) {
  n17.createProperty(e17.key, i12);
} };
var e112 = (i12, e17, n17) => {
  e17.constructor.createProperty(n17, i12);
};
function n13(n17) {
  return (t11, o15) => void 0 !== o15 ? e112(n17, t11, o15) : i72(n17, t11);
}
function t72(t11) {
  return n13({ ...t11, state: true });
}
var o112 = ({ finisher: e17, descriptor: t11 }) => (o15, n17) => {
  var r112;
  if (void 0 === n17) {
    const n18 = null !== (r112 = o15.originalKey) && void 0 !== r112 ? r112 : o15.key, i12 = null != t11 ? { kind: "method", placement: "prototype", key: n18, descriptor: t11(o15.key) } : { ...o15, key: n18 };
    return null != e17 && (i12.finisher = function(t12) {
      e17(t12, n18);
    }), i12;
  }
  {
    const r12 = o15.constructor;
    void 0 !== t11 && Object.defineProperty(o15, n17, t11(n17)), null == e17 || e17(r12, n17);
  }
};
function e12(e17) {
  return o112({ finisher: (r112, t11) => {
    Object.assign(r112.prototype[t11], e17);
  } });
}
function i8(i12, n17) {
  return o112({ descriptor: (o15) => {
    const t11 = { get() {
      var o16, n18;
      return null !== (n18 = null === (o16 = this.renderRoot) || void 0 === o16 ? void 0 : o16.querySelector(i12)) && void 0 !== n18 ? n18 : null;
    }, enumerable: true, configurable: true };
    if (n17) {
      const n18 = "symbol" == typeof o15 ? Symbol() : "__" + o15;
      t11.get = function() {
        var o16, t12;
        return void 0 === this[n18] && (this[n18] = null !== (t12 = null === (o16 = this.renderRoot) || void 0 === o16 ? void 0 : o16.querySelector(i12)) && void 0 !== t12 ? t12 : null), this[n18];
      };
    }
    return t11;
  } });
}
var n14;
var e13 = null != (null === (n14 = window.HTMLSlotElement) || void 0 === n14 ? void 0 : n14.prototype.assignedElements) ? (o15, n17) => o15.assignedElements(n17) : (o15, n17) => o15.assignedNodes(n17).filter((o16) => o16.nodeType === Node.ELEMENT_NODE);
var ShoelaceElement5 = class extends s62 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues5({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement5.version = "2.7.0";
ShoelaceElement5.dependencies = {};
__decorateClass5([
  n13()
], ShoelaceElement5.prototype, "dir", 2);
__decorateClass5([
  n13()
], ShoelaceElement5.prototype, "lang", 2);
var SlSpinner4 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController24(this);
  }
  render() {
    return x42`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner4.styles = spinner_styles_default4;
var formCollections5 = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads5 = /* @__PURE__ */ new WeakMap();
var userInteractedControls5 = /* @__PURE__ */ new WeakSet();
var interactions5 = /* @__PURE__ */ new WeakMap();
var FormControlController5 = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (!disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a42;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a42 = formCollections5.get(this.form)) == null ? void 0 : _a42.forEach((control2) => {
          this.setUserInteracted(control2, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions5.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions5.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues5({
      form: (input) => {
        if (input.hasAttribute("form") && input.getAttribute("form") !== "") {
          const root = input.getRootNode();
          const formId = input.getAttribute("form");
          if (formId) {
            return root.getElementById(formId);
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a42;
        return (_a42 = input.disabled) != null ? _a42 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions5.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions5.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections5.has(this.form)) {
        formCollections5.get(this.form).add(this.host);
      } else {
        formCollections5.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads5.has(this.form)) {
        reportValidityOverloads5.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    var _a42;
    if (this.form) {
      (_a42 = formCollections5.get(this.form)) == null ? void 0 : _a42.delete(this.host);
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads5.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads5.get(this.form);
        reportValidityOverloads5.delete(this.form);
      }
    }
    this.form = void 0;
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls5.add(el);
    } else {
      userInteractedControls5.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a42;
    return (_a42 = this.form) != null ? _a42 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls5.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState5 = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState5 = Object.freeze(__spreadProps5(__spreadValues5({}, validValidityState5), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState5 = Object.freeze(__spreadProps5(__spreadValues5({}, validValidityState5), {
  valid: false,
  customError: true
}));
var button_styles_default4 = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition: var(--sl-transition-x-fast) background-color, var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border, var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;
var HasSlotController5 = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent2(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}
var icon_styles_default5 = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
var basePath5 = "";
function setBasePath5(path) {
  basePath5 = path;
}
function getBasePath5(subpath = "") {
  if (!basePath5) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath5(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s9) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s9.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s9.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath5(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath5.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}
var library5 = {
  name: "default",
  resolver: (name) => getBasePath5(`assets/icons/${name}.svg`)
};
var library_default_default5 = library5;
var icons22 = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-files" viewBox="0 0 16 16" part="svg">
      <path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"></path>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary5 = {
  name: "system",
  resolver: (name) => {
    if (name in icons22) {
      return `data:image/svg+xml,${encodeURIComponent(icons22[name])}`;
    }
    return "";
  }
};
var library_system_default5 = systemLibrary5;
var registry5 = [library_default_default5, library_system_default5];
var watchedIcons5 = [];
function watchIcon5(icon) {
  watchedIcons5.push(icon);
}
function unwatchIcon5(icon) {
  watchedIcons5 = watchedIcons5.filter((el) => el !== icon);
}
function getIconLibrary5(name) {
  return registry5.find((lib) => lib.name === name);
}
function watch5(propertyName, options) {
  const resolvedOptions = __spreadValues5({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update22 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update22.call(this, changedProps);
    };
  };
}
var { I: l72 } = j32;
var t82 = (o15, l11) => void 0 === l11 ? void 0 !== (null == o15 ? void 0 : o15._$litType$) : (null == o15 ? void 0 : o15._$litType$) === l11;
var e14 = (o15) => void 0 === o15.strings;
var s72 = {};
var a52 = (o15, l11 = s72) => o15._$AH = l11;
var CACHEABLE_ERROR5 = Symbol();
var RETRYABLE_ERROR5 = Symbol();
var parser5;
var iconCache5 = /* @__PURE__ */ new Map();
var SlIcon5 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library22) {
    var _a42;
    let fileData;
    if (library22 == null ? void 0 : library22.spriteSheet) {
      return x42`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR5 : RETRYABLE_ERROR5;
    } catch (e17) {
      return RETRYABLE_ERROR5;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg2 = div.firstElementChild;
      if (((_a42 = svg2 == null ? void 0 : svg2.tagName) == null ? void 0 : _a42.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR5;
      if (!parser5)
        parser5 = new DOMParser();
      const doc = parser5.parseFromString(svg2.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR5;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e17) {
      return CACHEABLE_ERROR5;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon5(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon5(this);
  }
  getUrl() {
    const library22 = getIconLibrary5(this.library);
    if (this.name && library22) {
      return library22.resolver(this.name);
    }
    return this.src;
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a42;
    const library22 = getIconLibrary5(this.library);
    const url = this.getUrl();
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache5.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library22);
      iconCache5.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg2 = await iconResolver;
    if (svg2 === RETRYABLE_ERROR5) {
      iconCache5.delete(url);
    }
    if (url !== this.getUrl()) {
      return;
    }
    if (t82(svg2)) {
      this.svg = svg2;
      return;
    }
    switch (svg2) {
      case RETRYABLE_ERROR5:
      case CACHEABLE_ERROR5:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg2.cloneNode(true);
        (_a42 = library22 == null ? void 0 : library22.mutator) == null ? void 0 : _a42.call(library22, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon5.styles = icon_styles_default5;
__decorateClass5([
  t72()
], SlIcon5.prototype, "svg", 2);
__decorateClass5([
  n13({ reflect: true })
], SlIcon5.prototype, "name", 2);
__decorateClass5([
  n13()
], SlIcon5.prototype, "src", 2);
__decorateClass5([
  n13()
], SlIcon5.prototype, "label", 2);
__decorateClass5([
  n13({ reflect: true })
], SlIcon5.prototype, "library", 2);
__decorateClass5([
  watch5("label")
], SlIcon5.prototype, "handleLabelChange", 1);
__decorateClass5([
  watch5(["name", "src", "library"])
], SlIcon5.prototype, "setIcon", 1);
var t92 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e15 = (t11) => (...e17) => ({ _$litDirective$: t11, values: e17 });
var i9 = class {
  constructor(t11) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t11, e17, i12) {
    this._$Ct = t11, this._$AM = e17, this._$Ci = i12;
  }
  _$AS(t11, e17) {
    return this.update(t11, e17);
  }
  update(t11, e17) {
    return this.render(...e17);
  }
};
var o12 = e15(class extends i9 {
  constructor(t11) {
    var i12;
    if (super(t11), t11.type !== t92.ATTRIBUTE || "class" !== t11.name || (null === (i12 = t11.strings) || void 0 === i12 ? void 0 : i12.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t11) {
    return " " + Object.keys(t11).filter((i12) => t11[i12]).join(" ") + " ";
  }
  update(i12, [s9]) {
    var r112, o15;
    if (void 0 === this.it) {
      this.it = /* @__PURE__ */ new Set(), void 0 !== i12.strings && (this.nt = new Set(i12.strings.join(" ").split(/\s/).filter((t11) => "" !== t11)));
      for (const t11 in s9) s9[t11] && !(null === (r112 = this.nt) || void 0 === r112 ? void 0 : r112.has(t11)) && this.it.add(t11);
      return this.render(s9);
    }
    const e17 = i12.element.classList;
    this.it.forEach((t11) => {
      t11 in s9 || (e17.remove(t11), this.it.delete(t11));
    });
    for (const t11 in s9) {
      const i13 = !!s9[t11];
      i13 === this.it.has(t11) || (null === (o15 = this.nt) || void 0 === o15 ? void 0 : o15.has(t11)) || (i13 ? (e17.add(t11), this.it.add(t11)) : (e17.remove(t11), this.it.delete(t11)));
    }
    return T32;
  }
});
var e16 = Symbol.for("");
var l8 = (t11) => {
  if ((null == t11 ? void 0 : t11.r) === e16) return null == t11 ? void 0 : t11._$litStatic$;
};
var i10 = (t11, ...r112) => ({ _$litStatic$: r112.reduce((r12, e17, l11) => r12 + ((t12) => {
  if (void 0 !== t12._$litStatic$) return t12._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t12}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e17) + t11[l11 + 1], t11[0]), r: e16 });
var s8 = /* @__PURE__ */ new Map();
var a62 = (t11) => (r112, ...e17) => {
  const o15 = e17.length;
  let i12, a72;
  const n17 = [], u62 = [];
  let c92, $42 = 0, f82 = false;
  for (; $42 < o15; ) {
    for (c92 = r112[$42]; $42 < o15 && void 0 !== (a72 = e17[$42], i12 = l8(a72)); ) c92 += i12 + r112[++$42], f82 = true;
    $42 !== o15 && u62.push(a72), n17.push(c92), $42++;
  }
  if ($42 === o15 && n17.push(r112[o15]), f82) {
    const t12 = n17.join("$$lit$$");
    void 0 === (r112 = s8.get(t12)) && (n17.raw = n17, s8.set(t12, r112 = n17)), e17 = u62;
  }
  return t11(r112, ...e17);
};
var n15 = a62(x42);
var u52 = a62(b32);
var l9 = (l11) => null != l11 ? l11 : A;
var SlButton4 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController5(this, {
      form: (input) => {
        if (input.hasAttribute("form")) {
          const doc = input.getRootNode();
          const formId = input.getAttribute("form");
          return doc.getElementById(formId);
        }
        return input.closest("form");
      },
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController5(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController24(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState5;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? i10`a` : i10`button`;
    return n15`
      <${tag}
        part="base"
        class=${o12({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${l9(isLink ? void 0 : this.disabled)}
        type=${l9(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${l9(isLink ? void 0 : this.name)}
        value=${l9(isLink ? void 0 : this.value)}
        href=${l9(isLink ? this.href : void 0)}
        target=${l9(isLink ? this.target : void 0)}
        download=${l9(isLink ? this.download : void 0)}
        rel=${l9(isLink ? this.rel : void 0)}
        role=${l9(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? n15` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? n15`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton4.styles = button_styles_default4;
SlButton4.dependencies = {
  "sl-icon": SlIcon5,
  "sl-spinner": SlSpinner4
};
__decorateClass5([
  i8(".button")
], SlButton4.prototype, "button", 2);
__decorateClass5([
  t72()
], SlButton4.prototype, "hasFocus", 2);
__decorateClass5([
  t72()
], SlButton4.prototype, "invalid", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "title", 2);
__decorateClass5([
  n13({ reflect: true })
], SlButton4.prototype, "variant", 2);
__decorateClass5([
  n13({ reflect: true })
], SlButton4.prototype, "size", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlButton4.prototype, "caret", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlButton4.prototype, "disabled", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlButton4.prototype, "loading", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlButton4.prototype, "outline", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlButton4.prototype, "pill", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlButton4.prototype, "circle", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "type", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "name", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "value", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "href", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "target", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "rel", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "download", 2);
__decorateClass5([
  n13()
], SlButton4.prototype, "form", 2);
__decorateClass5([
  n13({ attribute: "formaction" })
], SlButton4.prototype, "formAction", 2);
__decorateClass5([
  n13({ attribute: "formenctype" })
], SlButton4.prototype, "formEnctype", 2);
__decorateClass5([
  n13({ attribute: "formmethod" })
], SlButton4.prototype, "formMethod", 2);
__decorateClass5([
  n13({ attribute: "formnovalidate", type: Boolean })
], SlButton4.prototype, "formNoValidate", 2);
__decorateClass5([
  n13({ attribute: "formtarget" })
], SlButton4.prototype, "formTarget", 2);
__decorateClass5([
  watch5("disabled", { waitUntilFirstUpdate: true })
], SlButton4.prototype, "handleDisabledChange", 1);
var translation4 = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation4(translation4);
var details_styles_default2 = i52`
  ${component_styles_default5}

  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`;
var defaultAnimationRegistry3 = /* @__PURE__ */ new Map();
var customAnimationRegistry3 = /* @__PURE__ */ new WeakMap();
function ensureAnimation3(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation3(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation3(animationName, animation) {
  defaultAnimationRegistry3.set(animationName, ensureAnimation3(animation));
}
function getAnimation3(el, animationName, options) {
  const customAnimation = customAnimationRegistry3.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation3(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry3.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation3(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}
function waitForEvent3(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}
function animateTo3(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps5(__spreadValues5({}, options), {
      duration: prefersReducedMotion3() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion3() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations3(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        const handleAnimationEvent = requestAnimationFrame(resolve);
        animation.addEventListener("cancel", () => handleAnimationEvent, { once: true });
        animation.addEventListener("finish", () => handleAnimationEvent, { once: true });
        animation.cancel();
      });
    })
  );
}
function shimKeyframesHeightAuto2(keyframes, calculatedHeight) {
  return keyframes.map((keyframe) => __spreadProps5(__spreadValues5({}, keyframe), {
    height: keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height
  }));
}
var SlDetails2 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController24(this);
    this.open = false;
    this.disabled = false;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0";
    if (this.open) {
      this.details.open = true;
    }
    this.detailsObserver = new MutationObserver((changes) => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName === "open") {
          if (this.details.open) {
            this.show();
          } else {
            this.hide();
          }
        }
      }
    });
    this.detailsObserver.observe(this.details, { attributes: true });
  }
  disconnectedCallback() {
    this.detailsObserver.disconnect();
  }
  handleSummaryClick(ev) {
    ev.preventDefault();
    if (!this.disabled) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
      this.header.focus();
    }
  }
  handleSummaryKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
    if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
      event.preventDefault();
      this.hide();
    }
    if (event.key === "ArrowDown" || event.key === "ArrowRight") {
      event.preventDefault();
      this.show();
    }
  }
  async handleOpenChange() {
    if (this.open) {
      this.details.open = true;
      const slShow = this.emit("sl-show", { cancelable: true });
      if (slShow.defaultPrevented) {
        this.open = false;
        this.details.open = false;
        return;
      }
      await stopAnimations3(this.body);
      const { keyframes, options } = getAnimation3(this, "details.show", { dir: this.localize.dir() });
      await animateTo3(this.body, shimKeyframesHeightAuto2(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.emit("sl-after-show");
    } else {
      const slHide = this.emit("sl-hide", { cancelable: true });
      if (slHide.defaultPrevented) {
        this.details.open = true;
        this.open = true;
        return;
      }
      await stopAnimations3(this.body);
      const { keyframes, options } = getAnimation3(this, "details.hide", { dir: this.localize.dir() });
      await animateTo3(this.body, shimKeyframesHeightAuto2(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.details.open = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (this.open || this.disabled) {
      return void 0;
    }
    this.open = true;
    return waitForEvent3(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!this.open || this.disabled) {
      return void 0;
    }
    this.open = false;
    return waitForEvent3(this, "sl-after-hide");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x42`
      <details
        part="base"
        class=${o12({
      details: true,
      "details--open": this.open,
      "details--disabled": this.disabled,
      "details--rtl": isRtl
    })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails2.styles = details_styles_default2;
SlDetails2.dependencies = {
  "sl-icon": SlIcon5
};
__decorateClass5([
  i8(".details")
], SlDetails2.prototype, "details", 2);
__decorateClass5([
  i8(".details__header")
], SlDetails2.prototype, "header", 2);
__decorateClass5([
  i8(".details__body")
], SlDetails2.prototype, "body", 2);
__decorateClass5([
  i8(".details__expand-icon-slot")
], SlDetails2.prototype, "expandIconSlot", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlDetails2.prototype, "open", 2);
__decorateClass5([
  n13()
], SlDetails2.prototype, "summary", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlDetails2.prototype, "disabled", 2);
__decorateClass5([
  watch5("open", { waitUntilFirstUpdate: true })
], SlDetails2.prototype, "handleOpenChange", 1);
setDefaultAnimation3("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" }
  ],
  options: { duration: 250, easing: "linear" }
});
setDefaultAnimation3("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" }
  ],
  options: { duration: 250, easing: "linear" }
});
var form_control_styles_default3 = i52`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;
var input_styles_default = i52`
  ${component_styles_default5}
  ${form_control_styles_default3}

  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition: var(--sl-transition-fast) color, var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear:not(.input__clear--visible) {
    visibility: hidden;
  }

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;
var defaultValue3 = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a42;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || n102;
      const fromAttribute = typeof converter === "function" ? converter : (_a42 = converter == null ? void 0 : converter.fromAttribute) != null ? _a42 : n102.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};
var l10 = e15(class extends i9 {
  constructor(r112) {
    if (super(r112), r112.type !== t92.PROPERTY && r112.type !== t92.ATTRIBUTE && r112.type !== t92.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!e14(r112)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r112) {
    return r112;
  }
  update(i12, [t11]) {
    if (t11 === T32 || t11 === A) return t11;
    const o15 = i12.element, l11 = i12.name;
    if (i12.type === t92.PROPERTY) {
      if (t11 === o15[l11]) return T32;
    } else if (i12.type === t92.BOOLEAN_ATTRIBUTE) {
      if (!!t11 === o15.hasAttribute(l11)) return T32;
    } else if (i12.type === t92.ATTRIBUTE && o15.getAttribute(l11) === t11 + "") return T32;
    return a52(i12), t11;
  }
});
var SlInput = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController5(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController5(this, "help-text", "label");
    this.localize = new LocalizeController24(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
    this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a42;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a42 = this.input) == null ? void 0 : _a42.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a42;
    this.__numberInput.value = this.value;
    return ((_a42 = this.input) == null ? void 0 : _a42.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    this.value = "";
    this.emit("sl-clear");
    this.emit("sl-input");
    this.emit("sl-change");
    this.input.focus();
    event.stopPropagation();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode) {
    this.input.setRangeText(replacement, start, end, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return x42`
      <div
        part="form-control"
        class=${o12({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${o12({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${l9(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${l9(this.placeholder)}
              minlength=${l9(this.minlength)}
              maxlength=${l9(this.maxlength)}
              min=${l9(this.min)}
              max=${l9(this.max)}
              step=${l9(this.step)}
              .value=${l10(this.value)}
              autocapitalize=${l9(this.autocapitalize)}
              autocomplete=${l9(this.autocomplete)}
              autocorrect=${l9(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${l9(this.pattern)}
              enterkeyhint=${l9(this.enterkeyhint)}
              inputmode=${l9(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${hasClearIcon ? x42`
                  <button
                    part="clear-button"
                    class=${o12({
      input__clear: true,
      "input__clear--visible": isClearIconVisible
    })}
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? x42`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? x42`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : x42`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = input_styles_default;
SlInput.dependencies = { "sl-icon": SlIcon5 };
__decorateClass5([
  i8(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass5([
  t72()
], SlInput.prototype, "hasFocus", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "title", 2);
__decorateClass5([
  n13({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "name", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "value", 2);
__decorateClass5([
  defaultValue3()
], SlInput.prototype, "defaultValue", 2);
__decorateClass5([
  n13({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "label", 2);
__decorateClass5([
  n13({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "placeholder", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass5([
  n13({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass5([
  n13({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass5([
  n13({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass5([
  n13({ reflect: true })
], SlInput.prototype, "form", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "pattern", 2);
__decorateClass5([
  n13({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass5([
  n13({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "min", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "max", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "step", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "autocorrect", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "autocomplete", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass5([
  n13({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass5([
  n13()
], SlInput.prototype, "inputmode", 2);
__decorateClass5([
  watch5("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass5([
  watch5("step", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass5([
  watch5("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);
var checkbox_styles_default3 = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color, var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;
var SlCheckbox3 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController5(this, {
      value: (control2) => control2.checked ? control2.value || "on" : void 0,
      defaultValue: (control2) => control2.defaultChecked,
      setValue: (control2, checked) => control2.checked = checked
    });
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    return x42`
      <label
        part="base"
        class=${o12({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
      >
        <input
          class="checkbox__input"
          type="checkbox"
          title=${this.title}
          name=${this.name}
          value=${l9(this.value)}
          .indeterminate=${l10(this.indeterminate)}
          .checked=${l10(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          aria-checked=${this.checked ? "true" : "false"}
          @click=${this.handleClick}
          @input=${this.handleInput}
          @invalid=${this.handleInvalid}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
        />

        <span
          part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
          class="checkbox__control"
        >
          ${this.checked ? x42`
                <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
              ` : ""}
          ${!this.checked && this.indeterminate ? x42`
                <sl-icon
                  part="indeterminate-icon"
                  class="checkbox__indeterminate-icon"
                  library="system"
                  name="indeterminate"
                ></sl-icon>
              ` : ""}
        </span>

        <div part="label" class="checkbox__label">
          <slot></slot>
        </div>
      </label>
    `;
  }
};
SlCheckbox3.styles = checkbox_styles_default3;
SlCheckbox3.dependencies = { "sl-icon": SlIcon5 };
__decorateClass5([
  i8('input[type="checkbox"]')
], SlCheckbox3.prototype, "input", 2);
__decorateClass5([
  t72()
], SlCheckbox3.prototype, "hasFocus", 2);
__decorateClass5([
  n13()
], SlCheckbox3.prototype, "title", 2);
__decorateClass5([
  n13()
], SlCheckbox3.prototype, "name", 2);
__decorateClass5([
  n13()
], SlCheckbox3.prototype, "value", 2);
__decorateClass5([
  n13({ reflect: true })
], SlCheckbox3.prototype, "size", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlCheckbox3.prototype, "disabled", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlCheckbox3.prototype, "checked", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlCheckbox3.prototype, "indeterminate", 2);
__decorateClass5([
  defaultValue3("checked")
], SlCheckbox3.prototype, "defaultChecked", 2);
__decorateClass5([
  n13({ reflect: true })
], SlCheckbox3.prototype, "form", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlCheckbox3.prototype, "required", 2);
__decorateClass5([
  watch5("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox3.prototype, "handleDisabledChange", 1);
__decorateClass5([
  watch5(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
], SlCheckbox3.prototype, "handleStateChange", 1);
var tooltip_styles_default = i52`
  ${component_styles_default5}

  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    pointer-events: none;
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
  }
`;
var popup_styles_default3 = i52`
  ${component_styles_default5}

  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }
`;
var min3 = Math.min;
var max3 = Math.max;
var round3 = Math.round;
var floor3 = Math.floor;
var createCoords3 = (v42) => ({
  x: v42,
  y: v42
});
var oppositeSideMap3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap3 = {
  start: "end",
  end: "start"
};
function clamp3(start, value, end) {
  return max3(start, min3(value, end));
}
function evaluate3(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide3(placement) {
  return placement.split("-")[0];
}
function getAlignment3(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis3(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength3(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis3(placement) {
  return ["top", "bottom"].includes(getSide3(placement)) ? "y" : "x";
}
function getAlignmentAxis3(placement) {
  return getOppositeAxis3(getSideAxis3(placement));
}
function getAlignmentSides3(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment3(placement);
  const alignmentAxis = getAlignmentAxis3(placement);
  const length = getAxisLength3(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement3(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement3(mainAlignmentSide)];
}
function getExpandedPlacements3(placement) {
  const oppositePlacement = getOppositePlacement3(placement);
  return [getOppositeAlignmentPlacement3(placement), oppositePlacement, getOppositeAlignmentPlacement3(oppositePlacement)];
}
function getOppositeAlignmentPlacement3(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap3[alignment]);
}
function getSideList3(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements3(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment3(placement);
  let list = getSideList3(getSide3(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement3));
    }
  }
  return list;
}
function getOppositePlacement3(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap3[side]);
}
function expandPaddingObject3(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject3(padding) {
  return typeof padding !== "number" ? expandPaddingObject3(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect3(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement3(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis3(placement);
  const alignmentAxis = getAlignmentAxis3(placement);
  const alignLength = getAxisLength3(alignmentAxis);
  const side = getSide3(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment3(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition4 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform22
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(floating));
  let rects = await platform22.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x52,
    y: y42
  } = computeCoordsFromPlacement3(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i12 = 0; i12 < validMiddleware.length; i12++) {
    const {
      name,
      fn
    } = validMiddleware[i12];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x52,
      y: y42,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform22,
      elements: {
        reference,
        floating
      }
    });
    x52 = nextX != null ? nextX : x52;
    y42 = nextY != null ? nextY : y42;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform22.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x52,
          y: y42
        } = computeCoordsFromPlacement3(rects, statefulPlacement, rtl));
      }
      i12 = -1;
      continue;
    }
  }
  return {
    x: x52,
    y: y42,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow3(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x52,
    y: y42,
    platform: platform22,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate3(options, state);
  const paddingObject = getPaddingObject3(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect3(await platform22.getClippingRect({
    element: ((_await$platform$isEle = await (platform22.isElement == null ? void 0 : platform22.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform22.getDocumentElement == null ? void 0 : platform22.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x52,
    y: y42
  } : rects.reference;
  const offsetParent = await (platform22.getOffsetParent == null ? void 0 : platform22.getOffsetParent(elements.floating));
  const offsetScale = await (platform22.isElement == null ? void 0 : platform22.isElement(offsetParent)) ? await (platform22.getScale == null ? void 0 : platform22.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect3(platform22.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform22.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x52,
      y: y42,
      placement,
      rects,
      platform: platform22,
      elements
    } = state;
    const {
      element,
      padding = 0
    } = evaluate3(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject3(padding);
    const coords = {
      x: x52,
      y: y42
    };
    const axis = getAlignmentAxis3(placement);
    const length = getAxisLength3(axis);
    const arrowDimensions = await platform22.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform22.getOffsetParent == null ? void 0 : platform22.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform22.isElement == null ? void 0 : platform22.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min3(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min3(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max22 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset22 = clamp3(min$1, center, max22);
    const shouldAddOffset = getAlignment3(placement) != null && center != offset22 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max22 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset22,
        centerOffset: center - offset22 + alignmentOffset
      }
    };
  }
});
var flip3 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform22,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate3(options, state);
      const side = getSide3(placement);
      const isBasePlacement = getSide3(initialPlacement) === initialPlacement;
      const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement3(initialPlacement)] : getExpandedPlacements3(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements3(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow3(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides3(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d52) => d52.overflows[0] <= 0).sort((a72, b42) => a72.overflows[1] - b42.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d52) => [d52.placement, d52.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a72, b42) => a72[1] - b42[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords3(state, options) {
  const {
    placement,
    platform: platform22,
    elements
  } = state;
  const rtl = await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating));
  const side = getSide3(placement);
  const alignment = getAlignment3(placement);
  const isVertical = getSideAxis3(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate3(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset3 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x52,
        y: y42
      } = state;
      const diffCoords = await convertValueToCoords3(state, options);
      return {
        x: x52 + diffCoords.x,
        y: y42 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift3 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x52,
        y: y42,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x62,
              y: y52
            } = _ref;
            return {
              x: x62,
              y: y52
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate3(options, state);
      const coords = {
        x: x52,
        y: y42
      };
      const overflow = await detectOverflow3(state, detectOverflowOptions);
      const crossAxis = getSideAxis3(getSide3(placement));
      const mainAxis = getOppositeAxis3(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min22 = mainAxisCoord + overflow[minSide];
        const max22 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp3(min22, mainAxisCoord, max22);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min22 = crossAxisCoord + overflow[minSide];
        const max22 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp3(min22, crossAxisCoord, max22);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x52,
          y: limitedCoords.y - y42
        }
      };
    }
  };
};
var size3 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform22,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate3(options, state);
      const overflow = await detectOverflow3(state, detectOverflowOptions);
      const side = getSide3(placement);
      const alignment = getAlignment3(placement);
      const isYAxis = getSideAxis3(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform22.isRTL == null ? void 0 : platform22.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min3(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min3(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max3(overflow.left, 0);
        const xMax = max3(overflow.right, 0);
        const yMin = max3(overflow.top, 0);
        const yMax = max3(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max3(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max3(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform22.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName3(node) {
  if (isNode3(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow3(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement3(node) {
  var _ref;
  return (_ref = (isNode3(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode3(value) {
  return value instanceof Node || value instanceof getWindow3(value).Node;
}
function isElement3(value) {
  return value instanceof Element || value instanceof getWindow3(value).Element;
}
function isHTMLElement3(value) {
  return value instanceof HTMLElement || value instanceof getWindow3(value).HTMLElement;
}
function isShadowRoot3(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow3(value).ShadowRoot;
}
function isOverflowElement3(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle23(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement3(element) {
  return ["table", "td", "th"].includes(getNodeName3(element));
}
function isContainingBlock3(element) {
  const webkit = isWebKit3();
  const css2 = getComputedStyle23(element);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock3(element) {
  let currentNode = getParentNode3(element);
  while (isHTMLElement3(currentNode) && !isLastTraversableNode3(currentNode)) {
    if (isContainingBlock3(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode3(currentNode);
    }
  }
  return null;
}
function isWebKit3() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode3(node) {
  return ["html", "body", "#document"].includes(getNodeName3(node));
}
function getComputedStyle23(element) {
  return getWindow3(element).getComputedStyle(element);
}
function getNodeScroll3(element) {
  if (isElement3(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode3(node) {
  if (getNodeName3(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot3(node) && node.host || // Fallback.
    getDocumentElement3(node)
  );
  return isShadowRoot3(result) ? result.host : result;
}
function getNearestOverflowAncestor3(node) {
  const parentNode = getParentNode3(node);
  if (isLastTraversableNode3(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement3(parentNode) && isOverflowElement3(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor3(parentNode);
}
function getOverflowAncestors3(node, list) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor3(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow3(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement3(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors3(scrollableAncestor));
}
function getCssDimensions3(element) {
  const css2 = getComputedStyle23(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement3(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round3(width) !== offsetWidth || round3(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement3(element) {
  return !isElement3(element) ? element.contextElement : element;
}
function getScale3(element) {
  const domElement = unwrapElement3(element);
  if (!isHTMLElement3(domElement)) {
    return createCoords3(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $42
  } = getCssDimensions3(domElement);
  let x52 = ($42 ? round3(rect.width) : rect.width) / width;
  let y42 = ($42 ? round3(rect.height) : rect.height) / height;
  if (!x52 || !Number.isFinite(x52)) {
    x52 = 1;
  }
  if (!y42 || !Number.isFinite(y42)) {
    y42 = 1;
  }
  return {
    x: x52,
    y: y42
  };
}
var noOffsets3 = /* @__PURE__ */ createCoords3(0);
function getVisualOffsets3(element) {
  const win = getWindow3(element);
  if (!isWebKit3() || !win.visualViewport) {
    return noOffsets3;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets3(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow3(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect3(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement3(element);
  let scale = createCoords3(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement3(offsetParent)) {
        scale = getScale3(offsetParent);
      }
    } else {
      scale = getScale3(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets3(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets3(domElement) : createCoords3(0);
  let x52 = (clientRect.left + visualOffsets.x) / scale.x;
  let y42 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow3(domElement);
    const offsetWin = offsetParent && isElement3(offsetParent) ? getWindow3(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale3(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle23(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x52 *= iframeScale.x;
      y42 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x52 += left;
      y42 += top;
      currentIFrame = getWindow3(currentIFrame).frameElement;
    }
  }
  return rectToClientRect3({
    width,
    height,
    x: x52,
    y: y42
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect3(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement3(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords3(1);
  const offsets = createCoords3(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName3(offsetParent) !== "body" || isOverflowElement3(documentElement)) {
      scroll = getNodeScroll3(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      const offsetRect = getBoundingClientRect3(offsetParent);
      scale = getScale3(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects3(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX3(element) {
  return getBoundingClientRect3(getDocumentElement3(element)).left + getNodeScroll3(element).scrollLeft;
}
function getDocumentRect3(element) {
  const html2 = getDocumentElement3(element);
  const scroll = getNodeScroll3(element);
  const body = element.ownerDocument.body;
  const width = max3(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max3(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x52 = -scroll.scrollLeft + getWindowScrollBarX3(element);
  const y42 = -scroll.scrollTop;
  if (getComputedStyle23(body).direction === "rtl") {
    x52 += max3(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x52,
    y: y42
  };
}
function getViewportRect3(element, strategy) {
  const win = getWindow3(element);
  const html2 = getDocumentElement3(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x52 = 0;
  let y42 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit3();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x52 = visualViewport.offsetLeft;
      y42 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x52,
    y: y42
  };
}
function getInnerBoundingClientRect3(element, strategy) {
  const clientRect = getBoundingClientRect3(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement3(element) ? getScale3(element) : createCoords3(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x52 = left * scale.x;
  const y42 = top * scale.y;
  return {
    width,
    height,
    x: x52,
    y: y42
  };
}
function getClientRectFromClippingAncestor3(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect3(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect3(getDocumentElement3(element));
  } else if (isElement3(clippingAncestor)) {
    rect = getInnerBoundingClientRect3(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets3(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect3(rect);
}
function hasFixedPositionAncestor3(element, stopNode) {
  const parentNode = getParentNode3(element);
  if (parentNode === stopNode || !isElement3(parentNode) || isLastTraversableNode3(parentNode)) {
    return false;
  }
  return getComputedStyle23(parentNode).position === "fixed" || hasFixedPositionAncestor3(parentNode, stopNode);
}
function getClippingElementAncestors3(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors3(element).filter((el) => isElement3(el) && getNodeName3(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle23(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode3(element) : element;
  while (isElement3(currentNode) && !isLastTraversableNode3(currentNode)) {
    const computedStyle = getComputedStyle23(currentNode);
    const currentNodeIsContaining = isContainingBlock3(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement3(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor3(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode3(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect3(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors3(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor3(element, clippingAncestor, strategy);
    accRect.top = max3(rect.top, accRect.top);
    accRect.right = min3(rect.right, accRect.right);
    accRect.bottom = min3(rect.bottom, accRect.bottom);
    accRect.left = max3(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor3(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions3(element) {
  return getCssDimensions3(element);
}
function getRectRelativeToOffsetParent3(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement3(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect3(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords3(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName3(offsetParent) !== "body" || isOverflowElement3(documentElement)) {
      scroll = getNodeScroll3(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect3(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX3(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent3(element, polyfill) {
  if (!isHTMLElement3(element) || getComputedStyle23(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent3(element, polyfill) {
  const window2 = getWindow3(element);
  if (!isHTMLElement3(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent3(element, polyfill);
  while (offsetParent && isTableElement3(offsetParent) && getComputedStyle23(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent3(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName3(offsetParent) === "html" || getNodeName3(offsetParent) === "body" && getComputedStyle23(offsetParent).position === "static" && !isContainingBlock3(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock3(element) || window2;
}
var getElementRects3 = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent3;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent3(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL3(element) {
  return getComputedStyle23(element).direction === "rtl";
}
var platform3 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect3,
  getDocumentElement: getDocumentElement3,
  getClippingRect: getClippingRect3,
  getOffsetParent: getOffsetParent3,
  getElementRects: getElementRects3,
  getClientRects: getClientRects3,
  getDimensions: getDimensions3,
  getScale: getScale3,
  isElement: isElement3,
  isRTL: isRTL3
};
function observeMove3(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement3(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor3(top);
    const insetRight = floor3(root.clientWidth - (left + width));
    const insetBottom = floor3(root.clientHeight - (top + height));
    const insetLeft = floor3(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max3(0, min3(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e17) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate3(reference, floating, update22, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement3(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors3(referenceEl) : [], ...getOverflowAncestors3(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update22, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update22);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove3(referenceEl, update22) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update22();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect3(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect3(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update22();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update22();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update22);
      ancestorResize && ancestor.removeEventListener("resize", update22);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition23 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform3,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition4(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function t102(t11) {
  return r102(t11);
}
function o13(t11) {
  return t11.assignedSlot ? t11.assignedSlot : t11.parentNode instanceof ShadowRoot ? t11.parentNode.host : t11.parentNode;
}
function r102(t11) {
  for (let e17 = t11; e17; e17 = o13(e17)) if (e17 instanceof Element && "none" === getComputedStyle(e17).display) return null;
  for (let e17 = o13(t11); e17; e17 = o13(e17)) {
    if (!(e17 instanceof Element)) continue;
    const t12 = getComputedStyle(e17);
    if ("contents" !== t12.display) {
      if ("static" !== t12.position || "none" !== t12.filter) return e17;
      if ("BODY" === e17.tagName) return e17;
    }
  }
  return null;
}
function isVirtualElement3(e17) {
  return e17 !== null && typeof e17 === "object" && "getBoundingClientRect" in e17;
}
var SlPopup3 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement3(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (!this.anchorEl) {
      throw new Error(
        "Invalid anchor element: no anchor could be found using the anchor slot or the anchor attribute."
      );
    }
    this.start();
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate3(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset3({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size3({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip3({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift3({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size3({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow3({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent22 = this.strategy === "absolute" ? (element) => platform3.getOffsetParent(element, t102) : platform3.getOffsetParent;
    computePosition23(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps5(__spreadValues5({}, platform3), {
        getOffsetParent: getOffsetParent22
      })
    }).then(({ x: x52, y: y42, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x52}px`,
        top: `${y42}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    this.emit("sl-reposition");
  }
  render() {
    return x42`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <div
        part="popup"
        class=${o12({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? x42`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup3.styles = popup_styles_default3;
__decorateClass5([
  i8(".popup")
], SlPopup3.prototype, "popup", 2);
__decorateClass5([
  i8(".popup__arrow")
], SlPopup3.prototype, "arrowEl", 2);
__decorateClass5([
  n13()
], SlPopup3.prototype, "anchor", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlPopup3.prototype, "active", 2);
__decorateClass5([
  n13({ reflect: true })
], SlPopup3.prototype, "placement", 2);
__decorateClass5([
  n13({ reflect: true })
], SlPopup3.prototype, "strategy", 2);
__decorateClass5([
  n13({ type: Number })
], SlPopup3.prototype, "distance", 2);
__decorateClass5([
  n13({ type: Number })
], SlPopup3.prototype, "skidding", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlPopup3.prototype, "arrow", 2);
__decorateClass5([
  n13({ attribute: "arrow-placement" })
], SlPopup3.prototype, "arrowPlacement", 2);
__decorateClass5([
  n13({ attribute: "arrow-padding", type: Number })
], SlPopup3.prototype, "arrowPadding", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlPopup3.prototype, "flip", 2);
__decorateClass5([
  n13({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p42) => p42.trim()).filter((p42) => p42 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup3.prototype, "flipFallbackPlacements", 2);
__decorateClass5([
  n13({ attribute: "flip-fallback-strategy" })
], SlPopup3.prototype, "flipFallbackStrategy", 2);
__decorateClass5([
  n13({ type: Object })
], SlPopup3.prototype, "flipBoundary", 2);
__decorateClass5([
  n13({ attribute: "flip-padding", type: Number })
], SlPopup3.prototype, "flipPadding", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlPopup3.prototype, "shift", 2);
__decorateClass5([
  n13({ type: Object })
], SlPopup3.prototype, "shiftBoundary", 2);
__decorateClass5([
  n13({ attribute: "shift-padding", type: Number })
], SlPopup3.prototype, "shiftPadding", 2);
__decorateClass5([
  n13({ attribute: "auto-size" })
], SlPopup3.prototype, "autoSize", 2);
__decorateClass5([
  n13()
], SlPopup3.prototype, "sync", 2);
__decorateClass5([
  n13({ type: Object })
], SlPopup3.prototype, "autoSizeBoundary", 2);
__decorateClass5([
  n13({ attribute: "auto-size-padding", type: Number })
], SlPopup3.prototype, "autoSizePadding", 2);
var SlTooltip = class extends ShoelaceElement5 {
  constructor() {
    super();
    this.localize = new LocalizeController24(this);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 8;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
    this.handleBlur = () => {
      if (this.hasTrigger("focus")) {
        this.hide();
      }
    };
    this.handleClick = () => {
      if (this.hasTrigger("click")) {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
    };
    this.handleFocus = () => {
      if (this.hasTrigger("focus")) {
        this.show();
      }
    };
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
      }
    };
    this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.show(), delay);
      }
    };
    this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
      }
    };
    this.addEventListener("blur", this.handleBlur, true);
    this.addEventListener("focus", this.handleFocus, true);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("keydown", this.handleKeyDown);
    this.addEventListener("mouseover", this.handleMouseOver);
    this.addEventListener("mouseout", this.handleMouseOut);
  }
  connectedCallback() {
    super.connectedCallback();
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    if (this.open) {
      this.popup.active = true;
      this.popup.reposition();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  async handleOpenChange() {
    if (this.open) {
      if (this.disabled) {
        return;
      }
      this.emit("sl-show");
      await stopAnimations3(this.body);
      this.body.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation3(this, "tooltip.show", { dir: this.localize.dir() });
      await animateTo3(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      await stopAnimations3(this.body);
      const { keyframes, options } = getAnimation3(this, "tooltip.hide", { dir: this.localize.dir() });
      await animateTo3(this.popup.popup, keyframes, options);
      this.popup.active = false;
      this.body.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    if (this.hasUpdated) {
      await this.updateComplete;
      this.popup.reposition();
    }
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  /** Shows the tooltip. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent3(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent3(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return x42`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${o12({
      tooltip: true,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = tooltip_styles_default;
SlTooltip.dependencies = { "sl-popup": SlPopup3 };
__decorateClass5([
  i8("slot:not([name])")
], SlTooltip.prototype, "defaultSlot", 2);
__decorateClass5([
  i8(".tooltip__body")
], SlTooltip.prototype, "body", 2);
__decorateClass5([
  i8("sl-popup")
], SlTooltip.prototype, "popup", 2);
__decorateClass5([
  n13()
], SlTooltip.prototype, "content", 2);
__decorateClass5([
  n13()
], SlTooltip.prototype, "placement", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlTooltip.prototype, "disabled", 2);
__decorateClass5([
  n13({ type: Number })
], SlTooltip.prototype, "distance", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlTooltip.prototype, "open", 2);
__decorateClass5([
  n13({ type: Number })
], SlTooltip.prototype, "skidding", 2);
__decorateClass5([
  n13()
], SlTooltip.prototype, "trigger", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlTooltip.prototype, "hoist", 2);
__decorateClass5([
  watch5("open", { waitUntilFirstUpdate: true })
], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass5([
  watch5(["content", "distance", "hoist", "placement", "skidding"])
], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass5([
  watch5("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
setDefaultAnimation3("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 150, easing: "ease" }
});
setDefaultAnimation3("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 150, easing: "ease" }
});
var button_group_styles_default4 = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;
var SlButtonGroup4 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton4(event.target);
    button == null ? void 0 : button.classList.add("sl-button-group__button--focus");
  }
  handleBlur(event) {
    const button = findButton4(event.target);
    button == null ? void 0 : button.classList.remove("sl-button-group__button--focus");
  }
  handleMouseOver(event) {
    const button = findButton4(event.target);
    button == null ? void 0 : button.classList.add("sl-button-group__button--hover");
  }
  handleMouseOut(event) {
    const button = findButton4(event.target);
    button == null ? void 0 : button.classList.remove("sl-button-group__button--hover");
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton4(el);
      if (button !== null) {
        button.classList.add("sl-button-group__button");
        button.classList.toggle("sl-button-group__button--first", index === 0);
        button.classList.toggle("sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.classList.toggle("sl-button-group__button--last", index === slottedElements.length - 1);
        button.classList.toggle("sl-button-group__button--radio", button.tagName.toLowerCase() === "sl-radio-button");
      }
    });
  }
  render() {
    return x42`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup4.styles = button_group_styles_default4;
__decorateClass5([
  i8("slot")
], SlButtonGroup4.prototype, "defaultSlot", 2);
__decorateClass5([
  t72()
], SlButtonGroup4.prototype, "disableRole", 2);
__decorateClass5([
  n13()
], SlButtonGroup4.prototype, "label", 2);
function findButton4(el) {
  var _a42;
  const selector = "sl-button, sl-radio-button";
  return (_a42 = el.closest(selector)) != null ? _a42 : el.querySelector(selector);
}
function isTabbable2(el) {
  const tag = el.tagName.toLowerCase();
  if (el.getAttribute("tabindex") === "-1") {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") !== "false") {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (el.offsetParent === null && t102(el) === null) {
    return false;
  }
  if (window.getComputedStyle(el).visibility === "hidden") {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  return ["button", "input", "select", "textarea", "a", "audio", "video", "summary"].includes(tag);
}
function getTabbableBoundary2(root) {
  var _a42, _b;
  const tabbableElements = getTabbableElements2(root);
  const start = (_a42 = tabbableElements[0]) != null ? _a42 : null;
  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
  return { start, end };
}
function getTabbableElements2(root) {
  const allElements = [];
  function walk(el) {
    if (el instanceof Element) {
      allElements.push(el);
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    [...el.children].forEach((e17) => walk(e17));
  }
  walk(root);
  return allElements.filter(isTabbable2).sort((a72, b42) => {
    const aTabindex = Number(a72.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b42.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}
var activeModals = [];
var Modal = class {
  constructor(element) {
    this.tabDirection = "forward";
    this.handleFocusIn = () => {
      this.checkFocus();
    };
    this.handleKeyDown = (event) => {
      var _a42;
      if (event.key !== "Tab")
        return;
      if (event.shiftKey) {
        this.tabDirection = "backward";
      } else {
        this.tabDirection = "forward";
      }
      event.preventDefault();
      const tabbableElements = getTabbableElements2(this.element);
      const start = tabbableElements[0];
      let focusIndex = this.currentFocusIndex;
      if (focusIndex === -1) {
        this.currentFocus = start;
        this.currentFocus.focus({ preventScroll: true });
        return;
      }
      const addition = this.tabDirection === "forward" ? 1 : -1;
      if (focusIndex + addition >= tabbableElements.length) {
        focusIndex = 0;
      } else if (this.currentFocusIndex + addition < 0) {
        focusIndex = tabbableElements.length - 1;
      } else {
        focusIndex += addition;
      }
      this.currentFocus = tabbableElements[focusIndex];
      (_a42 = this.currentFocus) == null ? void 0 : _a42.focus({ preventScroll: true });
      setTimeout(() => this.checkFocus());
    };
    this.handleKeyUp = () => {
      this.tabDirection = "forward";
    };
    this.element = element;
  }
  activate() {
    activeModals.push(this.element);
    document.addEventListener("focusin", this.handleFocusIn);
    document.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("keyup", this.handleKeyUp);
  }
  deactivate() {
    activeModals = activeModals.filter((modal) => modal !== this.element);
    this.currentFocus = null;
    document.removeEventListener("focusin", this.handleFocusIn);
    document.removeEventListener("keydown", this.handleKeyDown);
    document.removeEventListener("keyup", this.handleKeyUp);
  }
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  checkFocus() {
    if (this.isActive()) {
      const tabbableElements = getTabbableElements2(this.element);
      if (!this.element.matches(":focus-within")) {
        const start = tabbableElements[0];
        const end = tabbableElements[tabbableElements.length - 1];
        const target = this.tabDirection === "forward" ? start : end;
        if (typeof (target == null ? void 0 : target.focus) === "function") {
          this.currentFocus = target;
          target.focus({ preventScroll: true });
        }
      }
    }
  }
  get currentFocusIndex() {
    return getTabbableElements2(this.element).findIndex((el) => el === this.currentFocus);
  }
};
var locks = /* @__PURE__ */ new Set();
function getScrollbarWidth() {
  const documentWidth = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function lockBodyScrolling(lockingEl) {
  locks.add(lockingEl);
  if (!document.body.classList.contains("sl-scroll-lock")) {
    const scrollbarWidth = getScrollbarWidth();
    document.body.classList.add("sl-scroll-lock");
    document.body.style.setProperty("--sl-scroll-lock-size", `${scrollbarWidth}px`);
  }
}
function unlockBodyScrolling(lockingEl) {
  locks.delete(lockingEl);
  if (locks.size === 0) {
    document.body.classList.remove("sl-scroll-lock");
    document.body.style.removeProperty("--sl-scroll-lock-size");
  }
}
var dialog_styles_default = i52`
  ${component_styles_default5}

  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;
var icon_button_styles_default2 = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;
var SlIconButton2 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? i10`a` : i10`button`;
    return n15`
      <${tag}
        part="base"
        class=${o12({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${l9(isLink ? void 0 : this.disabled)}
        type=${l9(isLink ? void 0 : "button")}
        href=${l9(isLink ? this.href : void 0)}
        target=${l9(isLink ? this.target : void 0)}
        download=${l9(isLink ? this.download : void 0)}
        rel=${l9(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${l9(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${l9(this.name)}
          library=${l9(this.library)}
          src=${l9(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton2.styles = icon_button_styles_default2;
SlIconButton2.dependencies = { "sl-icon": SlIcon5 };
__decorateClass5([
  i8(".icon-button")
], SlIconButton2.prototype, "button", 2);
__decorateClass5([
  t72()
], SlIconButton2.prototype, "hasFocus", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "name", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "library", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "src", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "href", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "target", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "download", 2);
__decorateClass5([
  n13()
], SlIconButton2.prototype, "label", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlIconButton2.prototype, "disabled", 2);
var SlDialog = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController5(this, "footer");
    this.localize = new LocalizeController24(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.noHeader = false;
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopPropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.dialog.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.modal.activate();
      lockBodyScrolling(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.modal.deactivate();
    unlockBodyScrolling(this);
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: { source }
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation3(this, "dialog.denyClose", { dir: this.localize.dir() });
      animateTo3(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    document.addEventListener("keydown", this.handleDocumentKeyDown);
  }
  removeOpenListeners() {
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      this.modal.activate();
      lockBodyScrolling(this);
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([stopAnimations3(this.dialog), stopAnimations3(this.overlay)]);
      this.dialog.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", { cancelable: true });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({ preventScroll: true });
          } else {
            this.panel.focus({ preventScroll: true });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation3(this, "dialog.show", { dir: this.localize.dir() });
      const overlayAnimation = getAnimation3(this, "dialog.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo3(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo3(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
      ]);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      this.modal.deactivate();
      await Promise.all([stopAnimations3(this.dialog), stopAnimations3(this.overlay)]);
      const panelAnimation = getAnimation3(this, "dialog.hide", { dir: this.localize.dir() });
      const overlayAnimation = getAnimation3(this, "dialog.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo3(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {
          this.overlay.hidden = true;
        }),
        animateTo3(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {
          this.panel.hidden = true;
        })
      ]);
      this.dialog.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      unlockBodyScrolling(this);
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  /** Shows the dialog. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent3(this, "sl-after-show");
  }
  /** Hides the dialog */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent3(this, "sl-after-hide");
  }
  render() {
    return x42`
      <div
        part="base"
        class=${o12({
      dialog: true,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${l9(this.noHeader ? this.label : void 0)}
          aria-labelledby=${l9(!this.noHeader ? "title" : void 0)}
          tabindex="-1"
        >
          ${!this.noHeader ? x42`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              ` : ""}
          ${""}
          <slot part="body" class="dialog__body" tabindex="-1"></slot>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = dialog_styles_default;
SlDialog.dependencies = {
  "sl-icon-button": SlIconButton2
};
__decorateClass5([
  i8(".dialog")
], SlDialog.prototype, "dialog", 2);
__decorateClass5([
  i8(".dialog__panel")
], SlDialog.prototype, "panel", 2);
__decorateClass5([
  i8(".dialog__overlay")
], SlDialog.prototype, "overlay", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlDialog.prototype, "open", 2);
__decorateClass5([
  n13({ reflect: true })
], SlDialog.prototype, "label", 2);
__decorateClass5([
  n13({ attribute: "no-header", type: Boolean, reflect: true })
], SlDialog.prototype, "noHeader", 2);
__decorateClass5([
  watch5("open", { waitUntilFirstUpdate: true })
], SlDialog.prototype, "handleOpenChange", 1);
setDefaultAnimation3("dialog.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation3("dialog.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation3("dialog.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.02 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation3("dialog.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation3("dialog.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});
var menu_styles_default2 = i52`
  ${component_styles_default5}

  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;
var SlMenu2 = class extends ShoelaceElement5 {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const target = event.target;
    const item = target.closest("sl-menu-item");
    if (!item || item.disabled || item.inert) {
      return;
    }
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", { detail: { item } });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      item == null ? void 0 : item.click();
    }
    if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a42;
    return item.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((_a42 = item.getAttribute("role")) != null ? _a42 : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {
      if (el.inert || !this.isMenuItem(el)) {
        return false;
      }
      return true;
    });
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((i12) => i12.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach((i12) => {
      i12.setAttribute("tabindex", i12 === item ? "0" : "-1");
    });
  }
  render() {
    return x42`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu2.styles = menu_styles_default2;
__decorateClass5([
  i8("slot")
], SlMenu2.prototype, "defaultSlot", 2);
var menu_item_styles_default2 = i52`
  ${component_styles_default5}

  :host {
    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;
var SlMenuItem2 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.disabled = false;
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent2(this.defaultSlot);
  }
  render() {
    return x42`
      <div
        part="base"
        class=${o12({
      "menu-item": true,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--has-submenu": false
      // reserved for future use
    })}
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name="chevron-right" library="system" aria-hidden="true"></sl-icon>
        </span>
      </div>
    `;
  }
};
SlMenuItem2.styles = menu_item_styles_default2;
SlMenuItem2.dependencies = { "sl-icon": SlIcon5 };
__decorateClass5([
  i8("slot:not([name])")
], SlMenuItem2.prototype, "defaultSlot", 2);
__decorateClass5([
  i8(".menu-item")
], SlMenuItem2.prototype, "menuItem", 2);
__decorateClass5([
  n13()
], SlMenuItem2.prototype, "type", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlMenuItem2.prototype, "checked", 2);
__decorateClass5([
  n13()
], SlMenuItem2.prototype, "value", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlMenuItem2.prototype, "disabled", 2);
__decorateClass5([
  watch5("checked")
], SlMenuItem2.prototype, "handleCheckedChange", 1);
__decorateClass5([
  watch5("disabled")
], SlMenuItem2.prototype, "handleDisabledChange", 1);
__decorateClass5([
  watch5("type")
], SlMenuItem2.prototype, "handleTypeChange", 1);
var dropdown_styles_default2 = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
var SlDropdown2 = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController24(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a42;
      if (event.key === "Escape" && this.open) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (this.open && ((_a42 = document.activeElement) == null ? void 0 : _a42.tagName.toLowerCase()) === "sl-menu-item") {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a222, _b, _c;
          const activeElement = ((_a222 = this.containingElement) == null ? void 0 : _a222.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
          if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary2(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent3(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent3(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    this.panel.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations3(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation3(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo3(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations3(this);
      const { keyframes, options } = getAnimation3(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo3(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return x42`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        class=${o12({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown2.styles = dropdown_styles_default2;
SlDropdown2.dependencies = { "sl-popup": SlPopup3 };
__decorateClass5([
  i8(".dropdown")
], SlDropdown2.prototype, "popup", 2);
__decorateClass5([
  i8(".dropdown__trigger")
], SlDropdown2.prototype, "trigger", 2);
__decorateClass5([
  i8(".dropdown__panel")
], SlDropdown2.prototype, "panel", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlDropdown2.prototype, "open", 2);
__decorateClass5([
  n13({ reflect: true })
], SlDropdown2.prototype, "placement", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlDropdown2.prototype, "disabled", 2);
__decorateClass5([
  n13({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown2.prototype, "stayOpenOnSelect", 2);
__decorateClass5([
  n13({ attribute: false })
], SlDropdown2.prototype, "containingElement", 2);
__decorateClass5([
  n13({ type: Number })
], SlDropdown2.prototype, "distance", 2);
__decorateClass5([
  n13({ type: Number })
], SlDropdown2.prototype, "skidding", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlDropdown2.prototype, "hoist", 2);
__decorateClass5([
  watch5("open", { waitUntilFirstUpdate: true })
], SlDropdown2.prototype, "handleOpenChange", 1);
setDefaultAnimation3("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation3("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
var range_styles_default = i52`
  ${component_styles_default5}
  ${form_control_styles_default3}

  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color, var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`;
var SlRange = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController5(this);
    this.hasSlotController = new HasSlotController5(this, "help-text", "label");
    this.localize = new LocalizeController24(this);
    this.hasFocus = false;
    this.hasTooltip = false;
    this.title = "";
    this.name = "";
    this.value = 0;
    this.label = "";
    this.helpText = "";
    this.disabled = false;
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.tooltip = "top";
    this.tooltipFormatter = (value) => value.toString();
    this.form = "";
    this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.syncRange());
    if (this.value < this.min) {
      this.value = this.min;
    }
    if (this.value > this.max) {
      this.value = this.max;
    }
    this.updateComplete.then(() => {
      this.syncRange();
      this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value);
    this.emit("sl-input");
    this.syncRange();
  }
  handleBlur() {
    this.hasFocus = false;
    this.hasTooltip = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.hasTooltip = true;
    this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = true;
  }
  handleThumbDragEnd() {
    this.hasTooltip = false;
  }
  syncProgress(percent) {
    this.input.style.setProperty("--percent", `${percent * 100}%`);
  }
  syncTooltip(percent) {
    if (this.output !== null) {
      const inputWidth = this.input.offsetWidth;
      const tooltipWidth = this.output.offsetWidth;
      const thumbSize = getComputedStyle(this.input).getPropertyValue("--thumb-size");
      const isRtl = this.localize.dir() === "rtl";
      const percentAsWidth = inputWidth * percent;
      if (isRtl) {
        const x52 = `${inputWidth - percentAsWidth}px + ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc((${x52} - ${tooltipWidth / 2}px - ${thumbSize} / 2))`;
      } else {
        const x52 = `${percentAsWidth}px - ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc(${x52} - ${tooltipWidth / 2}px + ${thumbSize} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity();
    this.input.value = this.value.toString();
    this.value = parseFloat(this.input.value);
    this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const percent = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(percent);
    if (this.tooltip !== "none") {
      this.syncTooltip(percent);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  /** Sets focus on the range. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x42`
      <div
        part="form-control"
        class=${o12({
      "form-control": true,
      "form-control--medium": true,
      // range only has one size
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${o12({
      range: true,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${l9(this.name)}
              ?disabled=${this.disabled}
              min=${l9(this.min)}
              max=${l9(this.max)}
              step=${l9(this.step)}
              .value=${l10(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? x42`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter === "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = range_styles_default;
__decorateClass5([
  i8(".range__control")
], SlRange.prototype, "input", 2);
__decorateClass5([
  i8(".range__tooltip")
], SlRange.prototype, "output", 2);
__decorateClass5([
  t72()
], SlRange.prototype, "hasFocus", 2);
__decorateClass5([
  t72()
], SlRange.prototype, "hasTooltip", 2);
__decorateClass5([
  n13()
], SlRange.prototype, "title", 2);
__decorateClass5([
  n13()
], SlRange.prototype, "name", 2);
__decorateClass5([
  n13({ type: Number })
], SlRange.prototype, "value", 2);
__decorateClass5([
  n13()
], SlRange.prototype, "label", 2);
__decorateClass5([
  n13({ attribute: "help-text" })
], SlRange.prototype, "helpText", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlRange.prototype, "disabled", 2);
__decorateClass5([
  n13({ type: Number })
], SlRange.prototype, "min", 2);
__decorateClass5([
  n13({ type: Number })
], SlRange.prototype, "max", 2);
__decorateClass5([
  n13({ type: Number })
], SlRange.prototype, "step", 2);
__decorateClass5([
  n13()
], SlRange.prototype, "tooltip", 2);
__decorateClass5([
  n13({ attribute: false })
], SlRange.prototype, "tooltipFormatter", 2);
__decorateClass5([
  n13({ reflect: true })
], SlRange.prototype, "form", 2);
__decorateClass5([
  defaultValue3()
], SlRange.prototype, "defaultValue", 2);
__decorateClass5([
  e12({ passive: true })
], SlRange.prototype, "handleThumbDragStart", 1);
__decorateClass5([
  watch5("value", { waitUntilFirstUpdate: true })
], SlRange.prototype, "handleValueChange", 1);
__decorateClass5([
  watch5("disabled", { waitUntilFirstUpdate: true })
], SlRange.prototype, "handleDisabledChange", 1);
__decorateClass5([
  watch5("hasTooltip", { waitUntilFirstUpdate: true })
], SlRange.prototype, "syncRange", 1);
var progress_bar_styles_default = i52`
  ${component_styles_default5}

  :host {
    --height: 1rem;
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);
    --label-color: var(--sl-color-neutral-0);

    display: block;
  }

  .progress-bar {
    position: relative;
    background-color: var(--track-color);
    height: var(--height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset var(--sl-shadow-small);
    overflow: hidden;
  }

  .progress-bar__indicator {
    height: 100%;
    font-family: var(--sl-font-sans);
    font-size: 12px;
    font-weight: var(--sl-font-weight-normal);
    background-color: var(--indicator-color);
    color: var(--label-color);
    text-align: center;
    line-height: var(--height);
    white-space: nowrap;
    overflow: hidden;
    transition: 400ms width, 400ms background-color;
    user-select: none;
  }

  /* Indeterminate */
  .progress-bar--indeterminate .progress-bar__indicator {
    position: absolute;
    animation: indeterminate 2.5s infinite cubic-bezier(0.37, 0, 0.63, 1);
  }

  .progress-bar--indeterminate.progress-bar--rtl .progress-bar__indicator {
    animation-name: indeterminate-rtl;
  }

  @media (forced-colors: active) {
    .progress-bar {
      outline: solid 1px SelectedItem;
      background-color: var(--sl-color-neutral-0);
    }

    .progress-bar__indicator {
      outline: solid 1px SelectedItem;
      background-color: SelectedItem;
    }
  }

  @keyframes indeterminate {
    0% {
      left: -50%;
      width: 50%;
    }
    75%,
    100% {
      left: 100%;
      width: 50%;
    }
  }

  @keyframes indeterminate-rtl {
    0% {
      right: -50%;
      width: 50%;
    }
    75%,
    100% {
      right: 100%;
      width: 50%;
    }
  }
`;
var i11 = "important";
var n16 = " !" + i11;
var o14 = e15(class extends i9 {
  constructor(t11) {
    var e17;
    if (super(t11), t11.type !== t92.ATTRIBUTE || "style" !== t11.name || (null === (e17 = t11.strings) || void 0 === e17 ? void 0 : e17.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t11) {
    return Object.keys(t11).reduce((e17, r112) => {
      const s9 = t11[r112];
      return null == s9 ? e17 : e17 + `${r112 = r112.includes("-") ? r112 : r112.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s9};`;
    }, "");
  }
  update(e17, [r112]) {
    const { style: s9 } = e17.element;
    if (void 0 === this.ht) {
      this.ht = /* @__PURE__ */ new Set();
      for (const t11 in r112) this.ht.add(t11);
      return this.render(r112);
    }
    this.ht.forEach((t11) => {
      null == r112[t11] && (this.ht.delete(t11), t11.includes("-") ? s9.removeProperty(t11) : s9[t11] = "");
    });
    for (const t11 in r112) {
      const e18 = r112[t11];
      if (null != e18) {
        this.ht.add(t11);
        const r12 = "string" == typeof e18 && e18.endsWith(n16);
        t11.includes("-") || r12 ? s9.setProperty(t11, r12 ? e18.slice(0, -11) : e18, r12 ? i11 : "") : s9[t11] = e18;
      }
    }
    return T32;
  }
});
var SlProgressBar = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController24(this);
    this.value = 0;
    this.indeterminate = false;
    this.label = "";
  }
  render() {
    return x42`
      <div
        part="base"
        class=${o12({
      "progress-bar": true,
      "progress-bar--indeterminate": this.indeterminate,
      "progress-bar--rtl": this.localize.dir() === "rtl"
    })}
        role="progressbar"
        title=${l9(this.title)}
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow=${this.indeterminate ? 0 : this.value}
      >
        <div part="indicator" class="progress-bar__indicator" style=${o14({ width: `${this.value}%` })}>
          ${!this.indeterminate ? x42` <slot part="label" class="progress-bar__label"></slot> ` : ""}
        </div>
      </div>
    `;
  }
};
SlProgressBar.styles = progress_bar_styles_default;
__decorateClass5([
  n13({ type: Number, reflect: true })
], SlProgressBar.prototype, "value", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlProgressBar.prototype, "indeterminate", 2);
__decorateClass5([
  n13()
], SlProgressBar.prototype, "label", 2);
var card_styles_default = i52`
  ${component_styles_default5}

  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;
var SlCard = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController5(this, "footer", "header", "image");
  }
  render() {
    return x42`
      <div
        part="base"
        class=${o12({
      card: true,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = card_styles_default;
var divider_styles_default = i52`
  ${component_styles_default5}

  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`;
var SlDivider = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
SlDivider.styles = divider_styles_default;
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlDivider.prototype, "vertical", 2);
__decorateClass5([
  watch5("vertical")
], SlDivider.prototype, "handleVerticalChange", 1);
var switch_styles_default = i52`
  ${component_styles_default5}

  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition: var(--sl-transition-fast) translate ease, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color, var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`;
var SlSwitch = class extends ShoelaceElement5 {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController5(this, {
      value: (control2) => control2.checked ? control2.value || "on" : void 0,
      defaultValue: (control2) => control2.defaultChecked,
      setValue: (control2, checked) => control2.checked = checked
    });
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleClick() {
    this.checked = !this.checked;
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleKeyDown(event) {
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.checked = false;
      this.emit("sl-change");
      this.emit("sl-input");
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.checked = true;
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleCheckedChange() {
    this.input.checked = this.checked;
    this.formControlController.updateValidity();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(true);
  }
  /** Simulates a click on the switch. */
  click() {
    this.input.click();
  }
  /** Sets focus on the switch. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the switch. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    return x42`
      <label
        part="base"
        class=${o12({
      switch: true,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus,
      "switch--small": this.size === "small",
      "switch--medium": this.size === "medium",
      "switch--large": this.size === "large"
    })}
      >
        <input
          class="switch__input"
          type="checkbox"
          title=${this.title}
          name=${this.name}
          value=${l9(this.value)}
          .checked=${l10(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          role="switch"
          aria-checked=${this.checked ? "true" : "false"}
          @click=${this.handleClick}
          @input=${this.handleInput}
          @invalid=${this.handleInvalid}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @keydown=${this.handleKeyDown}
        />

        <span part="control" class="switch__control">
          <span part="thumb" class="switch__thumb"></span>
        </span>

        <slot part="label" class="switch__label"></slot>
      </label>
    `;
  }
};
SlSwitch.styles = switch_styles_default;
__decorateClass5([
  i8('input[type="checkbox"]')
], SlSwitch.prototype, "input", 2);
__decorateClass5([
  t72()
], SlSwitch.prototype, "hasFocus", 2);
__decorateClass5([
  n13()
], SlSwitch.prototype, "title", 2);
__decorateClass5([
  n13()
], SlSwitch.prototype, "name", 2);
__decorateClass5([
  n13()
], SlSwitch.prototype, "value", 2);
__decorateClass5([
  n13({ reflect: true })
], SlSwitch.prototype, "size", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlSwitch.prototype, "disabled", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlSwitch.prototype, "checked", 2);
__decorateClass5([
  defaultValue3("checked")
], SlSwitch.prototype, "defaultChecked", 2);
__decorateClass5([
  n13({ reflect: true })
], SlSwitch.prototype, "form", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlSwitch.prototype, "required", 2);
__decorateClass5([
  watch5("checked", { waitUntilFirstUpdate: true })
], SlSwitch.prototype, "handleCheckedChange", 1);
__decorateClass5([
  watch5("disabled", { waitUntilFirstUpdate: true })
], SlSwitch.prototype, "handleDisabledChange", 1);
var visually_hidden_styles_default = i52`
  ${component_styles_default5}

  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`;
var SlVisuallyHidden = class extends ShoelaceElement5 {
  render() {
    return x42` <slot></slot> `;
  }
};
SlVisuallyHidden.styles = visually_hidden_styles_default;
function drag(container, options) {
  function move(pointerEvent) {
    const dims = container.getBoundingClientRect();
    const defaultView = container.ownerDocument.defaultView;
    const offsetX = dims.left + defaultView.pageXOffset;
    const offsetY = dims.top + defaultView.pageYOffset;
    const x52 = pointerEvent.pageX - offsetX;
    const y42 = pointerEvent.pageY - offsetY;
    if (options == null ? void 0 : options.onMove) {
      options.onMove(x52, y42);
    }
  }
  function stop() {
    document.removeEventListener("pointermove", move);
    document.removeEventListener("pointerup", stop);
    if (options == null ? void 0 : options.onStop) {
      options.onStop();
    }
  }
  document.addEventListener("pointermove", move, { passive: true });
  document.addEventListener("pointerup", stop);
  if ((options == null ? void 0 : options.initialEvent) instanceof PointerEvent) {
    move(options.initialEvent);
  }
}
var color_picker_styles_default = i52`
  ${component_styles_default5}

  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position: 0 0, 0 0, -5px -5px, 5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow: inset 0 0 0 2px var(--sl-input-border-color), inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
function clamp22(value, min22, max22) {
  const noNegativeZero = (n17) => Object.is(n17, -0) ? 0 : n17;
  if (value < min22) {
    return noNegativeZero(min22);
  }
  if (value > max22) {
    return noNegativeZero(max22);
  }
  return noNegativeZero(value);
}
function bound01(n17, max22) {
  if (isOnePointZero(n17)) {
    n17 = "100%";
  }
  var isPercent = isPercentage(n17);
  n17 = max22 === 360 ? n17 : Math.min(max22, Math.max(0, parseFloat(n17)));
  if (isPercent) {
    n17 = parseInt(String(n17 * max22), 10) / 100;
  }
  if (Math.abs(n17 - max22) < 1e-6) {
    return 1;
  }
  if (max22 === 360) {
    n17 = (n17 < 0 ? n17 % max22 + max22 : n17 % max22) / parseFloat(String(max22));
  } else {
    n17 = n17 % max22 / parseFloat(String(max22));
  }
  return n17;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n17) {
  return typeof n17 === "string" && n17.indexOf(".") !== -1 && parseFloat(n17) === 1;
}
function isPercentage(n17) {
  return typeof n17 === "string" && n17.indexOf("%") !== -1;
}
function boundAlpha(a72) {
  a72 = parseFloat(a72);
  if (isNaN(a72) || a72 < 0 || a72 > 1) {
    a72 = 1;
  }
  return a72;
}
function convertToPercentage(n17) {
  if (n17 <= 1) {
    return "".concat(Number(n17) * 100, "%");
  }
  return n17;
}
function pad2(c92) {
  return c92.length === 1 ? "0" + c92 : String(c92);
}
function rgbToRgb(r112, g42, b42) {
  return {
    r: bound01(r112, 255) * 255,
    g: bound01(g42, 255) * 255,
    b: bound01(b42, 255) * 255
  };
}
function rgbToHsl(r112, g42, b42) {
  r112 = bound01(r112, 255);
  g42 = bound01(g42, 255);
  b42 = bound01(b42, 255);
  var max22 = Math.max(r112, g42, b42);
  var min22 = Math.min(r112, g42, b42);
  var h92 = 0;
  var s9 = 0;
  var l11 = (max22 + min22) / 2;
  if (max22 === min22) {
    s9 = 0;
    h92 = 0;
  } else {
    var d52 = max22 - min22;
    s9 = l11 > 0.5 ? d52 / (2 - max22 - min22) : d52 / (max22 + min22);
    switch (max22) {
      case r112:
        h92 = (g42 - b42) / d52 + (g42 < b42 ? 6 : 0);
        break;
      case g42:
        h92 = (b42 - r112) / d52 + 2;
        break;
      case b42:
        h92 = (r112 - g42) / d52 + 4;
        break;
      default:
        break;
    }
    h92 /= 6;
  }
  return { h: h92, s: s9, l: l11 };
}
function hue2rgb(p42, q32, t11) {
  if (t11 < 0) {
    t11 += 1;
  }
  if (t11 > 1) {
    t11 -= 1;
  }
  if (t11 < 1 / 6) {
    return p42 + (q32 - p42) * (6 * t11);
  }
  if (t11 < 1 / 2) {
    return q32;
  }
  if (t11 < 2 / 3) {
    return p42 + (q32 - p42) * (2 / 3 - t11) * 6;
  }
  return p42;
}
function hslToRgb(h92, s9, l11) {
  var r112;
  var g42;
  var b42;
  h92 = bound01(h92, 360);
  s9 = bound01(s9, 100);
  l11 = bound01(l11, 100);
  if (s9 === 0) {
    g42 = l11;
    b42 = l11;
    r112 = l11;
  } else {
    var q32 = l11 < 0.5 ? l11 * (1 + s9) : l11 + s9 - l11 * s9;
    var p42 = 2 * l11 - q32;
    r112 = hue2rgb(p42, q32, h92 + 1 / 3);
    g42 = hue2rgb(p42, q32, h92);
    b42 = hue2rgb(p42, q32, h92 - 1 / 3);
  }
  return { r: r112 * 255, g: g42 * 255, b: b42 * 255 };
}
function rgbToHsv(r112, g42, b42) {
  r112 = bound01(r112, 255);
  g42 = bound01(g42, 255);
  b42 = bound01(b42, 255);
  var max22 = Math.max(r112, g42, b42);
  var min22 = Math.min(r112, g42, b42);
  var h92 = 0;
  var v42 = max22;
  var d52 = max22 - min22;
  var s9 = max22 === 0 ? 0 : d52 / max22;
  if (max22 === min22) {
    h92 = 0;
  } else {
    switch (max22) {
      case r112:
        h92 = (g42 - b42) / d52 + (g42 < b42 ? 6 : 0);
        break;
      case g42:
        h92 = (b42 - r112) / d52 + 2;
        break;
      case b42:
        h92 = (r112 - g42) / d52 + 4;
        break;
      default:
        break;
    }
    h92 /= 6;
  }
  return { h: h92, s: s9, v: v42 };
}
function hsvToRgb(h92, s9, v42) {
  h92 = bound01(h92, 360) * 6;
  s9 = bound01(s9, 100);
  v42 = bound01(v42, 100);
  var i12 = Math.floor(h92);
  var f82 = h92 - i12;
  var p42 = v42 * (1 - s9);
  var q32 = v42 * (1 - f82 * s9);
  var t11 = v42 * (1 - (1 - f82) * s9);
  var mod = i12 % 6;
  var r112 = [v42, q32, p42, p42, t11, v42][mod];
  var g42 = [t11, v42, v42, q32, p42, p42][mod];
  var b42 = [p42, p42, t11, v42, v42, q32][mod];
  return { r: r112 * 255, g: g42 * 255, b: b42 * 255 };
}
function rgbToHex(r112, g42, b42, allow3Char) {
  var hex = [
    pad2(Math.round(r112).toString(16)),
    pad2(Math.round(g42).toString(16)),
    pad2(Math.round(b42).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r112, g42, b42, a72, allow4Char) {
  var hex = [
    pad2(Math.round(r112).toString(16)),
    pad2(Math.round(g42).toString(16)),
    pad2(Math.round(b42).toString(16)),
    pad2(convertDecimalToHex(a72))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d52) {
  return Math.round(parseFloat(d52) * 255).toString(16);
}
function convertHexToDecimal(h92) {
  return parseIntFromHex(h92) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a72 = 1;
  var s9 = null;
  var v42 = null;
  var l11 = null;
  var ok = false;
  var format = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s9 = convertToPercentage(color.s);
      v42 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s9, v42);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s9 = convertToPercentage(color.s);
      l11 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s9, l11);
      ok = true;
      format = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a72 = color.a;
    }
  }
  a72 = boundAlpha(a72);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a72
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = (
  /** @class */
  function() {
    function TinyColor2(color, opts) {
      if (color === void 0) {
        color = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a42;
      if (color instanceof TinyColor2) {
        return color;
      }
      if (typeof color === "number") {
        color = numberInputToObject(color);
      }
      this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a42 = opts.format) !== null && _a42 !== void 0 ? _a42 : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R42;
      var G32;
      var B42;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R42 = RsRGB / 12.92;
      } else {
        R42 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G32 = GsRGB / 12.92;
      } else {
        G32 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B42 = BsRGB / 12.92;
      } else {
        B42 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R42 + 0.7152 * G32 + 0.0722 * B42;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.isMonochrome = function() {
      var s9 = this.toHsl().s;
      return s9 === 0;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h92 = Math.round(hsv.h * 360);
      var s9 = Math.round(hsv.s * 100);
      var v42 = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h92, ", ").concat(s9, "%, ").concat(v42, "%)") : "hsva(".concat(h92, ", ").concat(s9, "%, ").concat(v42, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h92 = Math.round(hsl.h * 360);
      var s9 = Math.round(hsl.s * 100);
      var l11 = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h92, ", ").concat(s9, "%, ").concat(l11, "%)") : "hsla(".concat(h92, ", ").concat(s9, "%, ").concat(l11, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      if (allowShortChar === void 0) {
        allowShortChar = false;
      }
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r112 = Math.round(this.r);
      var g42 = Math.round(this.g);
      var b42 = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r112, ", ").concat(g42, ", ").concat(b42, ")") : "rgba(".concat(r112, ", ").concat(g42, ", ").concat(b42, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x52) {
        return "".concat(Math.round(bound01(x52, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x52) {
        return Math.round(bound01(x52, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a42 = Object.entries(names); _i < _a42.length; _i++) {
        var _b = _a42[_i], key = _b[0], value = _b[1];
        if (hex === value) {
          return key;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format) {
      var formatSet = Boolean(format);
      format = format !== null && format !== void 0 ? format : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color).toRgb();
      var p42 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p42 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p42 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p42 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p42 + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h92 = hsv.h;
      var s9 = hsv.s;
      var v42 = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h: h92, s: s9, v: v42 }));
        v42 = (v42 + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h92 = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h92 + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h92 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      var alpha = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n17) {
      var hsl = this.toHsl();
      var h92 = hsl.h;
      var result = [this];
      var increment = 360 / n17;
      for (var i12 = 1; i12 < n17; i12++) {
        result.push(new TinyColor2({ h: (h92 + i12 * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color) {
      return this.toRgbString() === new TinyColor2(color).toRgbString();
    };
    return TinyColor2;
  }()
);
var hasEyeDropper = "EyeDropper" in window;
var SlColorPicker = class extends ShoelaceElement5 {
  constructor() {
    super();
    this.formControlController = new FormControlController5(this);
    this.isSafeValue = false;
    this.localize = new LocalizeController24(this);
    this.hasFocus = false;
    this.isDraggingGridHandle = false;
    this.isEmpty = false;
    this.inputValue = "";
    this.hue = 0;
    this.saturation = 100;
    this.brightness = 100;
    this.alpha = 100;
    this.value = "";
    this.defaultValue = "";
    this.label = "";
    this.format = "hex";
    this.inline = false;
    this.size = "medium";
    this.noFormatToggle = false;
    this.name = "";
    this.disabled = false;
    this.hoist = false;
    this.opacity = false;
    this.uppercase = false;
    this.swatches = "";
    this.form = "";
    this.required = false;
    this.handleFocusIn = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.handleFocusOut = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.input.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  handleCopy() {
    this.input.select();
    document.execCommand("copy");
    this.previewButton.focus();
    this.previewButton.classList.add("color-picker__preview-color--copied");
    this.previewButton.addEventListener("animationend", () => {
      this.previewButton.classList.remove("color-picker__preview-color--copied");
    });
  }
  handleFormatToggle() {
    const formats = ["hex", "rgb", "hsl", "hsv"];
    const nextIndex = (formats.indexOf(this.format) + 1) % formats.length;
    this.format = formats[nextIndex];
    this.setColor(this.value);
    this.emit("sl-change");
    this.emit("sl-input");
  }
  handleAlphaDrag(event) {
    const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha");
    const handle = container.querySelector(".color-picker__slider-handle");
    const { width } = container.getBoundingClientRect();
    let oldValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: (x52) => {
        this.alpha = clamp22(x52 / width * 100, 0, 100);
        this.syncValues();
        if (this.value !== oldValue) {
          oldValue = this.value;
          this.emit("sl-change");
          this.emit("sl-input");
        }
      },
      initialEvent: event
    });
  }
  handleHueDrag(event) {
    const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue");
    const handle = container.querySelector(".color-picker__slider-handle");
    const { width } = container.getBoundingClientRect();
    let oldValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: (x52) => {
        this.hue = clamp22(x52 / width * 360, 0, 360);
        this.syncValues();
        if (this.value !== oldValue) {
          oldValue = this.value;
          this.emit("sl-change");
          this.emit("sl-input");
        }
      },
      initialEvent: event
    });
  }
  handleGridDrag(event) {
    const grid = this.shadowRoot.querySelector(".color-picker__grid");
    const handle = grid.querySelector(".color-picker__grid-handle");
    const { width, height } = grid.getBoundingClientRect();
    let oldValue = this.value;
    handle.focus();
    event.preventDefault();
    this.isDraggingGridHandle = true;
    drag(grid, {
      onMove: (x52, y42) => {
        this.saturation = clamp22(x52 / width * 100, 0, 100);
        this.brightness = clamp22(100 - y42 / height * 100, 0, 100);
        this.syncValues();
        if (this.value !== oldValue) {
          oldValue = this.value;
          this.emit("sl-change");
          this.emit("sl-input");
        }
      },
      onStop: () => this.isDraggingGridHandle = false,
      initialEvent: event
    });
  }
  handleAlphaKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.alpha = clamp22(this.alpha - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.alpha = clamp22(this.alpha + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.alpha = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.alpha = 100;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleHueKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.hue = clamp22(this.hue - increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.hue = clamp22(this.hue + increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.hue = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.hue = 360;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleGridKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.saturation = clamp22(this.saturation - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.saturation = clamp22(this.saturation + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this.brightness = clamp22(this.brightness + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      this.brightness = clamp22(this.brightness - increment, 0, 100);
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputChange(event) {
    const target = event.target;
    const oldValue = this.value;
    event.stopPropagation();
    if (this.input.value) {
      this.setColor(target.value);
      target.value = this.value;
    } else {
      this.value = "";
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputInput(event) {
    this.formControlController.updateValidity();
    event.stopPropagation();
  }
  handleInputKeyDown(event) {
    if (event.key === "Enter") {
      const oldValue = this.value;
      if (this.input.value) {
        this.setColor(this.input.value);
        this.input.value = this.value;
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
        setTimeout(() => this.input.select());
      } else {
        this.hue = 0;
      }
    }
  }
  handleInputInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleTouchMove(event) {
    event.preventDefault();
  }
  parseColor(colorString) {
    const color = new TinyColor(colorString);
    if (!color.isValid) {
      return null;
    }
    const hslColor = color.toHsl();
    const hsl = {
      h: hslColor.h,
      s: hslColor.s * 100,
      l: hslColor.l * 100,
      a: hslColor.a
    };
    const rgb = color.toRgb();
    const hex = color.toHexString();
    const hexa = color.toHex8String();
    const hsvColor = color.toHsv();
    const hsv = {
      h: hsvColor.h,
      s: hsvColor.s * 100,
      v: hsvColor.v * 100,
      a: hsvColor.a
    };
    return {
      hsl: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        string: this.setLetterCase(`hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`)
      },
      hsla: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        string: this.setLetterCase(
          `hsla(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%, ${hsl.a.toFixed(2).toString()})`
        )
      },
      hsv: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        string: this.setLetterCase(`hsv(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%)`)
      },
      hsva: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        a: hsv.a,
        string: this.setLetterCase(
          `hsva(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%, ${hsv.a.toFixed(2).toString()})`
        )
      },
      rgb: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        string: this.setLetterCase(`rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`)
      },
      rgba: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        a: rgb.a,
        string: this.setLetterCase(
          `rgba(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)}, ${rgb.a.toFixed(2).toString()})`
        )
      },
      hex: this.setLetterCase(hex),
      hexa: this.setLetterCase(hexa)
    };
  }
  setColor(colorString) {
    const newColor = this.parseColor(colorString);
    if (newColor === null) {
      return false;
    }
    this.hue = newColor.hsva.h;
    this.saturation = newColor.hsva.s;
    this.brightness = newColor.hsva.v;
    this.alpha = this.opacity ? newColor.hsva.a * 100 : 100;
    this.syncValues();
    return true;
  }
  setLetterCase(string) {
    if (typeof string !== "string") {
      return "";
    }
    return this.uppercase ? string.toUpperCase() : string.toLowerCase();
  }
  async syncValues() {
    const currentColor = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    if (currentColor === null) {
      return;
    }
    if (this.format === "hsl") {
      this.inputValue = this.opacity ? currentColor.hsla.string : currentColor.hsl.string;
    } else if (this.format === "rgb") {
      this.inputValue = this.opacity ? currentColor.rgba.string : currentColor.rgb.string;
    } else if (this.format === "hsv") {
      this.inputValue = this.opacity ? currentColor.hsva.string : currentColor.hsv.string;
    } else {
      this.inputValue = this.opacity ? currentColor.hexa : currentColor.hex;
    }
    this.isSafeValue = true;
    this.value = this.inputValue;
    await this.updateComplete;
    this.isSafeValue = false;
  }
  handleAfterHide() {
    this.previewButton.classList.remove("color-picker__preview-color--copied");
  }
  handleEyeDropper() {
    if (!hasEyeDropper) {
      return;
    }
    const eyeDropper = new EyeDropper();
    eyeDropper.open().then((colorSelectionResult) => {
      const oldValue = this.value;
      this.setColor(colorSelectionResult.sRGBHex);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }).catch(() => {
    });
  }
  selectSwatch(color) {
    const oldValue = this.value;
    if (!this.disabled) {
      this.setColor(color);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
  }
  /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
  getHexString(hue, saturation, brightness, alpha = 100) {
    const color = new TinyColor(`hsva(${hue}, ${saturation}, ${brightness}, ${alpha / 100})`);
    if (!color.isValid) {
      return "";
    }
    return color.toHex8String();
  }
  // Prevents nested components from leaking events
  stopNestedEventPropagation(event) {
    event.stopImmediatePropagation();
  }
  handleFormatChange() {
    this.syncValues();
  }
  handleOpacityChange() {
    this.alpha = 100;
  }
  handleValueChange(oldValue, newValue) {
    this.isEmpty = !newValue;
    if (!newValue) {
      this.hue = 0;
      this.saturation = 0;
      this.brightness = 100;
      this.alpha = 100;
    }
    if (!this.isSafeValue) {
      const newColor = this.parseColor(newValue);
      if (newColor !== null) {
        this.inputValue = this.value;
        this.hue = newColor.hsva.h;
        this.saturation = newColor.hsva.s;
        this.brightness = newColor.hsva.v;
        this.alpha = newColor.hsva.a * 100;
        this.syncValues();
      } else {
        this.inputValue = oldValue != null ? oldValue : "";
      }
    }
  }
  /** Sets focus on the color picker. */
  focus(options) {
    if (this.inline) {
      this.base.focus(options);
    } else {
      this.trigger.focus(options);
    }
  }
  /** Removes focus from the color picker. */
  blur() {
    var _a42;
    const elementToBlur = this.inline ? this.base : this.trigger;
    if (this.hasFocus) {
      elementToBlur.focus({ preventScroll: true });
      elementToBlur.blur();
    }
    if ((_a42 = this.dropdown) == null ? void 0 : _a42.open) {
      this.dropdown.hide();
    }
  }
  /** Returns the current value as a string in the specified format. */
  getFormattedValue(format = "hex") {
    const currentColor = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    if (currentColor === null) {
      return "";
    }
    switch (format) {
      case "hex":
        return currentColor.hex;
      case "hexa":
        return currentColor.hexa;
      case "rgb":
        return currentColor.rgb.string;
      case "rgba":
        return currentColor.rgba.string;
      case "hsl":
        return currentColor.hsl.string;
      case "hsla":
        return currentColor.hsla.string;
      case "hsv":
        return currentColor.hsv.string;
      case "hsva":
        return currentColor.hsva.string;
      default:
        return "";
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (!this.inline && !this.validity.valid) {
      this.dropdown.show();
      this.addEventListener("sl-after-show", () => this.input.reportValidity(), { once: true });
      if (!this.disabled) {
        this.formControlController.emitInvalidEvent();
      }
      return false;
    }
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const gridHandleX = this.saturation;
    const gridHandleY = 100 - this.brightness;
    const swatches = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter((color) => color.trim() !== "");
    const colorPicker = x42`
      <div
        part="base"
        class=${o12({
      "color-picker": true,
      "color-picker--inline": this.inline,
      "color-picker--disabled": this.disabled,
      "color-picker--focused": this.hasFocus
    })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? x42`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${o14({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${o12({
      "color-picker__grid-handle": true,
      "color-picker__grid-handle--dragging": this.isDraggingGridHandle
    })}
            style=${o14({
      top: `${gridHandleY}%`,
      left: `${gridHandleX}%`,
      backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            role="application"
            aria-label="HSV"
            tabindex=${l9(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${o14({
      left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
    })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${l9(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? x42`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${o14({
      backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
    })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${o14({
      left: `${this.alpha}%`
    })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${l9(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${o14({
      "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${!this.noFormatToggle ? x42`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                ` : ""}
            ${hasEyeDropper ? x42`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${swatches.length > 0 ? x42`
              <div part="swatches" class="color-picker__swatches">
                ${swatches.map((swatch) => {
      const parsedColor = this.parseColor(swatch);
      if (!parsedColor) {
        console.error(`Unable to parse swatch color: "${swatch}"`, this);
        return "";
      }
      return x42`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${l9(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${swatch}
                      @click=${() => this.selectSwatch(swatch)}
                      @keydown=${(event) => !this.disabled && event.key === "Enter" && this.setColor(parsedColor.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${o14({ backgroundColor: parsedColor.hexa })}
                      ></div>
                    </div>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
    if (this.inline) {
      return colorPicker;
    }
    return x42`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containing-element=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${o12({
      "color-dropdown__trigger": true,
      "color-dropdown__trigger--disabled": this.disabled,
      "color-dropdown__trigger--small": this.size === "small",
      "color-dropdown__trigger--medium": this.size === "medium",
      "color-dropdown__trigger--large": this.size === "large",
      "color-dropdown__trigger--empty": this.isEmpty,
      "color-dropdown__trigger--focused": this.hasFocus,
      "color-picker__transparent-bg": true
    })}
          style=${o14({
      color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${colorPicker}
      </sl-dropdown>
    `;
  }
};
SlColorPicker.styles = color_picker_styles_default;
SlColorPicker.dependencies = {
  "sl-button-group": SlButtonGroup4,
  "sl-button": SlButton4,
  "sl-dropdown": SlDropdown2,
  "sl-icon": SlIcon5,
  "sl-input": SlInput,
  "sl-visually-hidden": SlVisuallyHidden
};
__decorateClass5([
  i8('[part~="base"]')
], SlColorPicker.prototype, "base", 2);
__decorateClass5([
  i8('[part~="input"]')
], SlColorPicker.prototype, "input", 2);
__decorateClass5([
  i8(".color-dropdown")
], SlColorPicker.prototype, "dropdown", 2);
__decorateClass5([
  i8('[part~="preview"]')
], SlColorPicker.prototype, "previewButton", 2);
__decorateClass5([
  i8('[part~="trigger"]')
], SlColorPicker.prototype, "trigger", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "hasFocus", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "isDraggingGridHandle", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "isEmpty", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "inputValue", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "hue", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "saturation", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "brightness", 2);
__decorateClass5([
  t72()
], SlColorPicker.prototype, "alpha", 2);
__decorateClass5([
  n13()
], SlColorPicker.prototype, "value", 2);
__decorateClass5([
  defaultValue3()
], SlColorPicker.prototype, "defaultValue", 2);
__decorateClass5([
  n13()
], SlColorPicker.prototype, "label", 2);
__decorateClass5([
  n13()
], SlColorPicker.prototype, "format", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlColorPicker.prototype, "inline", 2);
__decorateClass5([
  n13({ reflect: true })
], SlColorPicker.prototype, "size", 2);
__decorateClass5([
  n13({ attribute: "no-format-toggle", type: Boolean })
], SlColorPicker.prototype, "noFormatToggle", 2);
__decorateClass5([
  n13()
], SlColorPicker.prototype, "name", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlColorPicker.prototype, "disabled", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlColorPicker.prototype, "hoist", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlColorPicker.prototype, "opacity", 2);
__decorateClass5([
  n13({ type: Boolean })
], SlColorPicker.prototype, "uppercase", 2);
__decorateClass5([
  n13()
], SlColorPicker.prototype, "swatches", 2);
__decorateClass5([
  n13({ reflect: true })
], SlColorPicker.prototype, "form", 2);
__decorateClass5([
  n13({ type: Boolean, reflect: true })
], SlColorPicker.prototype, "required", 2);
__decorateClass5([
  watch5("format", { waitUntilFirstUpdate: true })
], SlColorPicker.prototype, "handleFormatChange", 1);
__decorateClass5([
  watch5("opacity", { waitUntilFirstUpdate: true })
], SlColorPicker.prototype, "handleOpacityChange", 1);
__decorateClass5([
  watch5("value")
], SlColorPicker.prototype, "handleValueChange", 1);
var L4 = __toESM(require_leaflet());
var isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
var removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n17 = start.nextSibling;
    container.removeChild(start);
    start = n17;
  }
};
var marker = `{{lit-${String(Math.random()).slice(2)}}}`;
var nodeMarker = `<!--${marker}-->`;
var markerRegex = new RegExp(`${marker}|${nodeMarker}`);
var boundAttributeSuffix = "$lit$";
var Template = class {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element.content, 133, null, false);
    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const { strings, values: { length } } = result;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const { length: length2 } = attributes;
          let count = 0;
          for (let i12 = 0; i12 < length2; i12++) {
            if (endsWith(attributes[i12].name, boundAttributeSuffix)) {
              count++;
            }
          }
          while (count-- > 0) {
            const stringForPart = strings[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({ type: "attribute", index, name, strings: statics });
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings2 = data.split(markerRegex);
          const lastIndex = strings2.length - 1;
          for (let i12 = 0; i12 < lastIndex; i12++) {
            let insert;
            let s9 = strings2[i12];
            if (s9 === "") {
              insert = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s9);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s9 = s9.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert = document.createTextNode(s9);
            }
            parent.insertBefore(insert, node);
            this.parts.push({ type: "node", index: ++index });
          }
          if (strings2[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings2[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index === lastPartIndex) {
            index++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index;
          this.parts.push({ type: "node", index });
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index--;
          }
          partIndex++;
        } else {
          let i12 = -1;
          while ((i12 = node.data.indexOf(marker, i12 + 1)) !== -1) {
            this.parts.push({ type: "node", index: -1 });
            partIndex++;
          }
        }
      }
    }
    for (const n17 of nodesToRemove) {
      n17.parentNode.removeChild(n17);
    }
  }
};
var endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};
var isTemplatePartActive = (part) => part.index !== -1;
var createMarker = () => document.createComment("");
var lastAttributeNameRegex = (
  // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/
);
var walkerNodeFilter = 133;
function removeNodesFromTemplate(template, nodesToRemove) {
  const { element: { content }, parts: parts2 } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let part = parts2[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;
  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode;
    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    }
    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node);
      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    }
    if (currentRemovingNode !== null) {
      removeCount++;
    }
    while (part !== void 0 && part.index === nodeIndex) {
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
      part = parts2[partIndex];
    }
  }
  nodesToRemoveInTemplate.forEach((n17) => n17.parentNode.removeChild(n17));
}
var countNodes = (node) => {
  let count = node.nodeType === 11 ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
  while (walker.nextNode()) {
    count++;
  }
  return count;
};
var nextActiveIndexInTemplateParts = (parts2, startIndex = -1) => {
  for (let i12 = startIndex + 1; i12 < parts2.length; i12++) {
    const part = parts2[i12];
    if (isTemplatePartActive(part)) {
      return i12;
    }
  }
  return -1;
};
function insertNodeIntoTemplate(template, node, refNode = null) {
  const { element: { content }, parts: parts2 } = template;
  if (refNode === null || refNode === void 0) {
    content.appendChild(node);
    return;
  }
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let insertCount = 0;
  let walkerIndex = -1;
  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;
    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }
    while (partIndex !== -1 && parts2[partIndex].index === walkerIndex) {
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts2[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
        }
        return;
      }
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
    }
  }
}
var directives = /* @__PURE__ */ new WeakMap();
var isDirective = (o15) => {
  return typeof o15 === "function" && directives.has(o15);
};
var noChange = {};
var nothing = {};
var TemplateInstance = class {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }
  update(values) {
    let i12 = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i12]);
      }
      i12++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
};
var policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (s9) => s9 });
var commentMarker = ` ${marker} `;
var TemplateResult = class {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  /**
   * Returns a string of HTML used to create a `<template>` element.
   */
  getHTML() {
    const l11 = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i12 = 0; i12 < l11; i12++) {
      const s9 = this.strings[i12];
      const commentOpen = s9.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s9.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s9);
      if (attributeMatch === null) {
        html2 += s9 + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s9.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l11];
    return html2;
  }
  getTemplateElement() {
    const template = document.createElement("template");
    let value = this.getHTML();
    if (policy !== void 0) {
      value = policy.createHTML(value);
    }
    template.innerHTML = value;
    return template;
  }
};
var isPrimitive = (value) => {
  return value === null || !(typeof value === "object" || typeof value === "function");
};
var isIterable = (value) => {
  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  !!(value && value[Symbol.iterator]);
};
var AttributeCommitter = class {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];
    for (let i12 = 0; i12 < strings.length - 1; i12++) {
      this.parts[i12] = this._createPart();
    }
  }
  /**
   * Creates a single part. Override this to create a differnt type of part.
   */
  _createPart() {
    return new AttributePart(this);
  }
  _getValue() {
    const strings = this.strings;
    const l11 = strings.length - 1;
    const parts2 = this.parts;
    if (l11 === 1 && strings[0] === "" && strings[1] === "") {
      const v42 = parts2[0].value;
      if (typeof v42 === "symbol") {
        return String(v42);
      }
      if (typeof v42 === "string" || !isIterable(v42)) {
        return v42;
      }
    }
    let text = "";
    for (let i12 = 0; i12 < l11; i12++) {
      text += strings[i12];
      const part = parts2[i12];
      if (part !== void 0) {
        const v42 = part.value;
        if (isPrimitive(v42) || !isIterable(v42)) {
          text += typeof v42 === "string" ? v42 : String(v42);
        } else {
          for (const t11 of v42) {
            text += typeof t11 === "string" ? t11 : String(t11);
          }
        }
      }
    }
    text += strings[l11];
    return text;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
};
var AttributePart = class {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value;
      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective(this.value)) {
      const directive2 = this.value;
      this.value = noChange;
      directive2(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
};
var NodePart = class _NodePart {
  constructor(options) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options;
  }
  /**
   * Appends this part into a container.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  /**
   * Inserts this part after the `ref` node (between `ref` and `ref`'s next
   * sibling). Both `ref` and its next sibling must be static, unchanging nodes
   * such as those that appear in a literal section of a template.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  /**
   * Appends this part into a parent part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  /**
   * Inserts this part after the `ref` part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */
  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());
    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    const value = this.__pendingValue;
    if (value === noChange) {
      return;
    }
    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value) {
    if (this.value === value) {
      return;
    }
    this.clear();
    this.__insert(value);
    this.value = value;
  }
  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? "" : value;
    const valueAsString = typeof value === "string" ? value : String(value);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value;
  }
  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);
    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      const instance = new TemplateInstance(template, value.processor, this.options);
      const fragment = instance._clone();
      instance.update(value.values);
      this.__commitNode(fragment);
      this.value = instance;
    }
  }
  __commitIterable(value) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new _NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
};
var BooleanAttributePart = class {
  constructor(element, name, strings) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings.length !== 2 || strings[0] !== "" || strings[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element;
    this.name = name;
    this.strings = strings;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value = !!this.__pendingValue;
    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value;
    }
    this.__pendingValue = noChange;
  }
};
var PropertyCommitter = class extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === "" && strings[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
};
var PropertyPart = class extends AttributePart {
};
var eventOptionsSupported = false;
(() => {
  try {
    const options = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (_e) {
  }
})();
var EventPart = class {
  constructor(element, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e17) => this.handleEvent(e17);
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }
};
var getOptions = (o15) => o15 && (eventOptionsSupported ? { capture: o15.capture, passive: o15.passive, once: o15.once } : o15.capture);
function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(result.type, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    template = new Template(result, result.getTemplateElement());
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
}
var templateCaches = /* @__PURE__ */ new Map();
var parts = /* @__PURE__ */ new WeakMap();
var render = (result, container, options) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
    part.appendInto(container);
  }
  part.setValue(result);
  part.commit();
};
var DefaultTemplateProcessor = class {
  /**
   * Create parts for an attribute-position binding, given the event, attribute
   * name, and string literals.
   *
   * @param element The element containing the binding
   * @param name  The attribute name
   * @param strings The string literals. There are always at least two strings,
   *   event for fully-controlled bindings with a single expression.
   */
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element, name.slice(1), strings);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart(element, name.slice(1), options.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart(element, name.slice(1), strings)];
    }
    const committer = new AttributeCommitter(element, name, strings);
    return committer.parts;
  }
  /**
   * Create parts for a text-position binding.
   * @param templateFactory
   */
  handleTextExpression(options) {
    return new NodePart(options);
  }
};
var defaultTemplateProcessor = new DefaultTemplateProcessor();
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
var html = (strings, ...values) => new TemplateResult(strings, values, "html", defaultTemplateProcessor);
var getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
var compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === "undefined") {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
  console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
var shadyTemplateFactory = (scopeName) => (result) => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    const element = result.getTemplateElement();
    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }
    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
};
var TEMPLATE_TYPES = ["html", "svg"];
var removeStylesFromLitTemplates = (scopeName) => {
  TEMPLATE_TYPES.forEach((type) => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
    if (templates !== void 0) {
      templates.keyString.forEach((template) => {
        const { element: { content } } = template;
        const styles = /* @__PURE__ */ new Set();
        Array.from(content.querySelectorAll("style")).forEach((s9) => {
          styles.add(s9);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};
var shadyRenderSet = /* @__PURE__ */ new Set();
var prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName);
  const templateElement = !!template ? template.element : document.createElement("template");
  const styles = renderedDOM.querySelectorAll("style");
  const { length } = styles;
  if (length === 0) {
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }
  const condensedStyle = document.createElement("style");
  for (let i12 = 0; i12 < length; i12++) {
    const style3 = styles[i12];
    style3.parentNode.removeChild(style3);
    condensedStyle.textContent += style3.textContent;
  }
  removeStylesFromLitTemplates(scopeName);
  const content = templateElement.content;
  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  }
  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style2 = content.querySelector("style");
  if (window.ShadyCSS.nativeShadow && style2 !== null) {
    renderedDOM.insertBefore(style2.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = /* @__PURE__ */ new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
var render2 = (result, container, options) => {
  if (!options || typeof options !== "object" || !options.scopeName) {
    throw new Error("The `scopeName` option is required.");
  }
  const scopeName = options.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);
    const template = part.value instanceof TemplateInstance ? part.value.template : void 0;
    prepareTemplateStyles(scopeName, renderContainer, template);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  }
  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};
var _a26;
window.JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? "" : null;
      case Object:
      case Array:
        return value == null ? value : JSON.stringify(value);
    }
    return value;
  },
  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;
      case Number:
        return value === null ? null : Number(value);
      case Object:
      case Array:
        return JSON.parse(value);
    }
    return value;
  }
};
var notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var STATE_HAS_UPDATED = 1;
var STATE_UPDATE_REQUESTED = 1 << 2;
var STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
var STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
var finalized = "finalized";
var UpdatingElement = class extends HTMLElement {
  constructor() {
    super();
    this.initialize();
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   */
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this._classProperties.forEach((v42, p42) => {
      const attr = this._attributeNameForProperty(p42, v42);
      if (attr !== void 0) {
        this._attributeToPropertyMap.set(attr, p42);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  /**
   * Ensures the private `_classProperties` property metadata is created.
   * In addition to `finalize` this is also called in `createProperty` to
   * ensure the `@property` decorator can add property metadata.
   */
  /** @nocollapse */
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const superProperties = Object.getPrototypeOf(this)._classProperties;
      if (superProperties !== void 0) {
        superProperties.forEach((v42, k42) => this._classProperties.set(k42, v42));
      }
    }
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a PropertyDeclaration for the property with the given options.
   * The property setter calls the property's `hasChanged` property option
   * or uses a strict identity check to determine whether or not to request
   * an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   *
   * @nocollapse
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    this._ensureClassProperties();
    this._classProperties.set(name, options);
    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }
    const key = typeof name === "symbol" ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options);
    if (descriptor !== void 0) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   *   class MyElement extends LitElement {
   *     static getPropertyDescriptor(name, key, options) {
   *       const defaultDescriptor =
   *           super.getPropertyDescriptor(name, key, options);
   *       const setter = defaultDescriptor.set;
   *       return {
   *         get: defaultDescriptor.get,
   *         set(value) {
   *           setter.call(this, value);
   *           // custom action.
   *         },
   *         configurable: true,
   *         enumerable: true
   *       }
   *     }
   *   }
   *
   * @nocollapse
   */
  static getPropertyDescriptor(name, key, options) {
    return {
      // tslint:disable-next-line:no-any no symbol in index
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdateInternal(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a PropertyDeclaration via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override `createProperty`.
   *
   * @nocollapse
   * @final
   */
  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  /**
   * Creates property accessors for registered properties and ensures
   * any superclasses are also finalized.
   * @nocollapse
   */
  static finalize() {
    const superCtor = Object.getPrototypeOf(this);
    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }
    this[finalized] = true;
    this._ensureClassProperties();
    this._attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
      ];
      for (const p42 of propKeys) {
        this.createProperty(p42, props[p42]);
      }
    }
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  /**
   * Returns true if a property should request an update.
   * Called when a property value is set and uses the `hasChanged`
   * option for the property if present or a strict identity check.
   * @nocollapse
   */
  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  /**
   * Returns the property value for the given attribute value.
   * Called via the `attributeChangedCallback` and uses the property's
   * `converter` or `converter.fromAttribute` property option.
   * @nocollapse
   */
  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  /**
   * Returns the attribute value for the given property value. If this
   * returns undefined, the property will *not* be reflected to an attribute.
   * If this returns null, the attribute will be removed, otherwise the
   * attribute will be set to the value.
   * This uses the property's `reflect` and `type.toAttribute` property options.
   * @nocollapse
   */
  static _propertyValueToAttribute(value, options) {
    if (options.reflect === void 0) {
      return;
    }
    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  /**
   * Performs element initialization. By default captures any pre-set values for
   * registered properties.
   */
  initialize() {
    this._updateState = 0;
    this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
    this._changedProperties = /* @__PURE__ */ new Map();
    this._saveInstanceProperties();
    this.requestUpdateInternal();
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((_v, p42) => {
      if (this.hasOwnProperty(p42)) {
        const value = this[p42];
        delete this[p42];
        if (!this._instanceProperties) {
          this._instanceProperties = /* @__PURE__ */ new Map();
        }
        this._instanceProperties.set(p42, value);
      }
    });
  }
  /**
   * Applies previously saved instance properties.
   */
  _applyInstanceProperties() {
    this._instanceProperties.forEach((v42, p42) => this[p42] = v42);
    this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    if (this._enableUpdatingResolver !== void 0) {
      this._enableUpdatingResolver();
      this._enableUpdatingResolver = void 0;
    }
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   */
  disconnectedCallback() {
  }
  /**
   * Synchronizes property values when attributes change.
   */
  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }
  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;
    const attr = ctor._attributeNameForProperty(name, options);
    if (attr !== void 0) {
      const attrValue = ctor._propertyValueToAttribute(value, options);
      if (attrValue === void 0) {
        return;
      }
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }
  _attributeToProperty(name, value) {
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }
    const ctor = this.constructor;
    const propName = ctor._attributeToPropertyMap.get(name);
    if (propName !== void 0) {
      const options = ctor.getPropertyOptions(propName);
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = // tslint:disable-next-line:no-any
      ctor._propertyValueFromAttribute(value, options);
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  /**
   * This protected version of `requestUpdate` does not access or return the
   * `updateComplete` promise. This promise can be overridden and is therefore
   * not free to access.
   */
  requestUpdateInternal(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      const ctor = this.constructor;
      options = options || ctor.getPropertyOptions(name);
      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === void 0) {
            this._reflectingProperties = /* @__PURE__ */ new Map();
          }
          this._reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should
   * be called when an element should update based on some state not triggered
   * by setting a property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored. Returns the `updateComplete` Promise which is resolved
   * when the update completes.
   *
   * @param name {PropertyKey} (optional) name of requesting property
   * @param oldValue {any} (optional) old value of requesting property
   * @returns {Promise} A Promise that is resolved when the update completes.
   */
  requestUpdate(name, oldValue) {
    this.requestUpdateInternal(name, oldValue);
    return this.updateComplete;
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    try {
      await this._updatePromise;
    } catch (e17) {
    }
    const result = this.performUpdate();
    if (result != null) {
      await result;
    }
    return !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }
  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * You can override this method to change the timing of updates. If this
   * method is overridden, `super.performUpdate()` must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```
   * protected async performUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.performUpdate();
   * }
   * ```
   */
  performUpdate() {
    if (!this._hasRequestedUpdate) {
      return;
    }
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }
    let shouldUpdate = false;
    const changedProperties = this._changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e17) {
      shouldUpdate = false;
      this._markUpdated();
      throw e17;
    }
    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `_getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super._getUpdateComplete()`, then any subsequent state.
   *
   * @returns {Promise} The Promise returns a boolean that indicates if the
   * update resolved without triggering another update.
   */
  get updateComplete() {
    return this._getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async _getUpdateComplete() {
   *       await super._getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   * @deprecated Override `getUpdateComplete()` instead for forward
   *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.
   */
  _getUpdateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async getUpdateComplete() {
   *       await super.getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   */
  getUpdateComplete() {
    return this._updatePromise;
  }
  /**
   * Controls whether or not `update` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  update(_changedProperties) {
    if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
      this._reflectingProperties.forEach((v42, k42) => this._propertyToAttribute(k42, this[k42], v42));
      this._reflectingProperties = void 0;
    }
    this._markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */
  firstUpdated(_changedProperties) {
  }
};
_a26 = finalized;
UpdatingElement[_a26] = true;
var ElementProto = Element.prototype;
var legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
var supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var CSSResult = class {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  // Note, this is a getter so that it's lazy. In practice, this means
  // stylesheets are not created until the first element instance is made.
  get styleSheet() {
    if (this._styleSheet === void 0) {
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();
        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var unsafeCSS = (value) => {
  return new CSSResult(String(value), constructionToken);
};
var textFromCSSResult = (value) => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
var css = (strings, ...values) => {
  const cssText = values.reduce((acc, v42, idx) => acc + textFromCSSResult(v42) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};
(window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.5.1");
var renderNotImplemented = {};
var LitElement = class extends UpdatingElement {
  /**
   * Return the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * @nocollapse
   */
  static getStyles() {
    return this.styles;
  }
  /** @nocollapse */
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
      return;
    }
    const userStyles = this.getStyles();
    if (Array.isArray(userStyles)) {
      const addStyles = (styles2, set2) => styles2.reduceRight((set3, s9) => (
        // Note: On IE set.add() does not return the set
        Array.isArray(s9) ? addStyles(s9, set3) : (set3.add(s9), set3)
      ), set2);
      const set = addStyles(userStyles, /* @__PURE__ */ new Set());
      const styles = [];
      set.forEach((v42) => styles.unshift(v42));
      this._styles = styles;
    } else {
      this._styles = userStyles === void 0 ? [] : [userStyles];
    }
    this._styles = this._styles.map((s9) => {
      if (s9 instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
        const cssText = Array.prototype.slice.call(s9.cssRules).reduce((css2, rule) => css2 + rule.cssText, "");
        return unsafeCSS(cssText);
      }
      return s9;
    });
  }
  /**
   * Performs element initialization. By default this calls
   * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
   * captures any pre-set values for registered properties.
   */
  initialize() {
    super.initialize();
    this.constructor._getUniqueStyles();
    this.renderRoot = this.createRenderRoot();
    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   * @returns {Element|DocumentFragment} Returns a node into which to render.
   */
  createRenderRoot() {
    return this.attachShadow(this.constructor.shadowRootOptions);
  }
  /**
   * Applies styling to the element shadowRoot using the [[`styles`]]
   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
   * available and will fallback otherwise. When Shadow DOM is polyfilled,
   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
   * is available but `adoptedStyleSheets` is not, styles are appended to the
   * end of the `shadowRoot` to [mimic spec
   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
   */
  adoptStyles() {
    const styles = this.constructor._styles;
    if (styles.length === 0) {
      return;
    }
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s9) => s9.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map((s9) => s9 instanceof CSSStyleSheet ? s9 : s9.styleSheet);
    } else {
      this._needsShimAdoptedStyleSheets = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hasUpdated && window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param _changedProperties Map of changed properties with old values
   */
  update(changedProperties) {
    const templateResult = this.render();
    super.update(changedProperties);
    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
    }
    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;
      this.constructor._styles.forEach((s9) => {
        const style2 = document.createElement("style");
        style2.textContent = s9.cssText;
        this.renderRoot.appendChild(style2);
      });
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `NodePart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   */
  render() {
    return renderNotImplemented;
  }
};
LitElement["finalized"] = true;
LitElement.render = render2;
LitElement.shadowRootOptions = { mode: "open" };
var FaIcon = class extends LitElement {
  static get properties() {
    return {
      color: String,
      iClass: { attribute: "class" },
      src: String,
      style: String,
      size: String,
      pathPrefix: { attribute: "path-prefix" }
    };
  }
  static get styles() {
    return css`
      :host {
        display: inline-block;
        padding: 0;
        margin: 0;
      }
      :host svg {
        fill: var(--fa-icon-fill-color, currentcolor);
        width: var(--fa-icon-width, 19px);
        height: var(--fa-icon-height, 19px);
      }
    `;
  }
  getSources(className) {
    const PREFIX_TO_STYLE = {
      fas: "solid",
      far: "regular",
      fal: "light",
      fab: "brands",
      fa: "solid"
    };
    const getPrefix = (iClass) => {
      let data2 = iClass.split(" ");
      return [PREFIX_TO_STYLE[data2[0]], normalizeIconName(data2[1])];
    };
    const normalizeIconName = (name) => {
      let icon = name.replace("fa-", "");
      return icon;
    };
    let data = getPrefix(className);
    return `${this.pathPrefix}/@fortawesome/fontawesome-free/sprites/${data[0]}.svg#${data[1]}`;
  }
  constructor() {
    super();
    this.iClass = "";
    this.src = "";
    this.style = "";
    this.size = "";
    this.color = "";
    this.pathPrefix = "node_modules";
  }
  firstUpdated() {
    this.src = this.getSources(this.iClass);
  }
  _parseStyles() {
    return `
      ${this.size ? `width: ${this.size};` : ""}
      ${this.size ? `height: ${this.size};` : ""}
      ${this.color ? `fill: ${this.color};` : ""}
      ${this.style}
    `;
  }
  render() {
    return html`
      <svg 
        .style="${this._parseStyles()}">
        <use 
          href="${this.src}">
        </use>
      </svg>
    `;
  }
};
customElements.define("fa-icon", FaIcon);
var _drawObject_dec;
var _layerControl_dec;
var _editObjectMarkers_dec;
var _editObject_dec;
var _showBoundsLayer_dec;
var _showBounds_dec;
var _mouseMarker_dec;
var _mapMode_dec;
var _pinTitle_dec;
var _inputDrawObjectLabel_dec;
var _inputFillColor_dec;
var _inputBorderColor_dec;
var _inputZoom_dec;
var _inputLng_dec;
var _inputLat_dec;
var _boundsActive_dec;
var _mapHeight_dec;
var _mapWidth_dec;
var _geoJSON_dec;
var _customTileUrl_dec;
var _objects_dec;
var _markers_dec;
var _initialZoom_dec;
var _minZoom_dec;
var _maxZoom_dec;
var _mapBounds_dec;
var _initialPos_dec;
var _map_dec;
var _pinDialog_dec;
var _mapElement_dec;
var _a32;
var _WwMap_decorators;
var _init26;
var _mapElement;
var _pinDialog;
var _map;
var _initialPos;
var _mapBounds;
var _maxZoom;
var _minZoom;
var _initialZoom;
var _markers;
var _objects;
var _customTileUrl;
var _geoJSON;
var _mapWidth;
var _mapHeight;
var _boundsActive;
var _inputLat;
var _inputLng;
var _inputZoom;
var _inputBorderColor;
var _inputFillColor;
var _inputDrawObjectLabel;
var _pinTitle;
var _mapMode;
var _mouseMarker;
var _showBounds;
var _showBoundsLayer;
var _editObject;
var _editObjectMarkers;
var _layerControl;
var _drawObject;
_WwMap_decorators = [t36("webwriter-map")];
var WwMap = class extends (_a32 = LitElementWw6, _mapElement_dec = [e65("#map")], _pinDialog_dec = [e65("#pinDialog")], _map_dec = [n82({ type: Object })], _initialPos_dec = [n82({ type: Object, attribute: true, reflect: true })], _mapBounds_dec = [n82({ type: Object, attribute: true, reflect: true })], _maxZoom_dec = [n82({ type: Number, attribute: true, reflect: true })], _minZoom_dec = [n82({ type: Number, attribute: true, reflect: true })], _initialZoom_dec = [n82({ type: Number, attribute: true, reflect: true })], _markers_dec = [n82({ type: Array, attribute: true, reflect: true })], _objects_dec = [n82({ type: Object, attribute: true, reflect: true })], _customTileUrl_dec = [n82({ type: String, attribute: true, reflect: true })], _geoJSON_dec = [n82({ type: String, attribute: true, reflect: true })], _mapWidth_dec = [n82({ type: Number, attribute: true, reflect: true })], _mapHeight_dec = [n82({ type: Number, attribute: true, reflect: true })], _boundsActive_dec = [n82({ type: Boolean, attribute: true, reflect: true })], _inputLat_dec = [n82({ type: Number })], _inputLng_dec = [n82({ type: Number })], _inputZoom_dec = [n82({ type: Number })], _inputBorderColor_dec = [n82({ type: String })], _inputFillColor_dec = [n82({ type: String })], _inputDrawObjectLabel_dec = [n82({ type: String })], _pinTitle_dec = [n82({ type: String })], _mapMode_dec = [n82({ type: String })], _mouseMarker_dec = [n82({ type: Object })], _showBounds_dec = [n82({ type: Boolean })], _showBoundsLayer_dec = [n82({ type: Object })], _editObject_dec = [n82({ type: Object })], _editObjectMarkers_dec = [n82({ type: Array })], _layerControl_dec = [n82({ type: Object })], _drawObject_dec = [n82({ type: Object })], _a32) {
  constructor() {
    super(...arguments);
    this.styles = [style, leafletStyles];
    __privateAdd8(this, _mapElement, __runInitializers7(_init26, 8, this)), __runInitializers7(_init26, 11, this);
    __privateAdd8(this, _pinDialog, __runInitializers7(_init26, 12, this)), __runInitializers7(_init26, 15, this);
    __privateAdd8(this, _map, __runInitializers7(_init26, 16, this)), __runInitializers7(_init26, 19, this);
    __privateAdd8(this, _initialPos, __runInitializers7(_init26, 20, this, {
      lat: 51,
      lng: 19
    })), __runInitializers7(_init26, 23, this);
    __privateAdd8(this, _mapBounds, __runInitializers7(_init26, 24, this)), __runInitializers7(_init26, 27, this);
    __privateAdd8(this, _maxZoom, __runInitializers7(_init26, 28, this)), __runInitializers7(_init26, 31, this);
    __privateAdd8(this, _minZoom, __runInitializers7(_init26, 32, this)), __runInitializers7(_init26, 35, this);
    __privateAdd8(this, _initialZoom, __runInitializers7(_init26, 36, this, 13)), __runInitializers7(_init26, 39, this);
    __privateAdd8(this, _markers, __runInitializers7(_init26, 40, this, [])), __runInitializers7(_init26, 43, this);
    __privateAdd8(this, _objects, __runInitializers7(_init26, 44, this, {})), __runInitializers7(_init26, 47, this);
    __privateAdd8(this, _customTileUrl, __runInitializers7(_init26, 48, this, "")), __runInitializers7(_init26, 51, this);
    __privateAdd8(this, _geoJSON, __runInitializers7(_init26, 52, this, "")), __runInitializers7(_init26, 55, this);
    __privateAdd8(this, _mapWidth, __runInitializers7(_init26, 56, this, 100)), __runInitializers7(_init26, 59, this);
    __privateAdd8(this, _mapHeight, __runInitializers7(_init26, 60, this, 500)), __runInitializers7(_init26, 63, this);
    __privateAdd8(this, _boundsActive, __runInitializers7(_init26, 64, this, true)), __runInitializers7(_init26, 67, this);
    __privateAdd8(this, _inputLat, __runInitializers7(_init26, 68, this, 0)), __runInitializers7(_init26, 71, this);
    __privateAdd8(this, _inputLng, __runInitializers7(_init26, 72, this, 0)), __runInitializers7(_init26, 75, this);
    __privateAdd8(this, _inputZoom, __runInitializers7(_init26, 76, this, 0)), __runInitializers7(_init26, 79, this);
    __privateAdd8(this, _inputBorderColor, __runInitializers7(_init26, 80, this, "#000000ff")), __runInitializers7(_init26, 83, this);
    __privateAdd8(this, _inputFillColor, __runInitializers7(_init26, 84, this, "#000000ff")), __runInitializers7(_init26, 87, this);
    __privateAdd8(this, _inputDrawObjectLabel, __runInitializers7(_init26, 88, this, "")), __runInitializers7(_init26, 91, this);
    __privateAdd8(this, _pinTitle, __runInitializers7(_init26, 92, this, "")), __runInitializers7(_init26, 95, this);
    __privateAdd8(this, _mapMode, __runInitializers7(_init26, 96, this, "view")), __runInitializers7(_init26, 99, this);
    __privateAdd8(this, _mouseMarker, __runInitializers7(_init26, 100, this)), __runInitializers7(_init26, 103, this);
    __privateAdd8(this, _showBounds, __runInitializers7(_init26, 104, this, false)), __runInitializers7(_init26, 107, this);
    __privateAdd8(this, _showBoundsLayer, __runInitializers7(_init26, 108, this)), __runInitializers7(_init26, 111, this);
    __privateAdd8(this, _editObject, __runInitializers7(_init26, 112, this)), __runInitializers7(_init26, 115, this);
    __privateAdd8(this, _editObjectMarkers, __runInitializers7(_init26, 116, this, [])), __runInitializers7(_init26, 119, this);
    __privateAdd8(this, _layerControl, __runInitializers7(_init26, 120, this)), __runInitializers7(_init26, 123, this);
    __privateAdd8(this, _drawObject, __runInitializers7(_init26, 124, this)), __runInitializers7(_init26, 127, this);
  }
  static get scopedElements() {
    return {
      "sl-button-group": SlButtonGroup4,
      "sl-button": SlButton4,
      "sl-icon": SlIcon5,
      "sl-input": SlInput,
      "sl-checkbox": SlCheckbox3,
      "sl-details": SlDetails2,
      "sl-range": SlRange,
      "sl-progress-bar": SlProgressBar,
      "sl-card": SlCard,
      "sl-divider": SlDivider,
      "sl-switch": SlSwitch,
      "sl-menu": SlMenu2,
      "sl-menu-item": SlMenuItem2,
      "sl-dropdown": SlDropdown2,
      "sl-tooltip": SlTooltip,
      "sl-dialog": SlDialog,
      "sl-color-picker": SlColorPicker
    };
  }
  connectedCallback() {
    super.connectedCallback();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
  update(changedProperties) {
    super.update(changedProperties);
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (this.map && changedProperties.has("customTileUrl")) {
      this.map.eachLayer((layer) => {
        if (layer instanceof L4.TileLayer) this.map.removeLayer(layer);
      });
      if (this.layerControl) {
        this.map.removeControl(this.layerControl);
      }
      if (this.customTileUrl) {
        L4.tileLayer(this.customTileUrl, {
          attribution: ""
        }).addTo(this.map);
      } else {
        const osm = L4.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });
        const otm = L4.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
          attribution: '&copy; <a href="https://www.opentopomap.org">OpenTopoMap</a> contributors'
        });
        const sat = L4.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: '&copy; <a href="https://www.esri.com/">Esri</a> contributors'
          }
        );
        const baseLayers = {
          OpenStreetMap: osm,
          OpenTopoMap: otm,
          Satellite: sat
        };
        this.layerControl = L4.control.layers(baseLayers).addTo(this.map);
        osm.addTo(this.map);
      }
      this.markers?.forEach((marker3) => {
        const m42 = L4.marker([marker3.lat, marker3.lng], { icon: icons5.RED }).addTo(this.map);
        m42.bindPopup(marker3.title);
      });
    }
    if (this.map && changedProperties.has("geoJSON")) {
      this.map.eachLayer((layer) => {
        if (layer instanceof L4.GeoJSON) this.map.removeLayer(layer);
      });
      if (this.geoJSON) {
        L4.geoJSON(JSON.parse(this.geoJSON)).addTo(this.map);
      }
      this.markers?.forEach((marker3) => {
        const m42 = L4.marker([marker3.lat, marker3.lng], { icon: icons5.RED }).addTo(this.map);
        m42.bindPopup(marker3.title);
      });
    }
    if (this.map && changedProperties.has("mapBounds")) {
      if (this.mapBounds && this.boundsActive) {
        this.map.setMaxBounds(this.mapBounds);
      } else {
        this.map.setMaxBounds(void 0);
      }
    }
    if (this.map && changedProperties.has("maxZoom")) {
      if (this.maxZoom && this.boundsActive) {
        this.map.setMaxZoom(this.maxZoom);
      } else {
        this.map.setMaxZoom(Infinity);
      }
    }
    if (this.map && changedProperties.has("minZoom")) {
      if (this.minZoom) {
        this.map.setMinZoom(this.minZoom);
      } else {
        this.map.setMinZoom(0);
      }
    }
    if (this.map && changedProperties.has("boundsActive")) {
      if (this.boundsActive) {
        this.map.setMaxBounds(this.mapBounds);
      } else {
        this.map.setMaxBounds(void 0);
      }
    }
    if (this.map && changedProperties.has("editable")) {
      this.clearEditObject();
    }
  }
  shouldUpdate(changedProperties) {
    return super.shouldUpdate(changedProperties);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
  }
  firstUpdated(_changedProperties) {
    super.firstUpdated(_changedProperties);
    this.map = L4.map(this.mapElement).setView([this.initialPos.lat, this.initialPos.lng], this.initialZoom);
    if (this.customTileUrl) {
      L4.tileLayer(this.customTileUrl, {
        attribution: ""
      }).addTo(this.map);
    } else {
      L4.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(this.map);
    }
    if (this.geoJSON) {
      L4.geoJSON(JSON.parse(this.geoJSON)).addTo(this.map);
    }
    this.markers?.forEach((marker3) => {
      const m42 = L4.marker([marker3.lat, marker3.lng], { icon: icons5.RED }).addTo(this.map);
      m42.bindPopup(marker3.title);
    });
    this.map.on("move", this.onMapMove.bind(this));
    this.map.on("click", this.onMapClick.bind(this));
    this.inputLat = this.initialPos.lat;
    this.inputLng = this.initialPos.lng;
    this.inputZoom = this.initialZoom;
    this.loadObjects();
    setInterval(() => {
      this.setInitialPosition();
    }, 250);
  }
  isEditable() {
    return this.contentEditable === "true" || this.contentEditable === "";
  }
  onMapMove() {
  }
  onMapClick(e17) {
    if (this.mapMode === "mouseSelect") {
      if (this.mouseMarker) {
        this.map?.removeLayer(this.mouseMarker);
      }
      this.mouseMarker = L4.marker(e17.latlng, { icon: icons5.YELLOW }).addTo(this.map);
      this.inputLat = e17.latlng.lat;
      this.inputLng = e17.latlng.lng;
      this.inputZoom = this.map?.getZoom() || 0;
    }
  }
  render() {
    return ke26`
            <style>
                ${this.styles}
            </style>

            ${this.isEditable() ? this.toolbox() : ""}

            <div id="map" style=${se4({ height: this.mapHeight + "px", width: this.mapWidth + "%" })}></div>

            ${this.isEditable() ? this.dialogs() : ""}
        `;
  }
  toolbox() {
    return ke26`
            <div part="options" class="toolbox">
                <!-- <div class="position">
                    <sl-input
                        class="label-on-left"
                        label="Lat"
                        value=${this.inputLat}
                        @sl-change=${(e17) => {
      this.inputLat = e17.target.value;
    }}
                    ></sl-input>
                    <sl-input
                        class="label-on-left"
                        label="Lng"
                        value=${this.inputLng}
                        @sl-change=${(e17) => {
      this.inputLng = e17.target.value;
    }}
                    ></sl-input>
                </div>
                <sl-input
                    class="label-on-left"
                    label="Zoom"
                    value=${this.inputZoom}
                    @sl-change=${(e17) => {
      this.inputZoom = e17.target.value;
    }}
                ></sl-input>

                <sl-button-group label="Positions">
                    <sl-tooltip content="Set current Position">
                        <sl-button
                            @click=${() => {
      this.loadMapPosition();
    }}
                            >${faMapLocationDot}</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content="Set your Location">
                        <sl-button
                            @click=${() => {
      this.loadGeoLocation();
    }}
                            >${faLocationCrosshairs}</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content=${(this.mapMode !== "mouseSelect" ? "Enable" : "Disable") + " Mouse Selection"}>
                        <sl-button
                            @click=${() => {
      if (this.mapMode === "mouseSelect") {
        this.map?.removeLayer(this.mouseMarker);
        this.mapMode = "view";
      } else {
        this.mapMode = "mouseSelect";
      }
    }}
                            variant=${this.mapMode === "mouseSelect" ? "primary" : "default"}
                            >${faArrowPointer}</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content="Find Position">
                        <sl-button
                            @click=${() => {
      this.map?.setView([this.inputLat, this.inputLng], this.inputZoom);
    }}
                            >${faMagnifyingGlassLocation}</sl-button
                        >
                    </sl-tooltip>
                </sl-button-group>
                <sl-button-group label="Actions">
                    <sl-tooltip content="Add Pin">
                        <sl-button
                            @click=${() => {
      this.pinDialog.show();
    }}
                            >${faLocationDot}</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content="Set Position as initial">
                        <sl-button
                            @click=${() => {
      this.setInitialPosition();
    }}
                            >${faStreetView}</sl-button
                        >
                    </sl-tooltip>
                </sl-button-group>
                <sl-details class="custom-icons">
                    <div slot="summary">
                        Bounds
                        <i style="font-size:0.5rem"
                            >(${!this.mapBounds ? "not set" : this.boundsActive ? "activated" : "deactivated"})</i
                        >
                    </div>
                    <span name="plus-square" slot="expand-icon">${faSquarePlus}</span>
                    <span name="dash-square" slot="collapse-icon">${faSquareMinus}</span>

                    <sl-button-group label="Bounds">
                        <sl-tooltip content="Set Top Left">
                            <sl-button
                                @click=${() => {
      if (this.mapBounds) {
        this.mapBounds = [[this.inputLat, this.inputLng], this.mapBounds[1]];
      } else {
        this.mapBounds = [
          [this.inputLat, this.inputLng],
          [this.inputLat, this.inputLng]
        ];
      }
    }}
                                >${faBorderTopLeft}</sl-button
                            >
                        </sl-tooltip>
                        <sl-tooltip content="Set Bottom Right">
                            <sl-button
                                @click=${() => {
      if (this.mapBounds) {
        this.mapBounds = [this.mapBounds[0], [this.inputLat, this.inputLng]];
      } else {
        this.mapBounds = [
          [this.inputLat, this.inputLng],
          [this.inputLat, this.inputLng]
        ];
      }
    }}
                                >${faBorderBottomRight}</sl-button
                            >
                        </sl-tooltip>
                        <sl-tooltip content="Set Max Zoom">
                            <sl-button
                                @click=${() => {
      this.maxZoom = this.inputZoom;
    }}
                                >${faMagnifyingGlassPlus}</sl-button
                            >
                        </sl-tooltip>
                        <sl-tooltip content="Set Min Zoom">
                            <sl-button
                                @click=${() => {
      this.minZoom = this.inputZoom;
    }}
                                >${faMagnifyingGlassMinus}</sl-button
                            >
                        </sl-tooltip>
                    </sl-button-group>
                    <sl-button-group label="Actions">
                        <sl-tooltip content="Fit Bounds">
                            <sl-button
                                @click=${() => {
      this.map?.fitBounds(this.mapBounds);
    }}
                                >${faExpand}</sl-button
                            >
                        </sl-tooltip>
                        <sl-tooltip content="Visualize Bounds">
                            <sl-button
                                @click=${() => {
      this.showBounds = !this.showBounds;
      if (this.showBounds) {
        this.map?.fitBounds(this.mapBounds);
        this.showBoundsLayer = L4.rectangle(this.mapBounds, {
          color: "#ff7800",
          weight: 1
        }).addTo(this.map);
      } else {
        this.map?.removeLayer(this.showBoundsLayer);
      }
    }}
                                variant=${this.showBounds ? "primary" : "default"}
                                >${!this.showBounds ? faEye : faEyeSlashed}</sl-button
                            >
                        </sl-tooltip>
                        <sl-tooltip content=${this.boundsActive ? "Disable Bounds" : "Enable Bounds"}>
                            <sl-button
                                @click=${() => {
      this.boundsActive = !this.boundsActive;
    }}
                                variant=${!this.boundsActive ? "primary" : "default"}
                                >${this.boundsActive ? faBan : faBan}</sl-button
                            >
                        </sl-tooltip>
                        <sl-tooltip content="Reset Bounds">
                            <sl-button
                                @click=${() => {
      this.mapBounds = void 0;
      this.maxZoom = void 0;
      this.minZoom = void 0;
      this.showBounds = false;
      if (this.showBoundsLayer) {
        this.map?.removeLayer(this.showBoundsLayer);
      }
    }}
                                >${faTrash}</sl-button
                            >
                        </sl-tooltip>
                    </sl-button-group>
                </sl-details>
                <sl-details summary="Draw" class="custom-icons">
                    <span name="plus-square" slot="expand-icon">${faSquarePlus}</span>
                    <span name="dash-square" slot="collapse-icon">${faSquareMinus}</span>

                    <div>
                        <sl-button-group label="Draw">
                            <sl-tooltip content="Draw Rectangle">
                                <sl-button
                                    @click=${this.addRectangel}
                                    variant=${this.mapMode === "drawingRectangle" || this.mapMode === "awaitDrawingRectangel" ? "primary" : "default"}
                                >
                                    ${faVectorSquare}
                                </sl-button>
                            </sl-tooltip>
                            <sl-tooltip content="Draw Circle">
                                <sl-button
                                    @click=${this.addCircle}
                                    variant=${this.mapMode === "drawingCircle" || this.mapMode === "awaitDrawingCircle" ? "primary" : "default"}
                                >
                                    ${faCircle}
                                </sl-button>
                            </sl-tooltip>
                            <sl-tooltip content="Draw Polygon">
                                <sl-button
                                    @click=${() => {
      if (this.mapMode === "drawingPolygon") {
        this.mapMode = "view";
        this.drawObject.on("click", (e17) => {
          this.onPolygonClick(e17);
        });
        if (this.inputDrawObjectLabel) {
          this.drawObject.bindTooltip(this.inputDrawObjectLabel, {
            direction: "center"
          });
        }
        this.map?.dragging.enable();
        this.saveObject(this.drawObject);
      } else {
        this.addPolygon();
      }
    }}
                                    variant=${this.mapMode === "drawingPolygon" ? "primary" : "default"}
                                >
                                    ${faDrawPolygon}
                                </sl-button>
                            </sl-tooltip>
                            <sl-tooltip content="Draw Polyline">
                                <sl-button
                                    @click=${() => {
      if (this.mapMode === "drawingPolyline") {
        this.mapMode = "view";
        this.drawObject.on("click", (e17) => {
          this.onPolylineClick(e17);
        });
        if (this.inputDrawObjectLabel) {
          this.drawObject.bindTooltip(this.inputDrawObjectLabel, {
            direction: "center"
          });
        }
        this.map?.dragging.enable();
        this.saveObject(this.drawObject);
      } else {
        this.addPolyline();
      }
    }}
                                    variant=${this.mapMode === "drawingPolyline" ? "primary" : "default"}
                                >
                                    ${faSlash}
                                </sl-button>
                            </sl-tooltip>
                        </sl-button-group>
                        <sl-button-group label="Delete">
                            <sl-tooltip content="Delete Object">
                                <sl-button
                                    @click=${() => {
      this.deleteSelectedObject();
    }}
                                    ?disabled=${!this.editObject}
                                    >${faTrash}</sl-button
                                >
                            </sl-tooltip>
                        </sl-button-group>
                    </div>
                    <div>
                        <span>Border Color</span>
                        <sl-tooltip content="Border Color">
                            <sl-color-picker
                                opacity
                                value=${this.inputBorderColor}
                                @sl-change=${(e17) => {
      this.inputBorderColor = e17.target.value;
    }}
                            >
                                <span slot="label">Border Color</span>
                            </sl-color-picker>
                        </sl-tooltip>
                    </div>
                    <div>
                        <span>Fill Color</span>
                        <sl-tooltip content="Fill Color">
                            <sl-color-picker
                                opacity
                                value=${this.inputFillColor}
                                @sl-change=${(e17) => {
      this.inputFillColor = e17.target.value;
    }}
                            >
                                <span slot="label">Fill Color</span>
                            </sl-color-picker>
                        </sl-tooltip>
                    </div>
                    <div>
                        <sl-input
                            label="Label"
                            value=${this.inputDrawObjectLabel}
                            @sl-change=${(e17) => {
      this.inputDrawObjectLabel = e17.target.value;
    }}
                        ></sl-input>
                    </div>
                </sl-details>

                <sl-details summary="Size" class="custom-icons">
                    <span name="plus-square" slot="expand-icon">${faSquarePlus}</span>
                    <span name="dash-square" slot="collapse-icon">${faSquareMinus}</span>

                    <sl-input
                        label="Width"
                        value=${this.mapWidth}
                        @sl-change=${(e17) => {
      this.mapWidth = e17.target.value;
    }}
                    >
                        <span slot="suffix">%</span></sl-input
                    >
                    <sl-input
                        label="Height"
                        value=${this.mapHeight}
                        @sl-change=${(e17) => {
      this.mapHeight = e17.target.value;
    }}
                        ><span slot="suffix">px</span></sl-input
                    >
                </sl-details> -->

                <sl-details summary="Advanced" class="custom-icons">
                    <span name="plus-square" slot="expand-icon">${faSquarePlus}</span>
                    <span name="dash-square" slot="collapse-icon">${faSquareMinus}</span>

                    <p style="margin-top:-20px;margin-bottom:-2px; font-size:11.5pt">Map style</p>
                    <sl-tooltip content="Default">
                        <sl-button
                            @click=${() => {
      this.customTileUrl = void 0;
    }}
                            >User select</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content="OpenStreetMapDE">
                        <sl-button
                            @click=${() => {
      this.customTileUrl = "https://tile.openstreetmap.de/{z}/{x}/{y}.png";
    }}
                            >OpenStreetMapDE</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content="OpenTopoMap">
                        <sl-button
                            @click=${() => {
      this.customTileUrl = "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png";
    }}
                            >OpenTopoMap</sl-button
                        >
                    </sl-tooltip>
                    <sl-tooltip content="WorldImagery">
                        <sl-button
                            @click=${() => {
      this.customTileUrl = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";
    }}
                            >WorldImagery</sl-button
                        >
                    </sl-tooltip>
                    <sl-input
                        label="Custom Tile Url"
                        value=${this.customTileUrl}
                        @sl-change=${(e17) => {
      this.customTileUrl = e17.target.value;
    }}
                    ></sl-input>
                    <sl-input
                        label="GeoJSON"
                        value=${this.geoJSON}
                        @sl-change=${(e17) => {
      this.geoJSON = e17.target.value;
    }}
                    ></sl-input>
                </sl-details>
            </div>
        `;
  }
  dialogs() {
    return ke26`<sl-dialog id="pinDialog">
            <div slot="label">
                Add Pin
                <div class="marker-icon marker-icon-red" style="position: relative"></div>
            </div>
            <sl-input
                autofocus
                placeholder="Text"
                value=${this.pinTitle}
                @sl-change=${(e17) => {
      this.pinTitle = e17.target.value;
    }}
            ></sl-input>
            <sl-button
                slot="footer"
                variant="primary"
                @click=${() => {
      this.addLabel();
    }}
                >Add</sl-button
            >
        </sl-dialog>`;
  }
  addRectangel() {
    this.map?.dragging.disable();
    this.mapMode = "awaitDrawingRectangel";
    this.map?.off("mousemove");
    this.map?.off("mousedown");
    const onMapDivMouseDown = this.map.on("mousedown", (e17) => {
      if (this.mapMode === "awaitDrawingRectangel") {
        this.mapMode = "drawingRectangle";
        this.drawObject = L4.rectangle([e17.latlng, e17.latlng], {
          color: this.inputBorderColor,
          fillColor: this.inputFillColor,
          opacity: this.getOpacity(this.inputBorderColor),
          fillOpacity: this.getOpacity(this.inputFillColor)
        }).addTo(this.map);
        this.map.off("mousedown", onMapDivMouseDown);
      }
    });
    const onMapDivMove = this.map.on("mousemove", (e17) => {
      if (this.mapMode === "drawingRectangle") {
        this.drawObject?.setBounds(L4.latLngBounds(this.drawObject.getBounds().getNorthWest(), e17.latlng));
      }
    });
    const onMapDivMouseUp = this.map.on("mouseup", (e17) => {
      if (this.mapMode === "drawingRectangle") {
        this.mapMode = "view";
        this.map.off("mousemove", onMapDivMove);
        this.map.off("mouseup", onMapDivMouseUp);
        this.drawObject.on("click", (e18) => {
          this.onRectangleClick(e18);
        });
        if (this.inputDrawObjectLabel) {
          this.drawObject.bindTooltip(this.inputDrawObjectLabel, {
            direction: "center"
          });
        }
        this.map?.dragging.enable();
        this.saveObject(this.drawObject);
      }
    });
  }
  addCircle() {
    this.map?.dragging.disable();
    this.mapMode = "awaitDrawingCircle";
    this.map?.off("mousemove");
    this.map?.off("mousedown");
    const onMapDivMouseDown = this.map.on("mousedown", (e17) => {
      if (this.mapMode === "awaitDrawingCircle") {
        this.mapMode = "drawingCircle";
        this.drawObject = L4.circle(e17.latlng, {
          color: this.inputBorderColor,
          fillColor: this.inputFillColor,
          opacity: this.getOpacity(this.inputBorderColor),
          fillOpacity: this.getOpacity(this.inputFillColor)
        }).addTo(this.map);
        this.map.off("mousedown", onMapDivMouseDown);
      }
    });
    const onMapDivMove = this.map.on("mousemove", (e17) => {
      if (this.mapMode === "drawingCircle") {
        this.drawObject?.setRadius(this.drawObject.getLatLng().distanceTo(e17.latlng));
      }
    });
    const onMapDivMouseUp = this.map.on("mouseup", (e17) => {
      if (this.mapMode === "drawingCircle") {
        this.mapMode = "view";
        this.map.off("mousemove");
        this.map.off("mouseup");
        this.drawObject.on("click", (e18) => {
          this.onCircleClick(e18);
        });
        if (this.inputDrawObjectLabel) {
          this.drawObject.bindTooltip(this.inputDrawObjectLabel, {
            direction: "center"
          });
        }
        this.map?.dragging.enable();
        this.saveObject(this.drawObject);
      }
    });
  }
  addPolygon() {
    this.map?.dragging.disable();
    this.mapMode = "drawingPolygon";
    this.drawObject = void 0;
    this.map?.off("mousemove");
    this.map?.off("mousedown");
    const onMapDivMouseDown = this.map.on("click", (e17) => {
      if (this.mapMode === "drawingPolygon") {
        if (this.drawObject) {
          this.drawObject.addLatLng(e17.latlng);
        } else {
          this.drawObject = L4.polygon([e17.latlng], {
            color: this.inputBorderColor,
            fillColor: this.inputFillColor,
            opacity: this.getOpacity(this.inputBorderColor),
            fillOpacity: this.getOpacity(this.inputFillColor)
          }).addTo(this.map);
        }
      }
    });
  }
  addPolyline() {
    this.map?.dragging.disable();
    this.mapMode = "drawingPolyline";
    this.drawObject = void 0;
    this.map?.off("mousemove");
    this.map?.off("mousedown");
    const onMapDivMouseDown = this.map.on("click", (e17) => {
      if (this.mapMode === "drawingPolyline") {
        if (this.drawObject) {
          this.drawObject.addLatLng(e17.latlng);
        } else {
          this.drawObject = L4.polyline([e17.latlng], {
            color: this.inputBorderColor,
            fillColor: this.inputFillColor,
            opacity: this.getOpacity(this.inputBorderColor),
            fillOpacity: this.getOpacity(this.inputFillColor)
          }).addTo(this.map);
        }
      }
    });
  }
  getPolygonPoints(n17) {
    const points = [];
    const centerLat = this.inputLat;
    const centerLng = this.inputLng;
    for (let i12 = 0; i12 < n17; i12++) {
      const x52 = centerLat + 0.01 * Math.cos(2 * Math.PI * i12 / n17);
      const y42 = centerLng + 0.01 * Math.sin(2 * Math.PI * i12 / n17);
      points.push([x52, y42]);
    }
    return points;
  }
  getPolylinePoints(n17) {
    const points = [];
    const centerLat = this.inputLat;
    const centerLng = this.inputLng;
    for (let i12 = 0; i12 < n17; i12++) {
      const x52 = centerLat + 0.01 * i12;
      const y42 = centerLng + 0.01 * i12;
      points.push([x52, y42]);
    }
    return points;
  }
  onRectangleClick(e17) {
    if (!this.isEditable()) return;
    this.clearEditObject();
    this.editObject = e17.target;
    const markerTL = L4.marker(this.editObject.getBounds().getNorthWest(), {
      draggable: true,
      icon: icons5.GREEN
    }).addTo(this.map);
    const markerTR = L4.marker(this.editObject.getBounds().getNorthEast(), {
      draggable: true,
      icon: icons5.GREEN
    }).addTo(this.map);
    const markerBL = L4.marker(this.editObject.getBounds().getSouthWest(), {
      draggable: true,
      icon: icons5.GREEN
    }).addTo(this.map);
    const markerBR = L4.marker(this.editObject.getBounds().getSouthEast(), {
      draggable: true,
      icon: icons5.GREEN
    }).addTo(this.map);
    this.editObjectMarkers.push(markerTL);
    this.editObjectMarkers.push(markerTR);
    this.editObjectMarkers.push(markerBL);
    this.editObjectMarkers.push(markerBR);
    markerTL.on("drag", (e18) => {
      this.editObject?.setBounds(L4.latLngBounds(e18.target.getLatLng(), markerBR.getLatLng()));
      this.editObjectMarkers[1].setLatLng(this.editObject.getBounds().getNorthEast());
      this.editObjectMarkers[2].setLatLng(this.editObject.getBounds().getSouthWest());
      this.editObjectMarkers[3].setLatLng(this.editObject.getBounds().getSouthEast());
    });
    markerTL.once("dragend", (e18) => {
      this.saveObject(this.editObject, this.editObject.id);
    });
    markerTR.on("drag", (e18) => {
      this.editObject?.setBounds(
        L4.latLngBounds(
          [e18.target.getLatLng().lat, markerTL.getLatLng().lng],
          [markerBL.getLatLng().lat, e18.target.getLatLng().lng]
        )
      );
      this.editObjectMarkers[0].setLatLng(this.editObject.getBounds().getNorthWest());
      this.editObjectMarkers[2].setLatLng(this.editObject.getBounds().getSouthWest());
      this.editObjectMarkers[3].setLatLng(this.editObject.getBounds().getSouthEast());
    });
    markerTR.once("dragend", (e18) => {
      this.saveObject(this.editObject, this.editObject.id);
    });
    markerBL.on("drag", (e18) => {
      this.editObject?.setBounds(
        L4.latLngBounds(
          [markerTL.getLatLng().lat, e18.target.getLatLng().lng],
          [e18.target.getLatLng().lat, markerBR.getLatLng().lng]
        )
      );
      this.editObjectMarkers[0].setLatLng(this.editObject.getBounds().getNorthWest());
      this.editObjectMarkers[1].setLatLng(this.editObject.getBounds().getNorthEast());
      this.editObjectMarkers[3].setLatLng(this.editObject.getBounds().getSouthEast());
    });
    markerBL.once("dragend", (e18) => {
      this.saveObject(this.editObject, this.editObject.id);
    });
    markerBR.on("drag", (e18) => {
      this.editObject?.setBounds(L4.latLngBounds(markerTL.getLatLng(), e18.target.getLatLng()));
      this.editObjectMarkers[0].setLatLng(this.editObject.getBounds().getNorthWest());
      this.editObjectMarkers[1].setLatLng(this.editObject.getBounds().getNorthEast());
      this.editObjectMarkers[2].setLatLng(this.editObject.getBounds().getSouthWest());
    });
    markerBR.once("dragend", (e18) => {
      this.saveObject(this.editObject, this.editObject.id);
    });
  }
  onCircleClick(e17) {
    if (!this.isEditable()) return;
    if (this.editObjectMarkers.length > 0) {
      this.editObjectMarkers.forEach((marker3) => {
        this.map?.removeLayer(marker3);
      });
      this.editObjectMarkers = [];
    }
    this.editObject = e17.target;
    const markerCenter = L4.marker(this.editObject.getLatLng(), {
      draggable: true,
      icon: icons5.GREEN
    }).addTo(this.map);
    const markerRadius = L4.marker(
      [
        this.editObject.getBounds().getNorthEast().lat,
        this.editObject.getBounds().getNorthWest().lng + Math.abs(
          this.editObject.getBounds().getNorthEast().lng - this.editObject.getBounds().getNorthWest().lng
        ) / 2
      ],
      {
        draggable: true,
        icon: icons5.GREEN
      }
    ).addTo(this.map);
    this.editObjectMarkers.push(markerCenter);
    this.editObjectMarkers.push(markerRadius);
    markerCenter.on("drag", (e18) => {
      this.editObject?.setLatLng(e18.target.getLatLng());
      this.editObjectMarkers[1].setLatLng([
        this.editObject.getBounds().getNorthEast().lat,
        this.editObject.getBounds().getNorthWest().lng + Math.abs(
          this.editObject.getBounds().getNorthEast().lng - this.editObject.getBounds().getNorthWest().lng
        ) / 2
      ]);
    });
    markerCenter.once("dragend", (e18) => {
      this.saveObject(this.editObject, this.editObject.id);
    });
    markerRadius.on("drag", (e18) => {
      this.editObject?.setRadius(e18.target.getLatLng().distanceTo(markerCenter.getLatLng()));
      this.editObjectMarkers[0].setLatLng(this.editObject.getLatLng());
    });
    markerRadius.once("dragend", (e18) => {
      this.saveObject(this.editObject, this.editObject.id);
    });
  }
  onPolygonClick(e17) {
    if (!this.isEditable()) return;
    if (this.editObjectMarkers.length > 0) {
      this.editObjectMarkers.forEach((marker3) => {
        this.map?.removeLayer(marker3);
      });
      this.editObjectMarkers = [];
    }
    this.editObject = e17.target;
    this.editObject.getLatLngs()[0].forEach((point) => {
      const marker3 = L4.marker(point, {
        draggable: true,
        icon: icons5.GREEN
      }).addTo(this.map);
      this.editObjectMarkers.push(marker3);
      marker3.on("drag", (e18) => {
        const index = this.editObjectMarkers.indexOf(e18.target);
        const latlngs = this.editObject.getLatLngs()[0];
        latlngs[index] = e18.target.getLatLng();
        this.editObject.setLatLngs(latlngs);
      });
      marker3.once("dragend", (e18) => {
        this.saveObject(this.editObject, this.editObject.id);
      });
    });
  }
  onPolylineClick(e17) {
    if (!this.isEditable()) return;
    if (this.editObjectMarkers.length > 0) {
      this.editObjectMarkers.forEach((marker3) => {
        this.map?.removeLayer(marker3);
      });
      this.editObjectMarkers = [];
    }
    this.editObject = e17.target;
    this.editObject.getLatLngs().forEach((point) => {
      const marker3 = L4.marker(point, {
        draggable: true,
        icon: icons5.GREEN
      }).addTo(this.map);
      this.editObjectMarkers.push(marker3);
      marker3.on("drag", (e18) => {
        const index = this.editObjectMarkers.indexOf(e18.target);
        const latlngs = this.editObject.getLatLngs();
        latlngs[index] = e18.target.getLatLng();
        this.editObject.setLatLngs(latlngs);
      });
      marker3.once("dragend", (e18) => {
        this.saveObject(this.editObject, this.editObject.id);
      });
    });
  }
  setInitialPosition() {
    this.loadMapPosition();
    this.initialPos = {
      lat: this.inputLat,
      lng: this.inputLng
    };
    this.initialZoom = this.inputZoom;
  }
  loadMapPosition() {
    this.inputLat = this.map?.getCenter().lat || 0;
    this.inputLng = this.map?.getCenter().lng || 0;
    this.inputZoom = this.map?.getZoom() || 0;
  }
  loadGeoLocation() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition((position) => {
        this.map?.setView([position.coords.latitude, position.coords.longitude], 13);
        this.loadMapPosition();
      });
    }
  }
  addLabel() {
    if (this.pinTitle) {
      this.pinDialog.hide();
      const marker3 = L4.marker([this.inputLat, this.inputLng], { icon: icons5.RED }).addTo(this.map).bindPopup(this.pinTitle).openPopup();
      this.markers.push({
        lat: this.inputLat,
        lng: this.inputLng,
        title: this.pinTitle
      });
      this.markers = [...this.markers];
      this.pinTitle = "";
    }
  }
  clearEditObject() {
    if (this.editObjectMarkers.length > 0) {
      this.editObjectMarkers.forEach((marker3) => {
        this.map?.removeLayer(marker3);
      });
      this.editObjectMarkers = [];
    }
    if (this.editObject) {
      this.editObject = void 0;
    }
  }
  saveObject(o15, id3 = void 0) {
    const checkIfObjectExists = this.objects.hasOwnProperty(id3);
    if (!id3) {
      id3 = crypto.randomUUID();
      o15.id = id3;
    }
    this.objects[id3] = {
      id: id3,
      type: o15 instanceof L4.Rectangle ? "rectangle" : o15 instanceof L4.Circle ? "circle" : o15 instanceof L4.Polygon ? "polygon" : o15 instanceof L4.Polyline ? "polyline" : "unknown",
      latlngs: o15 instanceof L4.Rectangle ? o15.getBounds() : o15 instanceof L4.Circle ? o15.getLatLng() : o15 instanceof L4.Polygon ? o15.getLatLngs() : o15 instanceof L4.Polyline ? o15.getLatLngs() : void 0,
      radius: o15 instanceof L4.Circle ? o15.getRadius() : void 0,
      borderColor: o15.options.color,
      fillColor: o15.options.fillColor,
      borderOpacity: o15.options.opacity,
      fillOpacity: o15.options.fillOpacity,
      label: this.inputDrawObjectLabel
    };
    this.objects = { ...this.objects };
  }
  deleteObject(id3) {
    const checkIfObjectExists = this.objects.hasOwnProperty(id3);
    if (checkIfObjectExists) {
      delete this.objects[id3];
      this.objects = { ...this.objects };
    }
  }
  loadObjects() {
    for (let key in this.objects) {
      const o15 = this.objects[key];
      switch (o15.type) {
        case "rectangle":
          const rectangle2 = L4.rectangle(
            [
              [o15.latlngs._northEast.lat, o15.latlngs._northEast.lng],
              [o15.latlngs._southWest.lat, o15.latlngs._southWest.lng]
            ],
            {
              color: o15.borderColor,
              fillColor: o15.fillColor,
              opacity: o15.borderOpacity,
              fillOpacity: o15.fillOpacity
            }
          ).addTo(this.map);
          rectangle2.id = o15.id;
          rectangle2.on("click", (e17) => {
            this.onRectangleClick(e17);
          });
          if (o15.label) {
            rectangle2.bindTooltip(o15.label, {
              direction: "center"
            });
          }
          break;
        case "circle":
          const circle2 = L4.circle([o15.latlngs.lat, o15.latlngs.lng], {
            radius: o15.radius,
            color: o15.borderColor,
            fillColor: o15.fillColor,
            opacity: o15.borderOpacity,
            fillOpacity: o15.fillOpacity
          }).addTo(this.map);
          circle2.id = o15.id;
          circle2.on("click", (e17) => {
            this.onCircleClick(e17);
          });
          if (o15.label) {
            circle2.bindTooltip(o15.label, {
              direction: "center"
            });
          }
          break;
        case "polygon":
          const polygon2 = L4.polygon(o15.latlngs, {
            color: o15.borderColor,
            fillColor: o15.fillColor,
            opacity: o15.borderOpacity,
            fillOpacity: o15.fillOpacity
          }).addTo(this.map);
          polygon2.id = o15.id;
          polygon2.on("click", (e17) => {
            this.onPolygonClick(e17);
          });
          if (o15.label) {
            polygon2.bindTooltip(o15.label, {
              direction: "center"
            });
          }
          break;
        case "polyline":
          const polyline2 = L4.polyline(o15.latlngs, {
            color: o15.borderColor,
            fillColor: o15.fillColor,
            opacity: o15.borderOpacity,
            fillOpacity: o15.fillOpacity
          }).addTo(this.map);
          polyline2.id = o15.id;
          polyline2.on("click", (e17) => {
            this.onPolylineClick(e17);
          });
          if (o15.label) {
            polyline2.bindTooltip(o15.label, {
              direction: "center"
            });
          }
          break;
        default:
          break;
      }
    }
  }
  getOpacity(hex) {
    const a72 = parseInt(hex.substring(6, 8), 16);
    return Math.round(a72 / 255 * 100);
  }
  deleteSelectedObject() {
    if (this.editObject) {
      this.map?.removeLayer(this.editObject);
      this.deleteObject(this.editObject.id);
      this.clearEditObject();
    }
  }
};
_init26 = __decoratorStart7(_a32);
_mapElement = /* @__PURE__ */ new WeakMap();
_pinDialog = /* @__PURE__ */ new WeakMap();
_map = /* @__PURE__ */ new WeakMap();
_initialPos = /* @__PURE__ */ new WeakMap();
_mapBounds = /* @__PURE__ */ new WeakMap();
_maxZoom = /* @__PURE__ */ new WeakMap();
_minZoom = /* @__PURE__ */ new WeakMap();
_initialZoom = /* @__PURE__ */ new WeakMap();
_markers = /* @__PURE__ */ new WeakMap();
_objects = /* @__PURE__ */ new WeakMap();
_customTileUrl = /* @__PURE__ */ new WeakMap();
_geoJSON = /* @__PURE__ */ new WeakMap();
_mapWidth = /* @__PURE__ */ new WeakMap();
_mapHeight = /* @__PURE__ */ new WeakMap();
_boundsActive = /* @__PURE__ */ new WeakMap();
_inputLat = /* @__PURE__ */ new WeakMap();
_inputLng = /* @__PURE__ */ new WeakMap();
_inputZoom = /* @__PURE__ */ new WeakMap();
_inputBorderColor = /* @__PURE__ */ new WeakMap();
_inputFillColor = /* @__PURE__ */ new WeakMap();
_inputDrawObjectLabel = /* @__PURE__ */ new WeakMap();
_pinTitle = /* @__PURE__ */ new WeakMap();
_mapMode = /* @__PURE__ */ new WeakMap();
_mouseMarker = /* @__PURE__ */ new WeakMap();
_showBounds = /* @__PURE__ */ new WeakMap();
_showBoundsLayer = /* @__PURE__ */ new WeakMap();
_editObject = /* @__PURE__ */ new WeakMap();
_editObjectMarkers = /* @__PURE__ */ new WeakMap();
_layerControl = /* @__PURE__ */ new WeakMap();
_drawObject = /* @__PURE__ */ new WeakMap();
__decorateElement7(_init26, 4, "mapElement", _mapElement_dec, WwMap, _mapElement);
__decorateElement7(_init26, 4, "pinDialog", _pinDialog_dec, WwMap, _pinDialog);
__decorateElement7(_init26, 4, "map", _map_dec, WwMap, _map);
__decorateElement7(_init26, 4, "initialPos", _initialPos_dec, WwMap, _initialPos);
__decorateElement7(_init26, 4, "mapBounds", _mapBounds_dec, WwMap, _mapBounds);
__decorateElement7(_init26, 4, "maxZoom", _maxZoom_dec, WwMap, _maxZoom);
__decorateElement7(_init26, 4, "minZoom", _minZoom_dec, WwMap, _minZoom);
__decorateElement7(_init26, 4, "initialZoom", _initialZoom_dec, WwMap, _initialZoom);
__decorateElement7(_init26, 4, "markers", _markers_dec, WwMap, _markers);
__decorateElement7(_init26, 4, "objects", _objects_dec, WwMap, _objects);
__decorateElement7(_init26, 4, "customTileUrl", _customTileUrl_dec, WwMap, _customTileUrl);
__decorateElement7(_init26, 4, "geoJSON", _geoJSON_dec, WwMap, _geoJSON);
__decorateElement7(_init26, 4, "mapWidth", _mapWidth_dec, WwMap, _mapWidth);
__decorateElement7(_init26, 4, "mapHeight", _mapHeight_dec, WwMap, _mapHeight);
__decorateElement7(_init26, 4, "boundsActive", _boundsActive_dec, WwMap, _boundsActive);
__decorateElement7(_init26, 4, "inputLat", _inputLat_dec, WwMap, _inputLat);
__decorateElement7(_init26, 4, "inputLng", _inputLng_dec, WwMap, _inputLng);
__decorateElement7(_init26, 4, "inputZoom", _inputZoom_dec, WwMap, _inputZoom);
__decorateElement7(_init26, 4, "inputBorderColor", _inputBorderColor_dec, WwMap, _inputBorderColor);
__decorateElement7(_init26, 4, "inputFillColor", _inputFillColor_dec, WwMap, _inputFillColor);
__decorateElement7(_init26, 4, "inputDrawObjectLabel", _inputDrawObjectLabel_dec, WwMap, _inputDrawObjectLabel);
__decorateElement7(_init26, 4, "pinTitle", _pinTitle_dec, WwMap, _pinTitle);
__decorateElement7(_init26, 4, "mapMode", _mapMode_dec, WwMap, _mapMode);
__decorateElement7(_init26, 4, "mouseMarker", _mouseMarker_dec, WwMap, _mouseMarker);
__decorateElement7(_init26, 4, "showBounds", _showBounds_dec, WwMap, _showBounds);
__decorateElement7(_init26, 4, "showBoundsLayer", _showBoundsLayer_dec, WwMap, _showBoundsLayer);
__decorateElement7(_init26, 4, "editObject", _editObject_dec, WwMap, _editObject);
__decorateElement7(_init26, 4, "editObjectMarkers", _editObjectMarkers_dec, WwMap, _editObjectMarkers);
__decorateElement7(_init26, 4, "layerControl", _layerControl_dec, WwMap, _layerControl);
__decorateElement7(_init26, 4, "drawObject", _drawObject_dec, WwMap, _drawObject);
WwMap = __decorateElement7(_init26, 0, "WwMap", _WwMap_decorators, WwMap);
WwMap.shadowRootOptions = { ...h62.shadowRootOptions, delegatesFocus: true };
__runInitializers7(_init26, 1, WwMap);
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/keyed.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/*! Bundled license information:

leaflet/dist/leaflet-src.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)

@webwriter/lit/index.js:
  (*! Bundled license information:
  
  @lit/reactive-element/css-tag.js:
    (**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/reactive-element.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  lit-html/lit-html.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  lit-element/lit-element.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  lit-html/is-server.js:
    (**
     * @license
     * Copyright 2022 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/custom-element.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/property.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/state.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/event-options.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/base.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-all.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-async.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-assigned-elements.js:
    (**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  
  @lit/reactive-element/decorators/query-assigned-nodes.js:
    (**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     *)
  *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lib/dom.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/modify-template.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/directive.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/part.js:
  (**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template-instance.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template-result.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/parts.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/template-factory.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/render.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/default-template-processor.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-html/lib/shady-render.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/updating-element.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/decorators.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)

lit-element/lib/css-tag.js:
  (**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   *)
*/
})();</script><style data-ww-editing="bundle">/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* ../../node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
@supports (scrollbar-gutter: stable) {
  .sl-scroll-lock {
    scrollbar-gutter: var(--sl-scroll-lock-gutter) !important;
  }
  .sl-scroll-lock body {
    overflow: hidden !important;
  }
}
@supports not (scrollbar-gutter: stable) {
  .sl-scroll-lock body {
    padding-right: var(--sl-scroll-lock-size) !important;
    overflow: hidden !important;
  }
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}

/* node_modules/@shoelace-style/shoelace/dist/themes/light.css */
:root,
:host,
.sl-theme-light {
  color-scheme: light;
  --sl-color-gray-50: hsl(0 0% 97.5%);
  --sl-color-gray-100: hsl(240 4.8% 95.9%);
  --sl-color-gray-200: hsl(240 5.9% 90%);
  --sl-color-gray-300: hsl(240 4.9% 83.9%);
  --sl-color-gray-400: hsl(240 5% 64.9%);
  --sl-color-gray-500: hsl(240 3.8% 46.1%);
  --sl-color-gray-600: hsl(240 5.2% 33.9%);
  --sl-color-gray-700: hsl(240 5.3% 26.1%);
  --sl-color-gray-800: hsl(240 3.7% 15.9%);
  --sl-color-gray-900: hsl(240 5.9% 10%);
  --sl-color-gray-950: hsl(240 7.3% 8%);
  --sl-color-red-50: hsl(0 85.7% 97.3%);
  --sl-color-red-100: hsl(0 93.3% 94.1%);
  --sl-color-red-200: hsl(0 96.3% 89.4%);
  --sl-color-red-300: hsl(0 93.5% 81.8%);
  --sl-color-red-400: hsl(0 90.6% 70.8%);
  --sl-color-red-500: hsl(0 84.2% 60.2%);
  --sl-color-red-600: hsl(0 72.2% 50.6%);
  --sl-color-red-700: hsl(0 73.7% 41.8%);
  --sl-color-red-800: hsl(0 70% 35.3%);
  --sl-color-red-900: hsl(0 62.8% 30.6%);
  --sl-color-red-950: hsl(0 60% 19.6%);
  --sl-color-orange-50: hsl(33.3 100% 96.5%);
  --sl-color-orange-100: hsl(34.3 100% 91.8%);
  --sl-color-orange-200: hsl(32.1 97.7% 83.1%);
  --sl-color-orange-300: hsl(30.7 97.2% 72.4%);
  --sl-color-orange-400: hsl(27 96% 61%);
  --sl-color-orange-500: hsl(24.6 95% 53.1%);
  --sl-color-orange-600: hsl(20.5 90.2% 48.2%);
  --sl-color-orange-700: hsl(17.5 88.3% 40.4%);
  --sl-color-orange-800: hsl(15 79.1% 33.7%);
  --sl-color-orange-900: hsl(15.3 74.6% 27.8%);
  --sl-color-orange-950: hsl(15.2 69.1% 19%);
  --sl-color-amber-50: hsl(48 100% 96.1%);
  --sl-color-amber-100: hsl(48 96.5% 88.8%);
  --sl-color-amber-200: hsl(48 96.6% 76.7%);
  --sl-color-amber-300: hsl(45.9 96.7% 64.5%);
  --sl-color-amber-400: hsl(43.3 96.4% 56.3%);
  --sl-color-amber-500: hsl(37.7 92.1% 50.2%);
  --sl-color-amber-600: hsl(32.1 94.6% 43.7%);
  --sl-color-amber-700: hsl(26 90.5% 37.1%);
  --sl-color-amber-800: hsl(22.7 82.5% 31.4%);
  --sl-color-amber-900: hsl(21.7 77.8% 26.5%);
  --sl-color-amber-950: hsl(22.9 74.1% 16.7%);
  --sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
  --sl-color-yellow-100: hsl(54.9 96.7% 88%);
  --sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
  --sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
  --sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
  --sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
  --sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
  --sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
  --sl-color-yellow-800: hsl(31.8 81% 28.8%);
  --sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
  --sl-color-yellow-950: hsl(33.1 69% 13.9%);
  --sl-color-lime-50: hsl(78.3 92% 95.1%);
  --sl-color-lime-100: hsl(79.6 89.1% 89.2%);
  --sl-color-lime-200: hsl(80.9 88.5% 79.6%);
  --sl-color-lime-300: hsl(82 84.5% 67.1%);
  --sl-color-lime-400: hsl(82.7 78% 55.5%);
  --sl-color-lime-500: hsl(83.7 80.5% 44.3%);
  --sl-color-lime-600: hsl(84.8 85.2% 34.5%);
  --sl-color-lime-700: hsl(85.9 78.4% 27.3%);
  --sl-color-lime-800: hsl(86.3 69% 22.7%);
  --sl-color-lime-900: hsl(87.6 61.2% 20.2%);
  --sl-color-lime-950: hsl(86.5 60.6% 13.9%);
  --sl-color-green-50: hsl(138.5 76.5% 96.7%);
  --sl-color-green-100: hsl(140.6 84.2% 92.5%);
  --sl-color-green-200: hsl(141 78.9% 85.1%);
  --sl-color-green-300: hsl(141.7 76.6% 73.1%);
  --sl-color-green-400: hsl(141.9 69.2% 58%);
  --sl-color-green-500: hsl(142.1 70.6% 45.3%);
  --sl-color-green-600: hsl(142.1 76.2% 36.3%);
  --sl-color-green-700: hsl(142.4 71.8% 29.2%);
  --sl-color-green-800: hsl(142.8 64.2% 24.1%);
  --sl-color-green-900: hsl(143.8 61.2% 20.2%);
  --sl-color-green-950: hsl(144.3 60.7% 12%);
  --sl-color-emerald-50: hsl(151.8 81% 95.9%);
  --sl-color-emerald-100: hsl(149.3 80.4% 90%);
  --sl-color-emerald-200: hsl(152.4 76% 80.4%);
  --sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
  --sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
  --sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
  --sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
  --sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
  --sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
  --sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
  --sl-color-emerald-950: hsl(164.3 87.5% 9.4%);
  --sl-color-teal-50: hsl(166.2 76.5% 96.7%);
  --sl-color-teal-100: hsl(167.2 85.5% 89.2%);
  --sl-color-teal-200: hsl(168.4 83.8% 78.2%);
  --sl-color-teal-300: hsl(170.6 76.9% 64.3%);
  --sl-color-teal-400: hsl(172.5 66% 50.4%);
  --sl-color-teal-500: hsl(173.4 80.4% 40%);
  --sl-color-teal-600: hsl(174.7 83.9% 31.6%);
  --sl-color-teal-700: hsl(175.3 77.4% 26.1%);
  --sl-color-teal-800: hsl(176.1 69.4% 21.8%);
  --sl-color-teal-900: hsl(175.9 60.8% 19%);
  --sl-color-teal-950: hsl(176.5 58.6% 11.4%);
  --sl-color-cyan-50: hsl(183.2 100% 96.3%);
  --sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
  --sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
  --sl-color-cyan-300: hsl(187 92.4% 69%);
  --sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
  --sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
  --sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
  --sl-color-cyan-700: hsl(192.9 82.3% 31%);
  --sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
  --sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
  --sl-color-cyan-950: hsl(196.8 61% 16.1%);
  --sl-color-sky-50: hsl(204 100% 97.1%);
  --sl-color-sky-100: hsl(204 93.8% 93.7%);
  --sl-color-sky-200: hsl(200.6 94.4% 86.1%);
  --sl-color-sky-300: hsl(199.4 95.5% 73.9%);
  --sl-color-sky-400: hsl(198.4 93.2% 59.6%);
  --sl-color-sky-500: hsl(198.6 88.7% 48.4%);
  --sl-color-sky-600: hsl(200.4 98% 39.4%);
  --sl-color-sky-700: hsl(201.3 96.3% 32.2%);
  --sl-color-sky-800: hsl(201 90% 27.5%);
  --sl-color-sky-900: hsl(202 80.3% 23.9%);
  --sl-color-sky-950: hsl(202.3 73.8% 16.5%);
  --sl-color-blue-50: hsl(213.8 100% 96.9%);
  --sl-color-blue-100: hsl(214.3 94.6% 92.7%);
  --sl-color-blue-200: hsl(213.3 96.9% 87.3%);
  --sl-color-blue-300: hsl(211.7 96.4% 78.4%);
  --sl-color-blue-400: hsl(213.1 93.9% 67.8%);
  --sl-color-blue-500: hsl(217.2 91.2% 59.8%);
  --sl-color-blue-600: hsl(221.2 83.2% 53.3%);
  --sl-color-blue-700: hsl(224.3 76.3% 48%);
  --sl-color-blue-800: hsl(225.9 70.7% 40.2%);
  --sl-color-blue-900: hsl(224.4 64.3% 32.9%);
  --sl-color-blue-950: hsl(226.2 55.3% 18.4%);
  --sl-color-indigo-50: hsl(225.9 100% 96.7%);
  --sl-color-indigo-100: hsl(226.5 100% 93.9%);
  --sl-color-indigo-200: hsl(228 96.5% 88.8%);
  --sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
  --sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
  --sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
  --sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
  --sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
  --sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
  --sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
  --sl-color-indigo-950: hsl(243.5 43.6% 22.9%);
  --sl-color-violet-50: hsl(250 100% 97.6%);
  --sl-color-violet-100: hsl(251.4 91.3% 95.5%);
  --sl-color-violet-200: hsl(250.5 95.2% 91.8%);
  --sl-color-violet-300: hsl(252.5 94.7% 85.1%);
  --sl-color-violet-400: hsl(255.1 91.7% 76.3%);
  --sl-color-violet-500: hsl(258.3 89.5% 66.3%);
  --sl-color-violet-600: hsl(262.1 83.3% 57.8%);
  --sl-color-violet-700: hsl(263.4 70% 50.4%);
  --sl-color-violet-800: hsl(263.4 69.3% 42.2%);
  --sl-color-violet-900: hsl(263.5 67.4% 34.9%);
  --sl-color-violet-950: hsl(265.1 61.5% 21.4%);
  --sl-color-purple-50: hsl(270 100% 98%);
  --sl-color-purple-100: hsl(268.7 100% 95.5%);
  --sl-color-purple-200: hsl(268.6 100% 91.8%);
  --sl-color-purple-300: hsl(269.2 97.4% 85.1%);
  --sl-color-purple-400: hsl(270 95.2% 75.3%);
  --sl-color-purple-500: hsl(270.7 91% 65.1%);
  --sl-color-purple-600: hsl(271.5 81.3% 55.9%);
  --sl-color-purple-700: hsl(272.1 71.7% 47.1%);
  --sl-color-purple-800: hsl(272.9 67.2% 39.4%);
  --sl-color-purple-900: hsl(273.6 65.6% 32%);
  --sl-color-purple-950: hsl(276 59.5% 16.5%);
  --sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
  --sl-color-fuchsia-100: hsl(287 100% 95.5%);
  --sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
  --sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
  --sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
  --sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
  --sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
  --sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
  --sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
  --sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
  --sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);
  --sl-color-pink-50: hsl(327.3 73.3% 97.1%);
  --sl-color-pink-100: hsl(325.7 77.8% 94.7%);
  --sl-color-pink-200: hsl(325.9 84.6% 89.8%);
  --sl-color-pink-300: hsl(327.4 87.1% 81.8%);
  --sl-color-pink-400: hsl(328.6 85.5% 70.2%);
  --sl-color-pink-500: hsl(330.4 81.2% 60.4%);
  --sl-color-pink-600: hsl(333.3 71.4% 50.6%);
  --sl-color-pink-700: hsl(335.1 77.6% 42%);
  --sl-color-pink-800: hsl(335.8 74.4% 35.3%);
  --sl-color-pink-900: hsl(335.9 69% 30.4%);
  --sl-color-pink-950: hsl(336.2 65.4% 15.9%);
  --sl-color-rose-50: hsl(355.7 100% 97.3%);
  --sl-color-rose-100: hsl(355.6 100% 94.7%);
  --sl-color-rose-200: hsl(352.7 96.1% 90%);
  --sl-color-rose-300: hsl(352.6 95.7% 81.8%);
  --sl-color-rose-400: hsl(351.3 94.5% 71.4%);
  --sl-color-rose-500: hsl(349.7 89.2% 60.2%);
  --sl-color-rose-600: hsl(346.8 77.2% 49.8%);
  --sl-color-rose-700: hsl(345.3 82.7% 40.8%);
  --sl-color-rose-800: hsl(343.4 79.7% 34.7%);
  --sl-color-rose-900: hsl(341.5 75.5% 30.4%);
  --sl-color-rose-950: hsl(341.3 70.1% 17.1%);
  --sl-color-primary-50: var(--sl-color-sky-50);
  --sl-color-primary-100: var(--sl-color-sky-100);
  --sl-color-primary-200: var(--sl-color-sky-200);
  --sl-color-primary-300: var(--sl-color-sky-300);
  --sl-color-primary-400: var(--sl-color-sky-400);
  --sl-color-primary-500: var(--sl-color-sky-500);
  --sl-color-primary-600: var(--sl-color-sky-600);
  --sl-color-primary-700: var(--sl-color-sky-700);
  --sl-color-primary-800: var(--sl-color-sky-800);
  --sl-color-primary-900: var(--sl-color-sky-900);
  --sl-color-primary-950: var(--sl-color-sky-950);
  --sl-color-success-50: var(--sl-color-green-50);
  --sl-color-success-100: var(--sl-color-green-100);
  --sl-color-success-200: var(--sl-color-green-200);
  --sl-color-success-300: var(--sl-color-green-300);
  --sl-color-success-400: var(--sl-color-green-400);
  --sl-color-success-500: var(--sl-color-green-500);
  --sl-color-success-600: var(--sl-color-green-600);
  --sl-color-success-700: var(--sl-color-green-700);
  --sl-color-success-800: var(--sl-color-green-800);
  --sl-color-success-900: var(--sl-color-green-900);
  --sl-color-success-950: var(--sl-color-green-950);
  --sl-color-warning-50: var(--sl-color-amber-50);
  --sl-color-warning-100: var(--sl-color-amber-100);
  --sl-color-warning-200: var(--sl-color-amber-200);
  --sl-color-warning-300: var(--sl-color-amber-300);
  --sl-color-warning-400: var(--sl-color-amber-400);
  --sl-color-warning-500: var(--sl-color-amber-500);
  --sl-color-warning-600: var(--sl-color-amber-600);
  --sl-color-warning-700: var(--sl-color-amber-700);
  --sl-color-warning-800: var(--sl-color-amber-800);
  --sl-color-warning-900: var(--sl-color-amber-900);
  --sl-color-warning-950: var(--sl-color-amber-950);
  --sl-color-danger-50: var(--sl-color-red-50);
  --sl-color-danger-100: var(--sl-color-red-100);
  --sl-color-danger-200: var(--sl-color-red-200);
  --sl-color-danger-300: var(--sl-color-red-300);
  --sl-color-danger-400: var(--sl-color-red-400);
  --sl-color-danger-500: var(--sl-color-red-500);
  --sl-color-danger-600: var(--sl-color-red-600);
  --sl-color-danger-700: var(--sl-color-red-700);
  --sl-color-danger-800: var(--sl-color-red-800);
  --sl-color-danger-900: var(--sl-color-red-900);
  --sl-color-danger-950: var(--sl-color-red-950);
  --sl-color-neutral-50: var(--sl-color-gray-50);
  --sl-color-neutral-100: var(--sl-color-gray-100);
  --sl-color-neutral-200: var(--sl-color-gray-200);
  --sl-color-neutral-300: var(--sl-color-gray-300);
  --sl-color-neutral-400: var(--sl-color-gray-400);
  --sl-color-neutral-500: var(--sl-color-gray-500);
  --sl-color-neutral-600: var(--sl-color-gray-600);
  --sl-color-neutral-700: var(--sl-color-gray-700);
  --sl-color-neutral-800: var(--sl-color-gray-800);
  --sl-color-neutral-900: var(--sl-color-gray-900);
  --sl-color-neutral-950: var(--sl-color-gray-950);
  --sl-color-neutral-0: hsl(0, 0%, 100%);
  --sl-color-neutral-1000: hsl(0, 0%, 0%);
  --sl-border-radius-small: 0.1875rem;
  --sl-border-radius-medium: 0.25rem;
  --sl-border-radius-large: 0.5rem;
  --sl-border-radius-x-large: 1rem;
  --sl-border-radius-circle: 50%;
  --sl-border-radius-pill: 9999px;
  --sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
  --sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
  --sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);
  --sl-spacing-3x-small: 0.125rem;
  --sl-spacing-2x-small: 0.25rem;
  --sl-spacing-x-small: 0.5rem;
  --sl-spacing-small: 0.75rem;
  --sl-spacing-medium: 1rem;
  --sl-spacing-large: 1.25rem;
  --sl-spacing-x-large: 1.75rem;
  --sl-spacing-2x-large: 2.25rem;
  --sl-spacing-3x-large: 3rem;
  --sl-spacing-4x-large: 4.5rem;
  --sl-transition-x-slow: 1000ms;
  --sl-transition-slow: 500ms;
  --sl-transition-medium: 250ms;
  --sl-transition-fast: 150ms;
  --sl-transition-x-fast: 50ms;
  --sl-font-mono:
    SFMono-Regular,
    Consolas,
    "Liberation Mono",
    Menlo,
    monospace;
  --sl-font-sans:
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Helvetica,
    Arial,
    sans-serif,
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol";
  --sl-font-serif:
    Georgia,
    "Times New Roman",
    serif;
  --sl-font-size-2x-small: 0.625rem;
  --sl-font-size-x-small: 0.75rem;
  --sl-font-size-small: 0.875rem;
  --sl-font-size-medium: 1rem;
  --sl-font-size-large: 1.25rem;
  --sl-font-size-x-large: 1.5rem;
  --sl-font-size-2x-large: 2.25rem;
  --sl-font-size-3x-large: 3rem;
  --sl-font-size-4x-large: 4.5rem;
  --sl-font-weight-light: 300;
  --sl-font-weight-normal: 400;
  --sl-font-weight-semibold: 500;
  --sl-font-weight-bold: 700;
  --sl-letter-spacing-denser: -0.03em;
  --sl-letter-spacing-dense: -0.015em;
  --sl-letter-spacing-normal: normal;
  --sl-letter-spacing-loose: 0.075em;
  --sl-letter-spacing-looser: 0.15em;
  --sl-line-height-denser: 1;
  --sl-line-height-dense: 1.4;
  --sl-line-height-normal: 1.8;
  --sl-line-height-loose: 2.2;
  --sl-line-height-looser: 2.6;
  --sl-focus-ring-color: var(--sl-color-primary-600);
  --sl-focus-ring-style: solid;
  --sl-focus-ring-width: 3px;
  --sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);
  --sl-focus-ring-offset: 1px;
  --sl-button-font-size-small: var(--sl-font-size-x-small);
  --sl-button-font-size-medium: var(--sl-font-size-small);
  --sl-button-font-size-large: var(--sl-font-size-medium);
  --sl-input-height-small: 1.875rem;
  --sl-input-height-medium: 2.5rem;
  --sl-input-height-large: 3.125rem;
  --sl-input-background-color: var(--sl-color-neutral-0);
  --sl-input-background-color-hover: var(--sl-input-background-color);
  --sl-input-background-color-focus: var(--sl-input-background-color);
  --sl-input-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-border-color: var(--sl-color-neutral-300);
  --sl-input-border-color-hover: var(--sl-color-neutral-400);
  --sl-input-border-color-focus: var(--sl-color-primary-500);
  --sl-input-border-color-disabled: var(--sl-color-neutral-300);
  --sl-input-border-width: 1px;
  --sl-input-required-content: "*";
  --sl-input-required-content-offset: -2px;
  --sl-input-required-content-color: var(--sl-input-label-color);
  --sl-input-border-radius-small: var(--sl-border-radius-medium);
  --sl-input-border-radius-medium: var(--sl-border-radius-medium);
  --sl-input-border-radius-large: var(--sl-border-radius-medium);
  --sl-input-font-family: var(--sl-font-sans);
  --sl-input-font-weight: var(--sl-font-weight-normal);
  --sl-input-font-size-small: var(--sl-font-size-small);
  --sl-input-font-size-medium: var(--sl-font-size-medium);
  --sl-input-font-size-large: var(--sl-font-size-large);
  --sl-input-letter-spacing: var(--sl-letter-spacing-normal);
  --sl-input-color: var(--sl-color-neutral-700);
  --sl-input-color-hover: var(--sl-color-neutral-700);
  --sl-input-color-focus: var(--sl-color-neutral-700);
  --sl-input-color-disabled: var(--sl-color-neutral-900);
  --sl-input-icon-color: var(--sl-color-neutral-500);
  --sl-input-icon-color-hover: var(--sl-color-neutral-600);
  --sl-input-icon-color-focus: var(--sl-color-neutral-600);
  --sl-input-placeholder-color: var(--sl-color-neutral-500);
  --sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
  --sl-input-spacing-small: var(--sl-spacing-small);
  --sl-input-spacing-medium: var(--sl-spacing-medium);
  --sl-input-spacing-large: var(--sl-spacing-large);
  --sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
  --sl-input-focus-ring-offset: 0;
  --sl-input-filled-background-color: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
  --sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
  --sl-input-filled-color: var(--sl-color-neutral-800);
  --sl-input-filled-color-hover: var(--sl-color-neutral-800);
  --sl-input-filled-color-focus: var(--sl-color-neutral-700);
  --sl-input-filled-color-disabled: var(--sl-color-neutral-800);
  --sl-input-label-font-size-small: var(--sl-font-size-small);
  --sl-input-label-font-size-medium: var(--sl-font-size-medium);
  --sl-input-label-font-size-large: var(--sl-font-size-large);
  --sl-input-label-color: inherit;
  --sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
  --sl-input-help-text-font-size-medium: var(--sl-font-size-small);
  --sl-input-help-text-font-size-large: var(--sl-font-size-medium);
  --sl-input-help-text-color: var(--sl-color-neutral-500);
  --sl-toggle-size-small: 0.875rem;
  --sl-toggle-size-medium: 1.125rem;
  --sl-toggle-size-large: 1.375rem;
  --sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);
  --sl-panel-background-color: var(--sl-color-neutral-0);
  --sl-panel-border-color: var(--sl-color-neutral-200);
  --sl-panel-border-width: 1px;
  --sl-tooltip-border-radius: var(--sl-border-radius-medium);
  --sl-tooltip-background-color: var(--sl-color-neutral-800);
  --sl-tooltip-color: var(--sl-color-neutral-0);
  --sl-tooltip-font-family: var(--sl-font-sans);
  --sl-tooltip-font-weight: var(--sl-font-weight-normal);
  --sl-tooltip-font-size: var(--sl-font-size-small);
  --sl-tooltip-line-height: var(--sl-line-height-dense);
  --sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
  --sl-tooltip-arrow-size: 6px;
  --sl-z-index-drawer: 700;
  --sl-z-index-dialog: 800;
  --sl-z-index-dropdown: 900;
  --sl-z-index-toast: 950;
  --sl-z-index-tooltip: 1000;
}
.sl-scroll-lock {
  padding-right: var(--sl-scroll-lock-size) !important;
  overflow: hidden !important;
}
.sl-toast-stack {
  position: fixed;
  top: 0;
  inset-inline-end: 0;
  z-index: var(--sl-z-index-toast);
  width: 28rem;
  max-width: 100%;
  max-height: 100%;
  overflow: auto;
}
.sl-toast-stack sl-alert {
  margin: var(--sl-spacing-medium);
}
.sl-toast-stack sl-alert::part(base) {
  box-shadow: var(--sl-shadow-large);
}
</style></head><body><p style="text-align: center;"><b><span><span style="font-size: 18pt"><span style="font-family: &quot;Arial Black&quot;">Urban development at a glance - grown, historically planned and modern planned cities</span></span></span></b></p><p>Work orders:</p><p>A1: EA(10 min) - Refresh your knowledge about the different urban development models by reading M1 and applying your knowledge in the quiz. </p><p>A2: PA (15 min) - Stand at the bus stop and find a tandem partner. Analyze the three cities together (M2) and give your opinion as to which type of city they are.</p><p style="border-width: 1px;"><b><u>M1:</u> </b></p><p>In the last few lessons, we have dealt intensively with the development of Central European cities and learned about three key models:</p><p data-start="147" data-end="565" style="text-align: justify;"><b>- Grown cities</b><br data-start="166" data-end="169">These cities have developed over many centuries without a fixed master plan. They have an irregular, often winding street network that has gradually adapted to the needs of the inhabitants. Historic old towns with central market squares and narrow alleyways are typical examples. Here, the townscape is created organically, i.e. through many small, often spontaneous decisions.</p><p data-start="567" data-end="997" style="text-align: justify;"><b>- Historically planned cities</b><br data-start="595" data-end="598">Cities were purposefully designed early on - often as an expression of power and representative self-expression. Typical features include a symmetrical, often geometrically laid out network of streets, prestigious buildings such as residences or castles and clearly defined areas. This planning usually took place in the age of absolutism, when princes and rulers used cities as centers of power.</p><p data-start="999" data-end="1485" style="text-align: justify;"><b>- Modern planned cities</b><br data-start="1023" data-end="1026">Since the middle of the 20th century, cities have been characterized by modern planning. Here, current concepts such as sustainability, efficient traffic management and the use of modern technologies come together. Modern urban planners determine from the outset how living, working and leisure areas can be sensibly arranged to create liveable and sustainable spaces.</p><p data-start="999" data-end="1485" style="text-align: justify;"><span>Here are four multiple-choice quiz questions to test your understanding of the three urban development models from M1:</span></p><webwriter-quiz id="ww-0416ec0d-e021-49a0-8179-a8cb4a3d07d2" class="ww-widget ww-v1.0.5"><webwriter-task class="ww-widget ww-v1.0.5" id="ww-98e826b6-8526-4355-9da1-f7fff9f00edd" counter="undefined" solution="data:application/octet-stream;base64,wvW/G4uXreTcA1NRwomER5UShg2HfTEuqkRYLk7WN7nopPynJsM45d8U2FhpUBgAQqhQxVr8PpcBCKA=" iv="data:application/octet-stream;base64,/zTtLb+2uc2LEDOZ" salt="data:application/octet-stream;base64,kXzLlQYeQjJDdAPNkehx9Q=="><webwriter-task-prompt class="ww-widget ww-v1.0.5" id="ww-196ee905-c813-4aca-846d-fd856b698f18" slot="prompt"><p>Which statement best applies to historically planned cities?</p></webwriter-task-prompt><webwriter-choice class="ww-widget ww-v1.0.5" id="ww-5d647122-36f3-4aea-ada9-466c1ca49e06" mode="single"><webwriter-choice-item id="ww-cf19182c-588a-41a9-abf7-cd476fb6d41f" class="ww-widget ww-v1.0.5" layout="list"><p>They develop organically and show an irregular cityscape</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-ee7669fa-bea2-4e6b-97fe-1ea3d06daf72" layout="list"><p>They were specifically designed to express power and representation, e.g. through a symmetrical, geometrically laid out street network</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-3294ec5d-812e-4157-99ce-c6067cd574d9" layout="list"><p>They are based on modern planning concepts such as sustainability</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-6df6f78d-9f00-417d-a05a-f355aff12039" layout="list"><p>They develop exclusively without state influence</p></webwriter-choice-item></webwriter-choice></webwriter-task><webwriter-task class="ww-widget ww-v1.0.5" id="ww-f6145dc8-d01b-421f-b466-7a7386f57c29" counter="undefined" solution="data:application/octet-stream;base64,pekRFeO9wQEDz/FtLSxCBdf/aAhPqte1AZsXt0EiaP8fdGIFY52O1Jj7e0jH81UtRm0OkkaomzrfHMo=" iv="data:application/octet-stream;base64,8Bs26H6XWHyAUz++" salt="data:application/octet-stream;base64,LBrsOxhUTHyITugt3nfkCw=="><webwriter-task-prompt class="ww-widget ww-v1.0.5" id="ww-fadf65df-5bd2-4725-99ba-43d426161f6c" slot="prompt"><p>What is the typical characteristic of a mature city?</p></webwriter-task-prompt><webwriter-choice class="ww-widget ww-v1.0.5" id="ww-55b30296-f9e4-45ef-9342-03b9d36386e5" mode="single"><webwriter-choice-item id="ww-6d339df3-80a1-4753-bc16-fcadf6344657" class="ww-widget ww-v1.0.5" layout="list"><p>A regularly laid out, symmetrical road network</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-df46611f-9052-4772-97fb-61014fb13064" layout="list"><p>An irregular, often winding network of streets with central market squares</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-2145dd22-3ed6-4b44-8591-04e387179e36" layout="list"><p>Clear zoning into living, working and leisure areas from the outset</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-405bad44-893e-4602-89e7-10cf9d30168b" layout="list"><p>The application of modern sustainability concepts</p></webwriter-choice-item></webwriter-choice></webwriter-task><webwriter-task class="ww-widget ww-v1.0.5" id="ww-524dceb3-f91c-4e3a-bb39-528050e2538f" counter="undefined" solution="data:application/octet-stream;base64,StPbIDYbnBME4r3W6BNlPzvi8HzM21Z/ZrtCa+OoI8iHawo9w9pMef4VV3EZbBclB2sKMWIvHFy+2Vo=" iv="data:application/octet-stream;base64,ugG85Sjnw7l3iIHG" salt="data:application/octet-stream;base64,78Kd1O5r/uj/4W1mEMBR4g=="><webwriter-task-prompt class="ww-widget ww-v1.0.5" id="ww-d0e5e699-65a6-4c7c-b808-02464d0dd963" slot="prompt"><p>Which statement best describes the difference between historically planned and modern planned cities?</p></webwriter-task-prompt><webwriter-choice class="ww-widget ww-v1.0.5" id="ww-a5d24ea7-fe30-4ae7-9a47-ee16535e8134" mode="single"><webwriter-choice-item id="ww-e8ea0924-c0ac-426e-ae47-0d60d41722f3" class="ww-widget ww-v1.0.5" layout="list"><p>Historically planned cities arise spontaneously, whereas modern planned cities are defined from the outset.</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-66bea714-528e-4eaf-98e7-91f06a7b0de1" layout="list"><p>Both types of city are characterized by identical planning principles.</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-a5819b53-5bcf-4861-8558-a432a93c3187" layout="list"><p>Modern planned cities are always smaller than historically planned cities.</p></webwriter-choice-item><webwriter-choice-item class="ww-widget ww-v1.0.5" id="ww-c67ee47a-1537-4285-bf7d-26ee158c5176" layout="list"><p>Historically planned cities often show a fixed, representative geometry, while modern planning pays more attention to the functional combination of different urban zones.</p></webwriter-choice-item></webwriter-choice></webwriter-task></webwriter-quiz><p data-start="999" data-end="1485" style="text-align: justify;"><b><u>M2:</u></b></p><p data-start="999" data-end="1485" style="text-align: justify;">City 1: Siena, Italy:</p><webwriter-map class="ProseMirror-selectednode ww-widget ww-v2.0.3" id="ww-f2d05362-f51c-4083-be91-888f3a8a38eb" initialpos="{&quot;lat&quot;:43.31855874686703,&quot;lng&quot;:11.33042335510254}" initialzoom="14" markers="[]" objects="{}" geojson="" mapwidth="100" mapheight="500" boundsactive="" customtileurl=""></webwriter-map><p data-start="999" data-end="1485" style="text-align: justify;">City 2: <span>Karlsruhe</span>: Germany</p><webwriter-map class="ProseMirror-selectednode ww-widget ww-v2.0.3" id="ww-90241434-ae7a-4303-9368-c834f8cd9cf0" initialpos="{&quot;lat&quot;:49.009050809382074,&quot;lng&quot;:8.410205841064455}" initialzoom="13" markers="[]" objects="{}" geojson="" mapwidth="100" mapheight="500" boundsactive="" customtileurl=""></webwriter-map><p data-start="999" data-end="1485" style="text-align: justify;">City 3: Milton Keynes: Great Britain</p><webwriter-map class="ProseMirror-selectednode ww-widget ww-v2.0.3" id="ww-f31e8555-eb0b-4a23-9eec-9f144ccf14a2" initialpos="{&quot;lat&quot;:52.03924056542519,&quot;lng&quot;:-0.7615756988525392}" initialzoom="14" markers="[]" objects="{}" geojson="" mapwidth="100" mapheight="500" boundsactive="" customtileurl=""></webwriter-map><p data-start="999" data-end="1485" style="text-align: justify;"></p><table><tfoot><tr></tr></tfoot></table></body></html>